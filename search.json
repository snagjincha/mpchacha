[
  {
    "objectID": "PP2023/posts/Appendix/2022-06-14-final.html",
    "href": "PP2023/posts/Appendix/2022-06-14-final.html",
    "title": "참고자료: 2022-06-final",
    "section": "",
    "text": "오픈 북, 2시간, 문제미리공개"
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-06-14-final.html#imports",
    "href": "PP2023/posts/Appendix/2022-06-14-final.html#imports",
    "title": "참고자료: 2022-06-final",
    "section": "0. imports",
    "text": "0. imports\n아래코드를 이용하여 numpy, matplotlib, pandas를 import하라.\n\nimport numpy as np\nimport matplotlib.pyplot as plt \nimport pandas as pd\nfrom IPython.display import HTML"
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-06-14-final.html#기본문제-50점",
    "href": "PP2023/posts/Appendix/2022-06-14-final.html#기본문제-50점",
    "title": "참고자료: 2022-06-final",
    "section": "1. 기본문제 (50점)",
    "text": "1. 기본문제 (50점)\n(1) 도함수를 구하는 함수 derivate를 선언하라. 이 함수를 이용하여 \\(f(x)=x^2\\)의 그래프와 \\(f'(x)=2x\\)의 그래프를 \\(x \\in (-1,1)\\)의 범위에서 그려라.\n(풀이)\n\ndef f(x): \n    return x**2 \n\n\ndef derivate(f): \n    def df(x): \n        h=0.000000000001\n        return (f(x+h)-f(x))/h \n    return df\n\n\nx = np.linspace(-1,1,100)\nplt.plot(x,f(x))\nplt.plot(x,derivate(f)(x))\n\n\n\n\n(2) 적당한 클래스 정의하여 인스턴스 a를 만들고 print(a)의 출력결과가 본인의 학번이 나오도록 하라.\n(풀이)\n\nclass Klass:\n    def __str__(self):\n        return('2022-43052')\n\n\na=Klass()\nprint(a)\n\n2022-43052\n\n\n(3) for문이 실행될때마다 [묵,찌,빠] 중에 하나를 내며 빠를 누적 3회 낼경우 for문이 멈추는 이터레이터를 생성하라.\n(풀이)\n\nclass Klass: # 찌를 내는순간 for문이 멈추도록 하는 이터레이터를 만들자\n    def __init__(self): \n        self.candidate = [\"묵\",\"찌\",\"빠\"] \n        self.dic = {'묵':0,'찌':0,'빠':0}\n    def __iter__(self):\n        return self \n    def __next__(self):\n        action = np.random.choice(self.candidate)\n        self.dic[action] += 1\n        if self.dic['빠']==3:\n            print(\"빠가 3번 누적되어 for문을 멈춥니다\")\n            raise StopIteration\n        else:\n            return action\n\n\na=Klass()\nfor i in a:\n    print(i)\n\n빠\n묵\n빠\n빠가 3번 누적되어 for문을 멈춥니다\n\n\n(4)-(6)\n\nclass GS25: \n    n=0 \n    total_number_of_guests = 0 \n    def __init__(self):\n        self.number_of_guests = 0 \n\n(4) 위의 클래스를 수정하여 아래와 같이 GS25에서 새로운 인스턴스가 생성될때마다\nGS25의 점포수가 ?개로 늘었습니다.\n라는 메시지가 출력되도록 하라.\n(5) 함수 come를 인스턴스 메소드로 정의하라. 이 메소드가 실행될때마다 각 점포의 손님 인스턴스 변수 number_of_guests와 클래스변수 total_number_of_guests를 1씩 증가시키고 아래의 메시지를 출력하라.\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 n명입니다. \n현재 GS25 점포를 방문한 손님수는 m명입니다. \n(6) 새로운 클래스메서드 show를 만들고 아래와 같은 메시지를 출력하도록 하라.\nGS25의 점포수: ??\nGS25를 방문한 총 손님수: ??\n(풀이)\n\nclass GS25: \n    n=0 \n    total_number_of_guests = 0 \n    def __init__(self):\n        self.number_of_guests = 0 \n        GS25.n += 1 \n        print(\"GS25의 점포수가 {}개로 늘었습니다.\".format(GS25.n))\n    def come(self):\n        GS25.total_number_of_guests += 1 \n        self.number_of_guests += 1\n        print(\"새로운 손님이 오셨습니다!\")\n        print(\"GS25를 방문한 총 손님수는 {}명입니다.\".format(GS25.total_number_of_guests))\n        print(\"현재 GS25 점포를 방문한 손님수는 {}명입니다.\".format(self.number_of_guests))\n    @classmethod\n    def show(cls):\n        print(\"GS25의 점포수: {}\".format(cls.n))\n        print(\"GS25를 방문한 총 손님수: {}\".format(cls.total_number_of_guests))\n\n\na=GS25() ## (4)의 사용예시\n\nGS25의 점포수가 1개로 늘었습니다.\n\n\n\nb=GS25() ## (4)의 사용예시\n\nGS25의 점포수가 2개로 늘었습니다.\n\n\n\na.come() ## (5)의 사용예시\n\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 1명입니다.\n현재 GS25 점포를 방문한 손님수는 1명입니다.\n\n\n\na.come() ## (5)의 사용예시\n\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 2명입니다.\n현재 GS25 점포를 방문한 손님수는 2명입니다.\n\n\n\nb.come() ## (5)의 사용예시\n\n새로운 손님이 오셨습니다!\nGS25를 방문한 총 손님수는 3명입니다.\n현재 GS25 점포를 방문한 손님수는 1명입니다.\n\n\n\nGS25.show() ## (6)의 사용예시\n\nGS25의 점포수: 2\nGS25를 방문한 총 손님수: 3\n\n\n(7) __eq__는 연산 == 를 재정의하는 메소드이다. 클래스 RPS_BASE를 상속하여 새로운 클래스 RPS5를 만들라. 연산 ==를 재정의하여 RPS7의 두 인스턴스의 action이 같은 경우 true를 리턴하는 기능을 구현하라.\n\nclass RPS_BASE:\n    def __init__(self):\n        self.action = np.random.choice(['가위','바위','보'])\n\n(풀이)\n\nclass RPS7(RPS_BASE):\n    def __eq__(self,other):\n        return self.action == other.action \n\n\na=RPS7()\na.action\n\n'바위'\n\n\n\nb=RPS7()\nb.action\n\n'가위'\n\n\n\na==b\n\nFalse\n\n\n(8) __gt__는 연산 &gt; 를 재정의하는 메소드이다. 클래스 RPS_BASE를 상속하여 새로운 클래스 RPS6를 만들라. 연산 &gt;를 재정의하여 RPS6의 두 인스턴스 a,b의 action이 각각 (‘가위’,‘보’), (‘바위’,‘가위’), (‘보’,‘바위’) 인 경우 true를 리턴하는 기능을 구현하라.\n(풀이)\n\nclass RPS8(RPS_BASE):\n    def __gt__(self,other): # 연산 &gt; 를 재정의 \n        pair = self.action, other.action\n        return pair == ('가위','보') or pair == ('바위','가위') or pair == ('보','바위') \n\n\na=RPS8()\na.action\n\n'보'\n\n\n\nb=RPS8()\nb.action\n\n'가위'\n\n\n\na&gt;b, a&lt;b\n\n(False, True)\n\n\n(9)-(10)\n아래와 같은 데이터프레임을 선언하고 물음에 답하라.\n\nnp.random.seed(43052)\ndf=pd.DataFrame({'type':np.random.choice(['A','B'],100), 'score':np.random.randint(40,95,100)})\ndf\n\n\n\n\n\n\n\n\ntype\nscore\n\n\n\n\n0\nB\n45\n\n\n1\nA\n40\n\n\n2\nB\n79\n\n\n3\nB\n46\n\n\n4\nB\n57\n\n\n...\n...\n...\n\n\n95\nB\n69\n\n\n96\nA\n71\n\n\n97\nA\n93\n\n\n98\nA\n63\n\n\n99\nA\n82\n\n\n\n\n100 rows × 2 columns\n\n\n\n(9) type==’A’의 평균score를 구하는 코드를 작성하라.\n(풀이)\n\nm = df.query(\"type=='A'\").score.mean()\nm\n\n68.4\n\n\n(10) type==’A’의 평균score보다 같거나 큰 값을 가지는 행을 출력하라.\n(풀이)\n\n# \n# 아래모두 정답으로 인정 (문제설명이 불충분) \n# df.query(\"type=='A' and score &gt;= @m\") \n# df.query(\"score &gt;= @m\")"
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-06-14-final.html#가위-바위-보-하나빼기-150점",
    "href": "PP2023/posts/Appendix/2022-06-14-final.html#가위-바위-보-하나빼기-150점",
    "title": "참고자료: 2022-06-final",
    "section": "2. 가위, 바위, 보 하나빼기 (150점)",
    "text": "2. 가위, 바위, 보 하나빼기 (150점)\n\nclass RPS:\n    def __init__(self,candidate):\n        self.candidate = candidate\n        self.actions = list() \n        self.rewards = list()\n        self.prob = [0.5,0.5]\n\n    def __eq__(self,other): # 연산 == 를 재정의 \n        return self.actions[-1] == other.actions[-1] \n        #note: 둘의 액션이 같으면 무승부 \n    \n    def __gt__(self,other): # 연산 &gt; 를 재정의 \n        pair = self.actions[-1], other.actions[-1]\n        return pair == ('가위','보') or pair == ('바위','가위') or pair == ('보','바위') \n        #note: 가위&gt;보, 바위&gt;가위, 보&gt;가위 \n    \n    def __mul__(self,other):\n        # step1: 각자의 패를 선택 \n        self.choose()\n        other.choose()\n        \n        # step2: 승패 판단 + upate reward\n        if self == other: # 무승부일경우 \n            self.rewards.append(1)\n            other.rewards.append(1)\n        elif self &gt; other: # self의 승리 \n            self.rewards.append(2)\n            other.rewards.append(0)\n        else: # other의 승리 \n            self.rewards.append(0)\n            other.rewards.append(2)\n        \n        # step3: update data\n        self.update_data()\n        other.update_data()\n    \n    def update_data(self):\n        self.data = pd.DataFrame({'actions':self.actions, 'rewards':self.rewards})\n    \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} &lt;br/&gt; \n        데이터: &lt;br/&gt;\n        {}\n        \"\"\"        \n        return html_str.format(self.candidate,self.data._repr_html_())\n    \n    def choose(self):\n        self.actions.append(np.random.choice(self.candidate,p=self.prob))\n\n(1) 플레이어A는 (가위,가위) 중 하나를 선택할 수 있고 플레이어B는 (가위,바위) 중 하나를 선택할 수 있다. 각 플레이어는 각 패 중 하나를 랜덤으로 선택하는 액션을 한다고 가정하자. 아래에 해당하는 확률을 시뮬레이션을 이용하여 추정하라.\n\n플레이어A가 승리할 확률:\n플레이어B가 승리할 확률:\n플레이어A와 플레이어B가 비길 확률:\n\nhint: 50% 확률로 b가 승리하고 50% 확률로 비긴다.\n(풀이)\n\nPlayerA = RPS(['가위','가위']) \nPlayerB = RPS(['가위','바위']) \n\nfor _ in range(100):\n    PlayerA * PlayerB\n\n\nprint('플레이어A가 승리할 확률: {}'.format(sum(PlayerA.data.rewards==2)/100))\nprint('플레이어B가 승리할 확률: {}'.format(sum(PlayerA.data.rewards==0)/100))\nprint('플레이어A와 플레이어B가 비길 확률: {}'.format(sum(PlayerA.data.rewards==1)/100))\n\n플레이어A가 승리할 확률: 0.0\n플레이어B가 승리할 확률: 0.57\n플레이어A와 플레이어B가 비길 확률: 0.43\n\n\n(2) 문제 (1)과 같이 아래의 상황을 가정하자.\n\n\n\n\n플레이어A\n플레이어B\n\n\n\n\n각 플레이어가 낼 수 있는 패 (candidate)\n(가위,가위)\n(가위,바위)\n\n\n각 패를 선택할 확률 (prob)\n(0.5,0.5)\n(0.5,0.5)\n\n\n\n각 플레이어는 아래와 같은 규칙으로 가위바위보 결과에 따른 보상점수를 적립한다고 하자. - 승리: 보상점수 2점 적립 - 무승부: 보상점수 1점 적립 - 패배: 보상점수 0점 적립\n100번째 대결까지 시뮬레이션을 시행하고 플레이어B가 가위를 낼 경우 얻은 보상점수의 총합과 바위를 낼 경우 얻은 보상점수의 총합을 각각 구하라. 플레이어B는 가위를 내는것이 유리한가? 바위를 내는것이 유리한가?\nhint: 플레이어B는 바위를 내는 것이 유리하다.\nhint: 플레이어B가 100번중에 49번 가위를 내고 51번 바위를 낸다면 플레이어B가 적립할 보상점수는 각각 아래와 같다. - 가위를 내었을 경우: 49 * 1 = 49점 - 바위를 내었을 경우: 51 * 2 = 102점 - 총 보상점수 = 49점 + 102점 = 151점\n(풀이)\n\nprint('플레이어B가 가위를 낼 경우 얻은 보상점수의 총합: {}'.format(PlayerB.data.query(\" actions=='가위'\").rewards.sum()))\nprint('플레이어B가 바위를 낼 경우 얻은 보상점수의 총합: {}'.format(PlayerB.data.query(\" actions=='바위'\").rewards.sum()))\n\n플레이어B가 가위를 낼 경우 얻은 보상점수의 총합: 43\n플레이어B가 바위를 낼 경우 얻은 보상점수의 총합: 114\n\n\n(3) (2)에서 얻은 데이터를 학습하여 플레이어B가 “가위” 혹은 “바위” 를 선택할 확률을 매시점 조금씩 조정한다고 가정하자. 구체적으로는 현재시점까지 얻은 보상점수의 비율로 확률을 결정한다. 예를들어 플레이어B가 100회의 대결동안 누적한 보상점수의 총합이 아래와 같다고 하자.\n\n가위를 내었을 경우 보상점수 총합 = 50점\n바위를 내었을 경우 보상점수 총합 = 100점\n\n그렇다면 플레이어B는 각각 (50/150,100/150) 의 확률로 (가위,바위) 중 하나를 선택한다. 101번째 대결에 플레이어B가 가위를 내서 비겼다면 이후에는 (51/151,100/151) 의 확률로 (가위,바위) 중 하나를 선택한다. 102번째 대결에 플레이어B가 바위를 내서 이겼다면 이후에는 각각 (51/153,102/153) 의 확률로 (가위,바위) 중 하나를 선택한다. 이러한 상황을 요약하여 표로 정리하면 아래와 같다.\n\n\n\n\n\n\n\n\n\n시점\n플레이어B가 가위를 냈을 경우 얻은 점수 총합\n플레이어B가 바위를 냈을 경우 얻은 점수 총합\nt+1시점에서 플레이어B가 (가위,바위)를 낼 확률\n\n\n\n\nt=100\n50\n100\n(50/150, 100/150)\n\n\nt=101\n51\n100\n(51/151, 100/151)\n\n\nt=102\n51\n102\n(51/153, 102/153)\n\n\n\n이러한 방식으로 500회까지 게임을 진행하며 확률을 수정하였을 경우 501번째 대결에서 플레이어B가 (가위,바위)를 낼 확률은 각각 얼마인가?\nhint: 시간이 지날수록 플레이어B는 (가위,바위)중 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다.\n(풀이)\n\nclass RPS2(RPS):\n    def __init__(self,candidate):\n        # 기존내용\n        self.candidate = candidate\n        self.actions = list() \n        self.rewards = list()\n        self.prob = [0.5,0.5]\n        # 새롭게 정의하는 내용 \n        self.data = dict()\n        self.trainable=False # 학습모드 설정 \n        \n    def update_data(self):\n        a = self.actions[-1]\n        r = self.rewards[-1] \n        self.data[a] = self.data.get(a,0)+r \n        \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} &lt;br/&gt; \n        확률: {} &lt;br/&gt;\n        데이터: {} \n        \"\"\"        \n        return html_str.format(self.candidate,self.prob,self.data)\n    \n    def choose(self):\n        if self.trainable:  # if self.trainalbe==True: \n            a1 = self.candidate[0] # action1 \n            a2 = self.candidate[1] # action2 \n            r1 = self.data[a1] # reward from action1 \n            r2 = self.data[a2] # reward from action2 \n            self.prob = [r1/(r1+r2), r2/(r1+r2)] \n        self.actions.append(np.random.choice(self.candidate,p=self.prob))\n\n\nPlayerA=RPS2(['가위','가위'])\nPlayerB=RPS2(['가위','바위'])\n\n\n#\n# 1~100 \nPlayerA.trainable=False \nPlayerB.trainable=False \nfor _ in range(100):\n    PlayerA * PlayerB \n# 100~500     \nPlayerA.trainable=False \nPlayerB.trainable=True\nfor _ in range(400):\n    PlayerA * PlayerB \n\n\nPlayerB\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.1923536439665472, 0.8076463560334528] \n        데이터: {'바위': 678, '가위': 161} \n        \n\n\n\n앞으로 아래와 같은 용어를 사용한다.\n\n(정의) 어떠한 플레이어가 양손 중 하나를 선택하는 확률을 데이터를 바탕으로 매 순간 업데이트 한다면 그 플레이어는 “학습모드 상태이다”고 표현한다.\n(정의) 반대로 어떠한 플레이어가 양손 중 하나를 항상 동일한 확률로 낸다면 그 플레이어는 “학습모드 상태가 아니다”라고 표현한다.\n\n\n(4) 새로운 두명의 플레이어C와 플레이어D를 만들어라. 두 플레이어는 모두 동일하게 (가위,바위) 중 하나를 선택할 수 있다. 두 명의 플레이어는 100번째 대결까지는 두 가지 패중 하나를 랜덤하게 선택하고 101번째 대결부터 500번째 대결까지는 문제(3)의 플레이어B와 같은 방식으로 확률을 업데이트 하여 두 가지 패를 서로 다른 확률로 낸다고 하자. 즉 100번째 대결까지는 두 플레이어가 모두 학습모드 상태가 아니고 101번째부터 500번째 대결까지는 두 플레이어가 모두 학습모드 상태이다. 500번째 대결까지의 학습이 끝났을 경우 플레이어 C와 플레이어D가 각 패를 낼 확률은 각각 얼마인가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어C가 (가위,바위)를 낼 확률\n플레이어D가 (가위,바위)를 낼 확률\n비고\n\n\n\n\nt &lt;= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt &lt;= 500\n대결 데이터를 학습하여 수정한 확률\n대결 데이터를 학습하여 수정한 확률\n양쪽 플레이어 모두 학습모드임\n\n\n\nhint: 시간이 지날수록 두 플레이어 모두 바위를 내는 쪽이 유리하다는 것을 알게 될 것이다.\n(풀이)\n\nPlayerC=RPS2(['가위','바위'])\nPlayerD=RPS2(['가위','바위'])\n\n\n#\n# 1~100 \nPlayerC.trainable=False \nPlayerD.trainable=False \nfor _ in range(100):\n    PlayerC * PlayerD\n# 100~500     \nPlayerC.trainable=True\nPlayerD.trainable=True\nfor _ in range(400):\n    PlayerC * PlayerD \n\n\nPlayerC\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.07692307692307693, 0.9230769230769231] \n        데이터: {'바위': 469, '가위': 39} \n        \n\n\n\nPlayerD\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.07942973523421588, 0.9205702647657841] \n        데이터: {'바위': 453, '가위': 39} \n        \n\n\n\nC,D 모두 바위를 내는게 유리하다는걸 학습함\n\n(5) 새로운 플레이어 E와 F를 생각하자. 플레이어E와 플레이어F는 각각 (가위,바위) 그리고 (가위,보) 중 하나를 선택할 수 있다고 가정하자. 시뮬레이션 대결결과를 이용하여 아래의 확률을 근사적으로 추정하라.\n\n플레이어E가 승리할 확률:\n플레이어F가 승리할 확률:\n플레이어E와 플레이어F가 비길 확률:\n\nhint: 플레이어E가 가위를 낸다면 최소한 지지는 않기 때문에 플레이어E가 좀 더 유리한 패를 가지고 있다. 따라서 플레이어E의 결과가 더 좋을 것이다.\n(풀이)\n\nPlayerE=RPS(['가위','바위'])\nPlayerF=RPS(['가위','보']) \n\nfor _ in range(100):\n    PlayerE * PlayerF\n\nprint('플레이어E가 승리할 확률: {}'.format(sum(PlayerE.data.rewards==2)/100))\nprint('플레이어F가 승리할 확률: {}'.format(sum(PlayerE.data.rewards==0)/100))\nprint('플레이어E와 플레이어F가 비길 확률: {}'.format(sum(PlayerE.data.rewards==1)/100))\n\n플레이어E가 승리할 확률: 0.47\n플레이어F가 승리할 확률: 0.36\n플레이어E와 플레이어F가 비길 확률: 0.17\n\n\n\n두 플레이어 E,F가 모두 랜덤으로 낸다면 (바보처럼 낸다면) 플레이어 E가 더 유리하다.\n\n(6) (5)와 동일한 두 명의 플레이어E, F를 생각하자. 두 플레이어는 100회까지는 랜덤으로 자신의 패를 선택한다. 그리고 101회부터 500회까지는 플레이어F만 데이터로 부터 학습을 하여 수정된 확률을 사용한다. 500번의 대결이 끝나고 플레이어F가 (가위,보)를 선택하는 확률이 어떻게 업데이트 되어있는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt &lt;= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt &lt;= 500\n(1/2, 1/2)\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\n\nhint: 플레이어F는 보를 내는 것이 낫다고 생각할 것이다. (가위를 내면 지거나 비기지만 보를 내면 지거나 이긴다.)\n(풀이)\n\nPlayerE=RPS2(['가위','바위'])\nPlayerF=RPS2(['가위','보'])\n\n\n#\n# 1~100 \nPlayerE.trainable=False \nPlayerF.trainable=False \nfor _ in range(100):\n    PlayerE * PlayerF\n# 100~500     \nPlayerE.trainable=False\nPlayerF.trainable=True\nfor _ in range(400):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.5, 0.5] \n        데이터: {'바위': 112, '가위': 441} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.10067114093959731, 0.8993288590604027] \n        데이터: {'보': 402, '가위': 45} \n        \n\n\n\n플레이어F는 보를 내는게 더 유리하다는 것을 학습을 통하여 깨닫는다.\n\n(7) (6)번의 플레이어E와 플레이어F가 500회~1000회까지 추가로 게임을 한다. 이번에는 플레이어E만 데이터로부터 학습한다. 1000회까지 대결을 끝낸 이후 플레이어E가 (가위,바위)를 내는 확률은 어떻게 업데이트 되었는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt &lt;= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt &lt;= 500\n(1/2, 1/2)\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\nt &lt;= 1000\n데이터를 학습하여 수정한 확률\nt=500시점에 업데이트된 확률\n플레이어E는 학습모드 / 플레이어F는 학습모드아님\n\n\n\nhint: 플레이어F는 보를 내도록 학습되어 있다. 따라서 플레이어E가 바위를 내면 지고 가위를 내면 이길것이다. 따라서 플레이어E는 가위가 유리하다고 생각할 것이다.\n(풀이)\n\n# \n# 500~1000     \nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(500):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.902158273381295, 0.09784172661870504] \n        데이터: {'바위': 136, '가위': 1256} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.10067114093959731, 0.8993288590604027] \n        데이터: {'보': 528, '가위': 80} \n        \n\n\n\n플레이어E는 가위를 내는게 유리하다는걸 깨닫는다. (플레이어F는 지금 보만 내고 있으니까!)\n\n(8) (7)번의 플레이어E와 플레이어F가 1000회~30000회까지 추가로 게임을 한다. 이번에는 플레이어F만 데이터로부터 학습한다. 30000회까지 대결을 끝낸 이후 플레이어F가 (가위,보)를 내는 확률은 어떻게 업데이트 되었는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt &lt;= 100\n(1/2, 1/2)\n(1/2, 1/2)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt &lt;= 500\n(1/2, 1/2)\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\nt &lt;= 1000\n데이터를 학습하여 수정한 확률\nt=500시점에 업데이트된 확률\n플레이어E는 학습모드 / 플레이어F는 학습모드아님\n\n\nt &lt;= 30000\nt=1000시점에 업데이트된 확률\n데이터를 학습하여 수정한 확률\n플레이어E는 학습모드아님 / 플레이어F는 학습모드\n\n\n\nhint: 플레이어F는 원래 보가 유리하다고 생각하여 보를 자주 내도록 학습되었다. 하지만 플레이어E가 그러한 플레이어F의 성향을 파악하고 가위를 주로 내도록 학습하였다. 플레이어F는 그러한 플레이어E의 성향을 다시 파악하여 이번에는 가위을 자주 내는 것이 유리하다고 생각할 것이다.\n(풀이)\n\n# \n# 1000~30000 \nPlayerE.trainable=False\nPlayerF.trainable=True\nfor _ in range(29000):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.902158273381295, 0.09784172661870504] \n        데이터: {'바위': 4468, '가위': 33162} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.9214985023917028, 0.0785014976082972] \n        데이터: {'보': 1756, '가위': 20614} \n        \n\n\n\n플레이어 E가 가위만 내고 있으므로 플레이어 F는 지지 않기 위해서 가위를 내도록 학습한다.\n\n(9) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (3/4)의 확률로 가위를 (1/4)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt &lt;= 100\n(1/2, 1/2)\n(3/4, 1/4)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt &lt;= 1000\n데이터를 학습하여 수정한 확률\n(3/4, 1/4)\n플레이어E는 학습모드 / 플레이어F는 학습모드 아님\n\n\n\n(풀이)\n\nPlayerE=RPS2(['가위','바위'])\nPlayerF=RPS2(['가위','보'])\n\n\n#\n# 1~100 \nPlayerE.trainable=False \nPlayerF.trainable=False \nPlayerF.prob=[3/4,1/4]\nfor _ in range(100):\n    PlayerE * PlayerF\n# 100~1000     \nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(900):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.363831308077198, 0.636168691922802] \n        데이터: {'바위': 892, '가위': 509} \n        \n\n\n\n플레이어 E는 바위를 내는것이 좀 더 유리하다고 생각한다.\n\n(추가풀이)\n\n# 계속시행한다면?\nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(10000*100):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.1438411969483742, 0.8561588030516258] \n        데이터: {'바위': 1248374, '가위': 209736} \n        \n\n\n\nE가 가위를 냈을경우 보상의 기대값은 \\(1\\times 3/4 + 2 \\times 1/4 = 5/4\\) 이고 바위를 냈을경우 보상의 기대값은 \\(2\\times 3/4 + 0 \\times 1/4 = 6/4\\) 이므로 바위가 더 유리하다. 따라서 점점 바위를 내도록 학습한다.\n\n(10) 플레이어E와 플레이어F의 대결기록을 초기화 한다. 이번에는 플레이어F가 항상 (2/3)의 확률로 가위를 (1/3)의 확률로 보를 낸다고 가정한다. 플레이어E는 100번의 대결까지는 랜덤으로 (가위,바위)중 하나를 내고 101번째 대결부터 1000번째 대결까지는 대결 데이터를 학습하여 수정한 확률을 사용한다고 하자. 1000번째 대결이후에 플레이어E가 (가위,바위)를 내는 확률이 어떻게 업데이트 되어있는가?\n\n\n\n\n\n\n\n\n\n시점\n플레이어E가 (가위,바위)를 낼 확률\n플레이어F가 (가위,보)를 낼 확률\n비고\n\n\n\n\nt &lt;= 100\n(1/2, 1/2)\n(2/3, 1/3)\n양쪽 플레이어 모두 학습모드가 아님\n\n\nt &lt;= 1000\n데이터를 학습하여 수정한 확률\n(2/3, 1/3)\n플레이어E는 학습모드 / 플레이어F는 학습모드 아님\n\n\n\n(풀이)\n\nPlayerE=RPS2(['가위','바위'])\nPlayerF=RPS2(['가위','보'])\n\n\n#\n# 1~100 \nPlayerE.trainable=False \nPlayerF.trainable=False \nPlayerF.prob=[2/3,1/3]\nfor _ in range(100):\n    PlayerE * PlayerF\n# 100~1000     \nPlayerE.trainable=True\nPlayerF.trainable=False\nfor _ in range(900):\n    PlayerE * PlayerF\n\n\nPlayerE\n\n\n        낼 수 있는 패: ['가위', '바위']  \n        확률: [0.5139500734214391, 0.48604992657856094] \n        데이터: {'바위': 664, '가위': 700} \n        \n\n\n\nPlayerF\n\n\n        낼 수 있는 패: ['가위', '보']  \n        확률: [0.6666666666666666, 0.3333333333333333] \n        데이터: {'가위': 344, '보': 292} \n        \n\n\n\nE가 가위를 냈을경우 보상의 기대값은 \\(1\\times 2/3 + 2 \\times 1/3 = 4/3\\) 이고 바위를 냈을 경우 보상의 기대값은 \\(2\\times 2/3 + 0 \\times 1/3 = 4/3\\) 이므로 가위도 바위도 유리하지 않다. 따라서 가위와 바위를 어떠한 확률로 내든 상관없다.\n\n문제2의 추가해설\n(프로그래밍 팁)\n기본적인 구현기능인 RPS클래스를 상속을 이용하여 적절하게 modify하면 문제를 쉽게 풀 수 있습니다. 문항에 따라서 어떤것은 기본 RPS클래스를 쓰는것이 유리하고 어떠한 것은 새로운 클래스를 정의하는 것이 유리할 수 있습니다. 예를들어 2-(1),(2),(5)는 RPS클래스를 그대로 쓰는 것이 유리했으며 나머지는 새로운 클래스인 RPS2를 사용하는것이 문제풀이에 유리했습니다.\n(계산팁)\n추가확률을 계산할 경우 pandas의 dataframe을 이용하는 것보다 RPS2에서 제가 구현한 것 처럼 dict와 같은 내장자료형을 이용하는 것이 훨씬 연산속도가 빠릅니다. 가령 8번문제의 경우 알고리즘에 따라서 연산시간이 오래걸릴 수도 있는데 제가 짠 코드를 기반으로 코랩에서 돌리면 2.4116초 정도로 결과를 얻을 수 있습니다. 연산속도의 차이가 나는 이유는 (1) 기본적으로 판다스는 느리며 (2) RPS의 data에는 모든 자료를 저장는데 RPS2의 data는 각 패를 내었을 경우 보상의 누적만 저장하기 때문입니다. 최근 데이터량의 증가로 인하여 알고리즘의 효율성을 생각해야할 때도 있는데요, 본인이 구현한 코드와 정답코드를 비교해가며 계산시간을 테스트해보는것도 좋은 경험일 것 같습니다. 계산시간을 측정하는 것은 4월18일 강의노트에 사용한 방법을 참고하시면 됩니다.\n(약간의 개념해설)\n이 문제는 제로섬게임의 확장입니다. (양쪽 플레이어의 보상합이 일정하므로 이러한 게임을 constantsum 이라고 부릅니다) 어떤 분은 이 문제를 보고 게임이론을 떠올릴 수 있고 어떤 분은 강화학습을 떠올렸을 것 같습니다.\n문제의 포인트는 상대방의 전략에 따라서 나의 최적전략이 끝없이 달라진다는 점입니다. 문항 (5)-(10)까지의 문제는 이러한 상황을 묘사합니다. 직관적으로는 더 좋은패를 가지고 있는 플레이어E가 유리할 듯 하지만 결국 상대의 패를 보고 전략을 끝없이 수정하면 어떠한 하나의 action도 최적이 될 수 없습니다. 이 문제의 경우 문항 (8)의 시점에서는 둘 다 가위를 내도록 업데이트 되었는데 이를 이용하여 플레이어E가 다시 바위를 낼 수 있고 그 심리를 역이용하여 플레이어F가 다시 보를 낼 수 있고 그 심리를 다시 역이용하여 플레이어E가 다시 가위를 내며 그 심리를 역이용하여 플레이어F는 다시 가위를 낼 수 있어 무한반복이 됩니다. (상대도 바보가 아니거든요.)\n하지만 두 가지 액션을 확률로 선택한다면 문항 (10)의 상황과 같이 상대방이 어떠한 선택을 하더라도 유리한 선택이 존재하지 않는 어떠한 균형점이 존재할 수 있는데 이를 내쉬의 균형이라 합니다. 내쉬의 균형에 따르면 플레이어E는 가위와 바위를 2:1의 비율로 플레이어F는 가위와 보를 2:1로 낼때 서로가 서로의 전략을 바꾸지 않는 균형상태에 도달합니다. 이러한 게임의 셋팅에 대하여 좀 더 관심 있으신 분은 게임이론을 참고하셔서 공부해보시기 바랍니다. (저도 기본적인 내용밖에 모르지만 흥미있는 분야입니다)\n만약 주어진 게임환경에서 플레이어E,F가 (에이전트라고 부릅니다) 전략을 학습하는 과정이 흥미롭게 느껴졌다면 강화학습을 한번 참고해보시기 바랍니다. 강화학습은 알파고를 학습시킨것으로 유명한 알고리즘입니다. 아래영상은 컴퓨터플레이어가 벽돌깨기 게임을 하며 데이터를 쌓고 데이터로 부터 적절한 action을 학습하는 과정을 묘사한 영상입니다.\n\nhttps://www.youtube.com/watch?v=TmPfTpjtdgg\n\n여러분들이 기말고사에서 간단히 만들어본 알고리즘의 발전형입니다. 강화학습에 흥미가 있으시면 방학동안에 공부해보시길 바랍니다. (궁금한 점은 제 메일로 질문하셔도 됩니다, 제가 게임이론은 전공이 아니지만 강화학습은 약간 할줄 알거든요 ㅎㅎ)\n\nAppendix\n- 아래의 클래스를 참고하여 문제1,2을 풀어라. (5월25일 강의노트에 소개된 클래스를 약간 정리한 것)\n\n참고하지 않아도 감점은 없음\n\n\nclass RPS:\n    def __init__(self,candidate):\n        self.candidate = candidate\n        self.actions = list() \n        self.rewards = list()\n        self.prob = [0.5,0.5]\n\n    def __eq__(self,other): # 연산 == 를 재정의 \n        return self.actions[-1] == other.actions[-1] \n        #note: 둘의 액션이 같으면 무승부 \n    \n    def __gt__(self,other): # 연산 &gt; 를 재정의 \n        pair = self.actions[-1], other.actions[-1]\n        return pair == ('가위','보') or pair == ('바위','가위') or pair == ('보','바위') \n        #note: 가위&gt;보, 바위&gt;가위, 보&gt;가위 \n    \n    def __mul__(self,other):\n        # step1: 각자의 패를 선택 \n        self.choose()\n        other.choose()\n        \n        # step2: 승패 판단 + upate reward\n        if self == other: # 무승부일경우 \n            self.rewards.append(1)\n            other.rewards.append(1)\n        elif self &gt; other: # self의 승리 \n            self.rewards.append(2)\n            other.rewards.append(0)\n        else: # other의 승리 \n            self.rewards.append(0)\n            other.rewards.append(2)\n        \n        # step3: update data\n        self.update_data()\n        other.update_data()\n    \n    def update_data(self):\n        self.data = pd.DataFrame({'actions':self.actions, 'rewards':self.rewards})\n    \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} &lt;br/&gt; \n        데이터: &lt;br/&gt;\n        {}\n        \"\"\"        \n        return html_str.format(self.candidate,self.data._repr_html_())\n    \n    def choose(self):\n        self.actions.append(np.random.choice(self.candidate,p=self.prob))\n\n- 사용예시\n\na=RPS(['가위','가위'])\nb=RPS(['가위','보'])\n\n\nfor i in range(5):\n    a*b\n\n\na\n\n\n        낼 수 있는 패: ['가위', '가위']  \n        데이터: \n        \n\n\n\n\n\n\nactions\nrewards\n\n\n\n\n0\n가위\n2\n\n\n1\n가위\n2\n\n\n2\n가위\n1\n\n\n3\n가위\n2\n\n\n4\n가위\n2\n\n\n\n\n\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '보']  \n        데이터: \n        \n\n\n\n\n\n\nactions\nrewards\n\n\n\n\n0\n보\n0\n\n\n1\n보\n0\n\n\n2\n가위\n1\n\n\n3\n보\n0\n\n\n4\n보\n0"
  },
  {
    "objectID": "PP2023/posts/Appendix/2021-06-09-final.html",
    "href": "PP2023/posts/Appendix/2021-06-09-final.html",
    "title": "참고자료: 2021-06-final",
    "section": "",
    "text": "오픈 북, 2시간, 문제미리공개\n\n\n2021년 파이썬입문 기말고사 (풀이포함)\n\n# 1. (20점)\nN사에서 게임유저들에게 여름방학 기념이벤트로 진명왕의 집판검이라는 이름의 아이템을 선물했다고 하자. 진명왕의 집판검은 총 5회에 걸쳐서 강화(upgrade)될 수 있데 강화의 성공확률은 10%라고 하자. 강화가 5번성공하면 더 이상 강화가 진행되지 않는다고 하자. (따라서 더 이상 강화시도를 하지 않아도 무방하다) 아래는 이 아이템에 강화를 진행하였을때 각 강화상태를 설명한 예시이다.\n\n\n\n시도횟수\n강화성공여부\n강화상태\n비고\n\n\n\n\n1\n강화실패\n+0 \\(\\to\\) +0\n강화실패로 인하여 강화상태 변화없음\n\n\n2\n강화성공\n+0 \\(\\to\\) +1\n강화성공으로 인한 강화상태 변화\n\n\n3\n강화실패\n+1 \\(\\to\\) +1\n강화실패로 인하여 강화상태 변화없음\n\n\n4\n강화성공\n+1 \\(\\to\\) +2\n강화성공으로 인한 강화상태 변화\n\n\n5\n강화성공\n+2 \\(\\to\\) +3\n강화성공으로 인한 강화상태 변화\n\n\n6\n강화성공\n+3 \\(\\to\\) +4\n강화성공으로 인한 강화상태 변화\n\n\n7\n강화실패\n+4 \\(\\to\\) +4\n강화실패로 인하여 강화상태 변화없음\n\n\n8\n강화성공\n+4 \\(\\to\\) +5\n모든 강화 성공\n\n\n9\n-\n+5 \\(\\to\\) +5\n더 이상 강화시도 하지 않음\n\n\n10\n\\(\\dots\\)\n\\(\\dots\\)\n\\(\\dots\\)\n\n\n\n강화는 하루에 한 번씩만 시도할 수 있으며 시도가능한 기간은 7월1일부터 8월31일까지로 한정되어 있다고 하자. 따라서 방학동안 유저들은 총 62번 시도를 할 수 있다. 방학이 끝난이후 100명 유저중 대략 몇명정도 +5 강화상태에 있겠는가? 파이썬을 통한 시뮬레이션을 활용하여 추론하라. (단, +5강화에 성공하지 못한 모든 유저는 반드시 하루에 한번 강화를 시도해야 한다고 가정하자.)\n(풀이1)\n\nimport numpy as np\nnp.random.seed(1)\nsum(np.random.binomial(n=62, p=0.1, size=10000)&gt;=5)/10000\n\n0.7514\n\n\n(풀이2)\n\nclass ExecutionSword():\n    def __init__(self,prob):\n        self.nuser=100000\n        self.prob=prob\n        self.attemptresult=None\n        self.upgradestate=pd.DataFrame({'day0':[0]*self.nuser})\n        self.failstate=pd.DataFrame({'day0':[0]*self.nuser})\n        self.ratio=0\n        self.day=0\n    def addday(self):\n        self.day=self.day+1            \n    def attempt(self):\n        self.attemptresult = np.random.binomial(n=1, p=self.prob, size=self.nuser)\n    def update(self):\n        # 강화상태 업데이트\n        self.upgradestate['day%s' % self.day] = np.minimum(5,self.upgradestate['day%s' % (self.day-1)]+self.attemptresult)\n        # 강화실패누적횟수 업데이트 \n        self.failstate['day%s' % self.day]=self.failstate['day%s' % (self.day-1)]+(self.attemptresult==0)*1\n        # 강화상태==5 or 강화상태==0 일 경우 강화실패누적횟수 초기화 \n        self.failstate['day%s' % self.day][self.upgradestate['day%s' % self.day]== 0]=0\n        self.failstate['day%s' % self.day][self.upgradestate['day%s' % self.day]== 5]=0\n    def reset(self):\n        # 실패횟수 = 2 인것을 찾아 index_ 에 저장 -&gt; index_ 에 해당하는 유저의 강화횟수와 실패횟수를 모두 0으로 초기화 \n        index_= self.failstate['day%s' % self.day]==2\n        self.failstate['day%s' % self.day][index_] = 0\n        self.upgradestate['day%s' % self.day][index_] = 0\n    def arrangeprob(self):\n        self.ratio=sum(self.upgradestate['day%s' % self.day]==5) / self.nuser\n        if self.ratio &gt; 0.5:\n            self.prob = 0.9\n\n\n# 1 \nimport pandas as pd\ns1=ExecutionSword(0.1)\nfor i in range(62):\n    s1.addday()\n    s1.attempt()\n    s1.update()\n\n\nsum(s1.upgradestate.day62==5)/s1.nuser\n\n0.75551\n\n\n\n\n# 2. (70점)\n강화성공확률을 40%로 수정한다. 강화에 누적2회 실패하면 강화상태가 초기화 된다고 하자. (따라서 강화실패 누적횟수를 카운트하는 변수가 필요하다) 단, 강화실패 누적횟수는 누적2회 달성시 0으로 초기화 된다. 또한 강화상태가 +0인 경우는 실패하여도 강화실패 누적횟수가 추가되지 않는다.\n\n\n\n시도횟수\n강화성공여부\n강화상태\n강화실패누적\n비고\n\n\n\n\n1\n강화성공\n+0 \\(\\to\\) +1\n0 \\(\\to\\) 0\n-\n\n\n2\n강화성공\n+1 \\(\\to\\) +2\n0 \\(\\to\\) 0\n-\n\n\n3\n강화실패\n+2 \\(\\to\\) +2\n0 \\(\\to\\) 1\n-\n\n\n4\n강화성공\n+2 \\(\\to\\) +3\n1 \\(\\to\\) 1\n-\n\n\n5\n강화실패\n+3 \\(\\to\\) +0\n1 \\(\\to\\) 0\n강화실패로 누적2회로 인한 초기화\n\n\n6\n강화실패\n+0 \\(\\to\\) +0\n0 \\(\\to\\) 0\n강화실패 누적횟수 증가하지 않음\n\n\n7\n강화성공\n+0 \\(\\to\\) +1\n0 \\(\\to\\) 0\n-\n\n\n8\n강화성공\n+1 \\(\\to\\) +2\n0 \\(\\to\\) 0\n-\n\n\n9\n강화성공\n+2 \\(\\to\\) +3\n0 \\(\\to\\) 0\n-\n\n\n10\n강화성공\n+3 \\(\\to\\) +4\n0 \\(\\to\\) 0\n-\n\n\n11\n강화성공\n+4 \\(\\to\\) +5\n0 \\(\\to\\) 0\n모든 강화 성공\n\n\n12\n-\n+5 \\(\\to\\) +5\n0 \\(\\to\\) 0\n더 이상 강화시도 하지 않음\n\n\n13\n\\(\\dots\\)\n\\(\\dots\\)\n\\(\\dots\\)\n\\(\\dots\\)\n\n\n\n(1) 이 경우 62일의 방학뒤에 100명의 유저중 대략 몇명정도 +5 강화상태에 있겠는가? 시뮬레이션을 활용하여 추론하라. (단, +5강화에 성공하지 못한 모든 유저는 반드시 하루에 한번 강화를 시도해야 한다고 가정하자.)\n(2) 31번째 시도 이후 대략 몇명의 유저가 +5 강화상태에 있겠는가?\n\n# 2-1,2 \ns2=ExecutionSword(0.4)\n\n\nfor i in range(62):\n    s2.addday()\n    s2.attempt()\n    s2.update()\n    s2.reset() ## 초기화가 되는 조건이 있으므로 문제1에서 reset함수만 추가하면 된다. \n\n\n# 2-1\nsum(s2.upgradestate.day31==5)/s2.nuser\n\n0.36392\n\n\n\n# 2-2\nsum(s2.upgradestate.day62==5)/s2.nuser\n\n0.61803\n\n\n(3) 100명의 유저중 50명이상의 유저가 +5 강화상태에 도달하는 순간 모든 유저의 강화성공확률을 90%로 증가시킨다고 하자. 62일의 방학뒤에 100명의 유저 중 몇명 정도가 +5 강화상태에 있겠는가?\n\n# 2-3 \ns3=ExecutionSword(0.4)\n\n\nfor i in range(62):\n    s3.addday()\n    s3.attempt()\n    s3.update()\n    s3.reset() ## 초기화가 되는 조건이 있으므로 reset함수 추가\n    s3.arrangeprob() ## 전체유저의 50%가 강화성공하면 강화확률이 조정되는 조건이 있으므로 arragneprob 추가 \n\n\nsum(s3.upgradestate.day62==5)/s3.nuser\n\n0.9993"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1-비상식적인-append",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1-비상식적인-append",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1: 비상식적인 append",
    "text": "예제1: 비상식적인 append\n\n포인트: 이상한 일의 관찰\n\n- 원소의 추가: + 이용\n\na=[1,2,3]\nb=a\na=a+[4]\n\n\na\n\n[1, 2, 3, 4]\n\n\n\nb\n\n[1, 2, 3]\n\n\n- 원소의 추가 .append 이용\n\na=[1,2,3]\nb=a\na.append(4) # a=a+[4]\n\n\na\n\n[1, 2, 3, 4]\n\n\n\nb\n\n[1, 2, 3, 4]"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#append의-동작원리-틀린상상",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#append의-동작원리-틀린상상",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "append의 동작원리: 틀린상상",
    "text": "append의 동작원리: 틀린상상\n- 상자로서의 변수: 변수가 데이터를 저장하는 일종의 상자와 같다. &lt;– 아주 흔한 오해 (Fluent Python)\n\n흔히 비유하는 ‘상자로서의 변수’ 개념이 실제로는 객체지향적 언어에서 참조변수를 이해하는 데 방해가 된다.\n\n- “상자로서의 변수” 관점에서 아래의 코드를 해석하자. (일단 아래의 해석들이 틀린해석이라는 사실을 명심할 것)\na=[1,2,3]\nb=a\na.append(4)\na,b라는 변수들은 메모리에 어떻게 저장이 되어있을까?\n상상력을 조금 발휘하면 아래와 같이 여길 수 있다.\n\n메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자.\n아래를 실행하였을 경우\n\na=[1,2,3]\n\n메모리주소1에 존재하는 방을 a라고 하고, 그 방에 [1,2,3]을 넣는다.\n\n\n아래를 실행하였을 경우\n\nb=a\n\n메모리주소2에 존재하는 방을 b라고 하고, 그 방에 a를 넣어야하는데, a는 [1,2,3]이니까 [1,2,3]을 넣는다.\n\n\n아래를 실행하면\n\na.append(4)\n\n방 a로가서 [1,2,3]을 [1,2,3,4]로 바꾼다.\n그리고 방 b에는 아무것도 하지 않는다.\n\n- R에서는 맞는 비유인데, 파이썬은 적절하지 않은 비유이다.\n\n틀린이유\n\nid(a)\n\n140237129319488\n\n\n\nid(b)\n\n140237129319488"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#append의-동작원리-올바른-상상",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#append의-동작원리-올바른-상상",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "append의 동작원리: 올바른 상상",
    "text": "append의 동작원리: 올바른 상상\n\n파이썬에서의 변수는 자바에서의 참조변수와 같으므로 변수는 객체에 붙은 레이블이라고 생각하는 것이 좋다.\n\n- 파이썬에서는 아래가 더 적절한 비유이다.\n\n메모리는 변수를 담을 방이 여러개 있는 호텔이라고 생각하자.\n아래를 실행하였을 경우\n\na=[1,2,3]\n\n메모리주소 139753545242336에서 [1,2,3]을 생성\n방 139753545242336의 방문에 a라는 포스트잇을 붙인다.\n앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙은 방을 찾아가면 된다.\n\n\n아래를 실행하였을 경우\n\nb=a\n\na라는 포스트잇이 지칭하는 객체를 가져옴. 그리고 그 객체에 b라는 포스트잇을 붙인다.\n쉽게말하면 b라는 포스트잇을 방 139753545242336의 방문에 붙인다는 이야기.\n앞으로 [1,2,3]에 접근하기 위해서는 여러 메모리방중에서 a라는 포스트잇이 붙어 있거나 b라는 포스트잇이 붙어있는 방을 찾아가면 된다.\n\n\n아래를 실행하면\n\na.append(4)\n\na라는 포스트잇이 붙어있는 방으로 가서, 그 내용물에 append함수를 적용하여 4를 추가하라. 즉 내용물 [1,2,3]을 [1,2,3,4]로 바꾸라.\n같은방(139753545242336)에 a,b라는 포스트잇이 모두 붙어있음. 따라서 b라는 포스트잇이 붙은 방을 찾아가서 내용물을 열어보면 [1,2,3,4]가 나온다."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1-같은-value-다른-id",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1-같은-value-다른-id",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1: 같은 value, 다른 id",
    "text": "예제1: 같은 value, 다른 id\n\n포인트: (1) 포스트잇 개념의 확실한 이해 (2) 할당문을 새로운 시각으로 해석하는 연습 (3) “생성-&gt;할당”과 “참조/에일리어싱”의 구분\n\n\na=[1,2,3] # 우변: 생성된 오브젝트, 좌변: 이름 \nb=a # 우변: 가져온 오브젝트, 좌변: 별명 --&gt; 참조, 에일리어싱(별칭부여)이라고 한다\na.append(4) # a라는 오브젝트를 직접변경\nc=[1,2,3,4] # 우변: 생성된 오브젝트, 좌변: 이름\n\n여기에서 a,b,c는 모두 같은 value를 가진다.\n\na\n\n[1, 2, 3, 4]\n\n\n\nb\n\n[1, 2, 3, 4]\n\n\n\nc\n\n[1, 2, 3, 4]\n\n\n하지만 그 id까지 같은 것은 아니다.\n\nid(a), id(b), id(c)\n\n(140237129249664, 140237129249664, 140237128836544)"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제2",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제2",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제2",
    "text": "예제2\n\n선행지식: “생성-&gt;할당” 과 “참조/에일리어싱”의 구분\n\n\n포인트: 재할당의 이해!!\n\n(관찰)\n\na=[1,2,3] # 생성-&gt;할당\nb=a # 참조/에일리어싱 \na=a+[4] # 생성-&gt;재할당 \nprint('a=',a)\nprint('b=',b)\n\na= [1, 2, 3, 4]\nb= [1, 2, 3]\n\n\n(해설)\n\nid(a),id(b)\n\n(140237129283584, 140237129350912)\n\n\n\n포인트: [1,2,3]+[4] 가 실행되는 순간 새로운 오브젝트가 만들어지고 그 오브젝트를 a라는 이름으로 다시 할당되었음. (재할당)"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1",
    "text": "예제1\n\n선행지식: “생성-&gt;할당,재할당” 과 “참조/에일리어싱”의 구분\n\n\n포인트: 인터닝을 위한 떡밥예제\n\n\na=1+2021\nid(a)\n\n139753546122608\n\n\n\nb=2023-1\nid(b)\n\n139753545299280\n\n\n\nid(2022)\n\n139753545299472\n\n\n\n당연한결과임."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제2-이제-다-이해했다고-생각했는데..",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제2-이제-다-이해했다고-생각했는데..",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제2: 이제 다 이해했다고 생각했는데..",
    "text": "예제2: 이제 다 이해했다고 생각했는데..\n\n선행지식: “생성-&gt;할당,재할당” 과 “참조/에일리어싱”의 구분\n\n\n포인트: 인터닝의 이해\n\n\na=1+2 \nid(a)\n\n7394720\n\n\n\nb=4-1\nid(b)\n\n7394720\n\n\n\nid(a)와 id(b)가 왜 똑같지..?\n\n(해설) 파이썬의 경우 효율성을 위해서 -5~256까지의 정수를 미리 저장해둠.\n\nid(3)\n\n7394720\n\n\n\n3은 언제나 7394720에 지박령마냥 밖혀있음"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1-1",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1-1",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1",
    "text": "예제1\n(관찰) 아래의 예제를 살펴보자. 참조를 제대로 이해했다면 아래의 예제는 자연스럽게 이해가능할 것임.\n\nl1 = [3, [66,55,44]]\nl2 = l1 \nprint('시점1')\nprint('l1=',l1)\nprint('l2=',l2)\n\nl1[0]=4 \nprint('시점2')\nprint('l1=',l1)\nprint('l2=',l2)\n\nl2.append(5)\nprint('시점3')\nprint('l1=',l1)\nprint('l2=',l2)\n\n시점1\nl1= [3, [66, 55, 44]]\nl2= [3, [66, 55, 44]]\n시점2\nl1= [4, [66, 55, 44]]\nl2= [4, [66, 55, 44]]\n시점3\nl1= [4, [66, 55, 44], 5]\nl2= [4, [66, 55, 44], 5]\n\n\n(해설)\n\nl1 = [3, [66,55,44]]\nl2 = l1 \n\n\nid(l1),id(l2)\n\n(140571068242688, 140571068242688)\n\n\n이해는 되지만 우리가 원한건 이런게 아니야"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제2-r과-같이-를-쓰고-싶다면",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제2-r과-같이-를-쓰고-싶다면",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제2: R과 같이 = 를 쓰고 싶다면?",
    "text": "예제2: R과 같이 = 를 쓰고 싶다면?\n\n선행지식: “생성-&gt;할당,재할당” 과 “참조/에일리어싱”의 구분\n\n\n포인트: 복사의 사용, 얕은복사의 떡밥\n\n(관찰)\n\nl1 = [3, [66,55,44]]\nl2 = l1.copy()\nprint('시점1')\nprint('l1=',l1)\nprint('l2=',l2)\n\nl1[0]=4 \nprint('시점2')\nprint('l1=',l1)\nprint('l2=',l2)\n\nl2.append(5)\nprint('시점3')\nprint('l1=',l1)\nprint('l2=',l2)\n\n시점1\nl1= [3, [66, 55, 44]]\nl2= [3, [66, 55, 44]]\n시점2\nl1= [4, [66, 55, 44]]\nl2= [3, [66, 55, 44]]\n시점3\nl1= [4, [66, 55, 44]]\nl2= [3, [66, 55, 44], 5]\n\n\n(해설)\n\nl1 = [3, [66,55,44]]\nl2 = l1.copy()\n\n\nid(l1),id(l2) ## 드디어 주소가 달라졌다.\n\n(140571068242688, 140571068242240)"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제3-이제-다-이해했다고-생각했는데..",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제3-이제-다-이해했다고-생각했는데..",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제3: 이제 다 이해했다고 생각했는데..",
    "text": "예제3: 이제 다 이해했다고 생각했는데..\n\n선행지식: “생성-&gt;할당,재할당” 과 “참조/에일리어싱”의 구분, 복사의 사용\n\n\n포인트: 얕은복사를 이해하지 못할때 생기는 개념충돌\n\n(관찰)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\nl1[1].append(33)\nprint('l1=',l1)\nprint('l2=',l2)\n\nl1= [3, [66, 55, 44, 33]]\nl2= [3, [66, 55, 44, 33]]\n\n\n(의문)\n\nid(l1),id(l2)\n\n(140571077644352, 140571068253376)\n\n\n\nl1이랑 l2의 주소도 다르게 나오는데 왜 또 참조한것마냥 l1과 l2가 같이 바뀌고 있지?\n\n나는 진정한 복사(=깊은복사)를 하고싶다"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1-2",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1-2",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1",
    "text": "예제1\n\n선행지식: 이전까지 모든것\n\n\n포인트: 0차원 자료형의 메모리 구조 이해, 1차원 자료형의 메모리 구조를 위한 떡밥\n\n(관찰+해설)\n\na=2222\nb=2222\n\n\nid(a),id(b)\n\n(139753545300880, 139753545301808)\n\n\n메모리 상황\n\n2222라는 오브젝트가 어떤공간(139753545300880)에 생성되고 그 공간에 a라는 라벨이 붙음\n2222라는 오브젝트가 어떤공간(139753545301808)에 생성되고 그 공간에 b라는 라벨이 붙음\n\n즉 -5~256 이외의 2개의 메모리 공간을 추가적으로 사용"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제2-1",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제2-1",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제2",
    "text": "예제2\n\n선행지식: 이전까지 모든것, 0차원 자료형의 메모리저장상태 이해\n\n\n포인트: (1) 1차원 자료형의 메모리 구조 이해 (2) 가변형객체라는 표현의 의미\n\n(관찰)\n\na=[1,2,2222]\nb=[1,2,2222]\na.append(4)\nprint('a=',a)\nprint('b=',b)\n\na= [1, 2, 2222, 4]\nb= [1, 2, 2222]\n\n\n(해설)\n\na=[1,2,2222]\nb=[1,2,2222]\n\n\nid(a), [id(a[0]),id(a[1]),id(a[2])] # a=[1,2,2222]\n\n(140527746917824, [7585472, 7585504, 140528016796752])\n\n\n\nid(b), [id(b[0]),id(b[1]),id(b[2])] # b=[1,2,2222] \n\n(140527746917568, [7585472, 7585504, 140528016796144])\n\n\n\na.append(4)\n\n\na\n\n[1, 2, 2222, 4]\n\n\n\nb\n\n[1, 2, 2222]\n\n\n\nid(a)\n\n140527746917824\n\n\n메모리상황\n\n-5~256까지의 숫자는 미리 메모리에 저장되어 있다. 이중에서 1은 7394656, 2는 7394688에 저장되어있음.\n2222가 공간 139753178093776에서 만들어진다.\n어떠한 리스트오브젝트가 공간 139753182327904에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 a라는 포스트잇을 붙인다.\n2222가 공간 139753178095568에서 만들어진다.\n어떠한 리스트오브젝트가 공간 139753173818656에서 만들어지고 원소로 [1,2,2222]를 가진다. 이 공간에 b라는 포스트잇을 붙인다.\na라는 포스트잇이 붙은 공간으로 이동하여 원소에 4를 추가시킨다.\n\n즉 -5~256이외에 4개의 메모리 공간을 추가사용 (a,b,a의 2222,b의 2222)"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제3",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제3",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제3",
    "text": "예제3\n\n선행지식: 이전까지 모든 것\n\n\n포인트: l2=l1 와 l2=l1.copy() 의 차이점\n\n(관찰)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\nl1[0] = 7777\nprint('l1=',l1)\nprint('l2=',l2)\n\nl1= [7777, [66, 55, 44]]\nl2= [3, [66, 55, 44]]\n\n\n(해설)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139753183437040, [7394720, 139753183707216])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139753182311120, [7394720, 139753183707216])\n\n\n메모리상황\n\n-5~256까지의 숫자가 메모리에 저장되어 있다.\n저장된 숫자중 66,55,44를 묶어서 리스트로 구성하고 이 리스트를 공간 139753183707216에 저장.\n숫자 3과 공간 139753183707216에 저장된 리스트 [66,55,44]를 하나로 묶어서 새로운 리스트를 구성하고 이를 공간 139753183437040에 저장. 공간 139753183437040에 l1이라는 포스트잇 생성.\n공간 139753182311120에 l1의 원소들을 모아서 새로운 리스트를 구성함. 공간 139753182311120에 l2라는 포스트잇 생성. 그런데 따져보니까 내부구성은 똑같아?\n\n\nl1[0] = 7777\nl1,l2\n\n([7777, [66, 55, 44]], [3, [66, 55, 44]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139753183437040, [139753178092080, 139753183707216])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139753182311120, [7394720, 139753183707216])\n\n\n\nl1[0]은 원래 공간 7394720와 binding 되어 있었음.\n\n그런데 7777이라는 새로운 오브젝트가 공간 139753178092080에 생성되고 l1[0]이 공간 139753178092080와 다시 binding 됨."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제4",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제4",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제4",
    "text": "예제4\n\n선행지식: 이전까지 모든것, .copy()의 동작원리\n\n\n포인트: .copy()의 동작원리 재학습\n\n(관찰)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\nl1.append(7777)\nprint('l1=',l1)\nprint('l2=',l2)\n\nl1= [3, [66, 55, 44], 7777]\nl2= [3, [66, 55, 44]]\n\n\n(해설)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\nl1.append(7777)\n\n\nl1,l2\n\n([3, [66, 55, 44], 7777], [3, [66, 55, 44]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1]), id(l1[2])]\n\n(139753183257056, [7394720, 139753184484240, 139753180268560])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139753183216656, [7394720, 139753184484240])"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제5-우리를-힘들게-했던-그-예제.",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제5-우리를-힘들게-했던-그-예제.",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제5: 우리를 힘들게 했던 그 예제.",
    "text": "예제5: 우리를 힘들게 했던 그 예제.\n\n선행지식: 이전까지 모든것, .copy()의 동작원리\n\n\n포인트: (1) .copy()의 한계, (2) 얕은복사라는 명칭의 유래\n\n(관찰)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\nl1[1].append(7777)\nprint('l1=',l1)\nprint('l2=',l2)\n\nl1= [3, [66, 55, 44, 7777]]\nl2= [3, [66, 55, 44, 7777]]\n\n\n(해설-시점1)\n\nl1 = [3,[66,55,44]]\nl2 = l1.copy()\n\n\nl1,l2\n\n([3, [66, 55, 44]], [3, [66, 55, 44]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139753181411920, [7394720, 139753181409920])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139753181409440, [7394720, 139753181409920])\n\n\n(해설-시점2)\n\nl1[1].append(7777)\n\n\nl1,l2\n\n([3, [66, 55, 44, 7777]], [3, [66, 55, 44, 7777]])\n\n\n\nid(l1), [id(l1[0]), id(l1[1])]\n\n(139753181411920, [7394720, 139753181409920])\n\n\n\nid(l2), [id(l2[0]), id(l2[1])]\n\n(139753181409440, [7394720, 139753181409920])\n\n\n해설: 사실 시점1에서 메모리 주소상황을 잘 이해했다면 신기한 일이 아니다. .copy()는 l1과 l2의 주소만 다르게 만들 뿐 내용물인 l1[0],l1[1]는 동일하니까."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제6-신임교수최규빈이영미",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제6-신임교수최규빈이영미",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제6: 신임교수=[‘최규빈’,‘이영미’]",
    "text": "예제6: 신임교수=[‘최규빈’,‘이영미’]\n\n선행지식: 이전까지의 모든것\n\n\n포인트: 이전까지의 모든것 점검\n\n- 최규빈, 이영미는 신임교수임\n\n신임교수 = ['최규빈','이영미']\n\n\nid(신임교수), id('최규빈'), id('이영미')\n\n(139753182527808, 139753171447312, 139753171447408)\n\n\n- 신임교수를 누군가는 막내들이라고 부르기도 함.\n\n막내들 = 신임교수 \n\n\nid(막내들), id(신임교수)\n\n(139753182527808, 139753182527808)\n\n\n“막내들”이라는 단어와 “신임교수”라는 단어는 사실 같은 말임\n- 새로운 교수 “박혜원”이 뽑혔음.\n\n신임교수.append(\"박혜원\")\n\n\n신임교수, 막내들\n\n(['최규빈', '이영미', '박혜원'], ['최규빈', '이영미', '박혜원'])\n\n\n- 전북대 통계학과에서 R특강팀을 구성하여 방학중 R교육을 실시하고자함. 특강팀은 우선 신임교수들로 구성.\n\nR특강팀 = 신임교수.copy()\nR특강팀 \n\n['최규빈', '이영미', '박혜원']\n\n\n- R특강팀에 최혜미교수님 추가. (그렇지만 최혜미교수님이 막내는 아니야.. // 참조와 shallow copy의 차이점)\n\nR특강팀.append(\"최혜미\") \n\n\nR특강팀, 신임교수, 막내들\n\n(['최규빈', '이영미', '박혜원', '최혜미'], ['최규빈', '이영미', '박혜원'], ['최규빈', '이영미', '박혜원'])\n\n\n- R특강팀에서 양성준 교수를 추가하여 파이썬 특강팀을 구성 (R특강팀의 구분을 위해서 중첩리스트 구조로 만들자)\n\n파이썬특강팀 = [R특강팀, \"양성준\"]\n파이썬특강팀\n\n[['최규빈', '이영미', '박혜원', '최혜미'], '양성준']\n\n\n- 이영미교수는 다른 일이 많아서 R특강 팀에서 제외됨. (그럼 자연히 파이썬에서도 제외됨!!)\n\nR특강팀.remove(\"이영미\")\n\n\nR특강팀, 파이썬특강팀\n\n(['최규빈', '박혜원', '최혜미'], [['최규빈', '박혜원', '최혜미'], '양성준'])\n\n\n하지만 이영미교수는 여전히 신임교수이면서 막내들임\n\n신임교수, 막내들\n\n(['최규빈', '이영미', '박혜원'], ['최규빈', '이영미', '박혜원'])\n\n\n- 새로운 교수로 “손흥민”이 임용됨.\n\n막내들.append(\"손흥민\")\n\n\n막내들, 신임교수\n\n(['최규빈', '이영미', '박혜원', '손흥민'], ['최규빈', '이영미', '박혜원', '손흥민'])\n\n\n- 그렇다고 해서 손흥민 교수가 바로 R이나 파이썬 특강팀에 자동소속되는건 아님\n\nR특강팀, 파이썬특강팀\n\n(['최규빈', '박혜원', '최혜미'], [['최규빈', '박혜원', '최혜미'], '양성준'])"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1-motivation-example",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1-motivation-example",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1: Motivation example",
    "text": "예제1: Motivation example\n- 아래의 상황을 다시 생각해보자.\n\n파이썬특강팀 = [\"양성준\",[\"최규빈\",\"이영미\",\"최혜미\"]]\nADSP특강팀 = 파이썬특강팀.copy()\n파이썬특강팀[-1].remove(\"이영미\")\n\n\n파이썬특강팀, ADSP특강팀\n\n(['양성준', ['최규빈', '최혜미']], ['양성준', ['최규빈', '최혜미']])\n\n\n이슈: 이영미교수가 파이썬특강에서 제외되면서 ADSP특강팀에서도 제외되었음. 그런데 사실 이영미교수가 파이썬특강팀에서만 제외되길 원한 것이지 ADSP특강팀에서 제외되길 원한게 아닐수도 있음.\n해결: Deep copy의 사용\n\nimport copy\n\n\n파이썬특강팀 = [\"양성준\",[\"최규빈\",\"이영미\",\"최혜미\"]]\nADSP특강팀 = copy.deepcopy(파이썬특강팀)\n파이썬특강팀[-1].remove(\"이영미\")\n\n\n파이썬특강팀, ADSP특강팀\n\n(['양성준', ['최규빈', '최혜미']], ['양성준', ['최규빈', '이영미', '최혜미']])"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제2-2",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제2-2",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제2",
    "text": "예제2\n\n선행지식: 이전까지 모든것, 얕은복사\n\n\n포인트: (1) 깊은복사 (2) 복사의 레벨을 이해 (3) 얕은복사 = 1단계 깊은복사\n\n- deepcopy\n\nl1 = [3,[66,[55,44]]] \nl2 = copy.deepcopy(l1)\n\n\nl2[1][1].append(33)\n\n\nl1,l2\n\n([3, [66, [55, 44]]], [3, [66, [55, 44, 33]]])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 140137133270656\nl2: 140137132727232\n\n\n\n레벨1: l1,l2 의 메모리 주소가 다름을 확인\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 140137133270656 [7585536, 140137133267712]\nl2: 140137132727232 [7585536, 140137133267456]\n\n\n\n레벨2: l1안에 있는 [66,[55,44]]와 l2안에 있는 [66,[55,44]]의 메모리 주소가 다름도 확인.\n\n\nprint('level 3')\nprint('l1:', id(l1), [id(l1[0]),[id(l1[1][0]),id(l1[1][1])]])\nprint('l2:', id(l2), [id(l2[0]),[id(l2[1][0]),id(l2[1][1])]])\n\nlevel 3\nl1: 140137133270656 [7585536, [7587552, 140137133704320]]\nl2: 140137132727232 [7585536, [7587552, 140137137410624]]\n\n\n\n레벨3: l1안의 [66,[55,44]] 안의 [55,44]와 l2안의 [66,[55,44]] 안의 [55,44]의 메모리 주소까지도 다름을 확인.\n\n- 비교를 위한 shallow copy\n\nl1 = [3,[66,[55,44]]] \nl2 = l1.copy()\n\n\nl2[1][1].append(33)\n\n\nl1,l2\n\n([3, [66, [55, 44, 33]]], [3, [66, [55, 44, 33]]])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 140137133470528\nl2: 140137137411136\n\n\n\n레벨1: l1,l2 의 메모리 주소가 다름을 확인\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 140137133470528 [7585536, 140137133703424]\nl2: 140137137411136 [7585536, 140137133703424]\n\n\n\n레벨2: l1안에 있는 [66,[55,44]]와 l2안에 있는 [66,[55,44]]의 메모리 주소는 같음!!\n\n\nprint('level 3')\nprint('l1:', id(l1), [id(l1[0]),[id(l1[1][0]),id(l1[1][1])]])\nprint('l2:', id(l2), [id(l2[0]),[id(l2[1][0]),id(l2[1][1])]])\n\nlevel 3\nl1: 140137133470528 [7585536, [7587552, 140137137410880]]\nl2: 140137137411136 [7585536, [7587552, 140137137410880]]\n\n\n\n레벨3: l1안의 [66,[55,44]] 안의 [55,44]와 l2안의 [66,[55,44]] 안의 [55,44]의 메모리 주소도 같음!!\n\n- 비교를 위한 참조\n\nl1 = [3,[66,[55,44]]] \nl2 = l1\n\n\nl2[1][1].append(33)\n\n\nl1,l2\n\n([3, [66, [55, 44, 33]]], [3, [66, [55, 44, 33]]])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 140137133223232\nl2: 140137133223232\n\n\n\n레벨1: l1,l2 여기서부터 메모리 주소가 같다.\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 140137133223232 [7585536, 140137133698560]\nl2: 140137133223232 [7585536, 140137133698560]\n\n\n\nprint('level 3')\nprint('l1:', id(l1), [id(l1[0]),[id(l1[1][0]),id(l1[1][1])]])\nprint('l2:', id(l2), [id(l2[0]),[id(l2[1][0]),id(l2[1][1])]])\n\nlevel 3\nl1: 140137133223232 [7585536, [7587552, 140137133438144]]\nl2: 140137133223232 [7585536, [7587552, 140137133438144]]\n\n\n\nNote: 문헌에 따라서 shallow copy를 level1 deep copy라고 부르기도 한다."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1-3",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1-3",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1",
    "text": "예제1\n\n선행지식: 이전까지 모든것\n\n\n포인트: 얕은복사의 한계점 이해\n\n- 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라.\n\nl1= [3,[66,55,44]]\nl2= l1.copy() \nl1[-1].append(33)\n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, [66, 55, 44, 33]]\nl2= [3, [66, 55, 44, 33]]\n\n\n\n포인트: shallow copy (=level 1 deep copy) 이므로 l1안의 [66,55,44]와 l2안의 [66,55,44]는 같은 메모리 주소를 가짐"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제2-3",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제2-3",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제2",
    "text": "예제2\n\n선행지식: 이전까지 모든것\n\n\n포인트: 재할당의 활용하여 얕은복사의 한계점 극복\n\n- 아래의 코드결과를 예측하라. 결과가 나오는 이유를 설명하라.\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33] \n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, [66, 55, 44, 33]]\nl2= [3, [66, 55, 44]]\n\n\n\n포인트: l1[-1]+[33]가 실행되는 순간 새로운 오브젝트가 생성되고 이 새로운 오브젝트가 l1의 마지막 원소에 새롭게 할당된다."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제3-1",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제3-1",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제3",
    "text": "예제3\n\n선행지식: 이전까지 모든것\n\n\n포인트: 재할당의 활용하여 얕은복사의 한계점 극복, 예제4를 위한 떡밥\n\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33] \nl1[-1].remove(33)\n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, [66, 55, 44]]\nl2= [3, [66, 55, 44]]\n\n\n\n포인트: 이 상황에서 l1안의 [66,55,44]와 l2안의 [66,55,44]는 서로 다른 메모리 주소를 가진다."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제4-1",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제4-1",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제4",
    "text": "예제4\n\n선행지식: 이전까지 모든것\n\n\n포인트: 재할당으로 인해 메모리주소가 틀어짐을 이용한 트릭예제, 예제5의 떡밥예제\n\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33]\nl1[-1].remove(33) \nl1[-1].append(33)\n\n(잘못된 상상) 아래의 코드와 결과가 같을거야!!\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \n# l1[-1] = l1[-1]+[33] \n# l1[-1].remove(33)\nl1[-1].append(33)\n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, [66, 55, 44, 33]]\nl2= [3, [66, 55, 44, 33]]\n\n\n(하지만 현실은)\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] = l1[-1]+[33] \nl1[-1].remove(33)\nl1[-1].append(33)\n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, [66, 55, 44, 33]]\nl2= [3, [66, 55, 44]]"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제5",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제5",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제5",
    "text": "예제5\n\n선행지식: 이전까지 모든것\n\n\n포인트: +=는 재할당이 아니다.\n\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] += [33] # l1[-1] = l1[-1]+[33] \nl1[-1].remove(33)\nl1[-1].append(33)\n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, [66, 55, 44, 33]]\nl2= [3, [66, 55, 44, 33]]\n\n\n+= 연산자의 올바른 이해\n\n??? 예제4랑 예제5는 같은코드가 아니었음!!! a += [1] 는 새로운 오브젝트를 만드는게 아니고, 기존의 오브젝트를 변형하는 스타일의 코드였음! (마치 append 메소드처럼)"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#예제1-motivation-example-1",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#예제1-motivation-example-1",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "예제1: Motivation example",
    "text": "예제1: Motivation example\n\n선행지식: 이전까지 모든것\n\n\n포인트: +=는 재할당이 아니다.\n\n- 우리는 이제 아래의 내용은 마스터함\n\nl1= [3,[66,55,44]] \nl2= l1.copy() \nl1[-1] += [33] # l1[-1].append(33)이랑 같은거..\n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, [66, 55, 44, 33]]\nl2= [3, [66, 55, 44, 33]]\n\n\n- 아래의 결과를 한번 예측해볼까?\n\nl1=[3,(66,55,44)]\nl2=l1.copy()\nl2[1] += (33,)\n\n\nprint('l1=', l1)\nprint('l2=', l2)\n\nl1= [3, (66, 55, 44)]\nl2= [3, (66, 55, 44, 33)]"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#해설",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#해설",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "해설",
    "text": "해설\n(시점1)\n\nl1=[3,(66,55,44)]\nl2=l1.copy()\n\n\nl1,l2\n\n([3, (66, 55, 44)], [3, (66, 55, 44)])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 140006812656640\nl2: 140006812645888\n\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 140006812656640 [7585536, 140006812590400]\nl2: 140006812645888 [7585536, 140006812590400]\n\n\n(시점2)\n\nl2[1] += (33,)\n\n\nl1,l2\n\n([3, (66, 55, 44)], [3, (66, 55, 44, 33)])\n\n\n\nprint('level 1')\nprint('l1:', id(l1))\nprint('l2:', id(l2))\n\nlevel 1\nl1: 140006812656640\nl2: 140006812645888\n\n\n\nprint('level 2')\nprint('l1:', id(l1), [id(l1[0]),id(l1[1])])\nprint('l2:', id(l2), [id(l2[0]),id(l2[1])])\n\nlevel 2\nl1: 140006812656640 [7585536, 140006812590400]\nl2: 140006812645888 [7585536, 140006813422272]\n\n\n주소 140006812590400:(66,55,44)에 있는 값을 바꾸고 싶지만 불변형이라 못바꿈 \\(\\to\\) 그냥 새로 만들자. 그래서 그걸 140006813422272에 저장하자."
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#차원의-실체",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#차원의-실체",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "2차원의 실체",
    "text": "2차원의 실체\n- 2차원 array a,b를 선언하자.\n\na = np.array([[11,22,33,44]]).reshape(2,2)\nb = np.array([[11,22,33,44,55,66]]).reshape(2,3)\nc = np.array([11,22,33,44]).reshape(4,1)\nd = np.array([11,22,33,44]) # 1d\n\n- a,b,c,d 속성비교\n\na.shape, b.shape, c.shape, d.shape ## 차원 \n\n((2, 2), (2, 3), (4, 1), (4,))\n\n\n\na.strides, b.strides, c.strides, d.strides ## 차원이랑 관련이 있어보임.. + 8의 배수 \n\n((16, 8), (24, 8), (8, 8), (8,))\n\n\n- ((16, 8), (24, 8), (8, 8), (8,)) 와 같은 저 숫자들이 도데체 무엇을 의미하는거야?!\n\n사전지식: 컴퓨터는 하나의 숫자를 저장하는데 메모리를 8칸 쓴다.\n가정: 만약에 컴퓨터가 1차원으로만 숫자를 저장한다면??\nstrides의 의미: (다음 행으로 가기위해서 JUMP해야하는 메모리 공간수, 다음 열로 가기위해서 JUMP해야하는 메모리 공간수)\n\n- 통찰: strides의 존재로 인해서 유추할 수 있는 것은 a,b,c,d 는 모두 1차원으로 저장되어있다는 사실이다. (중첩된 리스트꼴이 아니라)\n- 그렇다면.. shallow copy = deep copy?!\n\nA1=[[1,2],[3,4]]\nA2=A1.copy()\nB1=np.array([[1,2],[3,4]])\nB2=B1.copy()\n\n\nB1\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nA2[0][0]=11\nB2[0][0]=11\n\n\nA1,A2\n\n([[11, 2], [3, 4]], [[11, 2], [3, 4]])\n\n\n\nB1,B2\n\n(array([[1, 2],\n        [3, 4]]),\n array([[11,  2],\n        [ 3,  4]]))\n\n\n- 해방: 넘파이를 쓰면 copy.deepcopy()를 쓰지 않아도 된다.\n- 용어정리: (필요할까..?)\n\nnumpy 한정 .copy() 는 copy모듈의 deep copy와 동등한 효과를 준다. 하지만 실제로는 shallow copy 이다. 공식문서에는 “Note that np.copy is a shallow copy and will not copy object elements within arrays.” 라고 명시되어 있음.\n일부 블로그에서 deep copy라고 주장하기도 함. 블로그1, 블로그2, 블로그3 // 블로그2의 경우 참조와 shallow copy도 구분못함..\n이따가 view라는 개념도 나올텐데 .copy()를 deep copy라고 주장하는 블로거들 대부분 .view()를 shallow copy 혹은 참조라고 주장한다. 하지만 copy와 view를 설명하는 공식문서에서는 view가 shallow copy라는 말을 찾아볼 수 없음.\n\n- 정리 (넘파이한정)\n\nnparray.copy(): 실제로는 shallow copy, 그런데 느낌은 deep copy\nnparray.view(): 실제로는 shallow copy 보다 더 얕은 단계의 카피, 그런데 느낌은 shallow copy"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#참조",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#참조",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "참조",
    "text": "참조\n- a를 선언, b는 a의 참조\n\na=np.array([[1,2],[3,4]])\nb=a ## 참조 \n\n\na\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n\na.shape\n\n(2, 2)\n\n\n\nb.shape\n\n(2, 2)\n\n\n- a의 shape을 바꾸어보자 \\(\\to\\) b도 같이 바뀐다\n\na.shape = (4,)\n\n\na\n\narray([1, 2, 3, 4])\n\n\n\nb\n\narray([1, 2, 3, 4])\n\n\n\nid(a),id(b)\n\n(139680327738544, 139680327738544)"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#view",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#view",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "view",
    "text": "view\n- a를 선언, b는 a의 view\n\na=np.array([[1,2],[3,4]]) \nb=a.view() ## 어떤 블로그등에서는 shallow copy라고 부르기도 한다. 그렇게 공부하지 마세여..\n\n\na\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n\na.shape\n\n(2, 2)\n\n\n\nb.shape\n\n(2, 2)\n\n\n\na.shape= (4,1)\n\n\na\n\narray([[1],\n       [2],\n       [3],\n       [4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nid(a), id(b)\n\n(139679960161232, 139679932937872)\n\n\n- 그런데..\n\na[0]=100\n\n\na\n\narray([[100],\n       [  2],\n       [  3],\n       [  4]])\n\n\n\nb\n\narray([[100,   2],\n       [  3,   4]])\n\n\n- 출생의 비밀\n\nb\n\narray([[100,   2],\n       [  3,   4]])\n\n\n\nb.base\n\narray([[100],\n       [  2],\n       [  3],\n       [  4]])\n\n\n\n? 이거 바뀐 a아니야?\n\n\nid(b.base), id(a)\n\n(139679960161232, 139679960161232)\n\n\n- View\n\nb가 a의 뷰라는 의미는, b가 a를 소스로하여 만들어진 오브젝트란 의미이다.\n따라서 이때 b.base는 a가 된다.\nb는 자체적으로 데이터를 가지고 있지 않으며 a와 공유한다.\n\nnote1 원본 ndarray의 일 경우는 .base가 None으로 나온다.\n\na.base\n\nnote2 b.base의 shpae과 b의 shape은 아무 관련없다.\n\nb.shape\n\n(2, 2)\n\n\n\nb.base.shape # a.shape과 같음\n\n(4, 1)\n\n\n- numpy에서 view를 사용하는 예시 (transpose)\n\nX = np.random.normal(size=[100,2])\nid((X.T).base), id(X)\n\n(139679932937584, 139679932937584)\n\n\n\nX.T 는 X의 view 이다.\n\n\nX.T @ X ## 실제로 X.T를 메모리공간에 새로 만들어 숫자를 저장하지않고 X.T @ X를 계산할 수 있음 (R과차이점) \n\narray([[124.15127928,  -0.45772606],\n       [ -0.45772606,  79.17005817]])"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#copy",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#copy",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "copy",
    "text": "copy\n- a를 선언, b는 a의 copy\n\na=np.array([[1,2],[3,4]])\nb=a.copy() # 껍데기를 새로 생성 (strides, shape) + 데이터도 a와 독립적으로 새로 생성하여 따로 메모리에 저장함. \n\n\nid(a),id(b)\n\n(139680327737776, 139679932938832)\n\n\n- a의 shape을 바꿔도 b에는 적용되지 않음\n\na.shape = (4,1)\na\n\narray([[1],\n       [2],\n       [3],\n       [4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n- 그리고 a[0]의 값을 바꿔도 b에는 적용되지 않음.\n\na[0]=100\n\n\na\n\narray([[100],\n       [  2],\n       [  3],\n       [  4]])\n\n\n\nb\n\narray([[1, 2],\n       [3, 4]])\n\n\n- b의 출생을 조사해보니..\n\na.base,b.base\n\n(None, None)\n\n\n출생의 비밀은 없었다. 둘다 원본.\n- .view() 는 껍데기만 새로생성 // .copy() 는 껍데기와 데이터를 모두 새로 생성\n\nAppendix: .copy의 한계(?)\n(관찰)\n\na=np.array([1,[1,2]],dtype='O')\nb=a.copy()\nprint('시점1')\nprint('a=',a)\nprint('b=',b)\n\na[0]=222\nprint('시점2')\nprint('a=',a)\nprint('b=',b)\n\na[1][0]=333\nprint('시점2')\nprint('a=',a)\nprint('b=',b)\n\n시점1\na= [1 list([1, 2])]\nb= [1 list([1, 2])]\n시점2\na= [222 list([1, 2])]\nb= [1 list([1, 2])]\n시점2\na= [222 list([333, 2])]\nb= [1 list([333, 2])]\n\n\n\n왜 또 시점2에서는 a와 b가 같이 움직여?\n\n해결책: 더 깊은 복사\n\nimport copy\n\n\na=np.array([1,[1,2]],dtype='O')\nb=copy.deepcopy(a)\nprint('시점1')\nprint('a=',a)\nprint('b=',b)\n\na[0]=222\nprint('시점2')\nprint('a=',a)\nprint('b=',b)\n\na[1][0]=333\nprint('시점2')\nprint('a=',a)\nprint('b=',b)\n\n시점1\na= [1 list([1, 2])]\nb= [1 list([1, 2])]\n시점2\na= [222 list([1, 2])]\nb= [1 list([1, 2])]\n시점2\na= [222 list([333, 2])]\nb= [1 list([1, 2])]\n\n\n- 중간요약\n\n사실 b=a.copy()는 에서 .copy()는 사실 온전한 deep-copy가 아니다.\n그래서 a의 데이터가 중첩구조를 가지는 경우는 온전한 deep-copy가 수행되지 않는다.\n그런데 일반적으로 넘파이를 이용할때 자주 사용하는 데이터 구조인 행렬, 텐서등은 데이터가 중첩구조를 가지지 않는다. (1차원 array로만 저장되어 있음)\n따라서 행렬, 텐서에 한정하면 .copy()는 온전한 deep-copy라고 이해해도 무방하다. &lt;– 이것만 기억해!"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#요약",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#요약",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "요약",
    "text": "요약\n아래를 구분할 수 있으면 잘 이해한 것!!\narr = np.array(...) # arr -- [arr.shape, arr.strides, arr.base, ... ] \narr2 = arr \narr2 = arr.view()\narr2 = arr.copy()\narr2 = copy.deepcopy(arr)"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#별명-뷰-카피",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#별명-뷰-카피",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "별명, 뷰, 카피",
    "text": "별명, 뷰, 카피\n- test 함수 작성\n\ndef test(a,b): \n    if id(a) == id(b): \n        print(\"별명\")\n    elif id(a) == id(b.base) or id(a.base)==id(b): \n        print(\"뷰\")\n    elif (id(a.base)!=id(None) and id(b.base)!=id(None)) and id(a.base) == id(b.base):\n        print(\"공통의 base를 가짐\")\n    else: \n        print(\"카피, 혹은 아무 관련없는 오브젝트\") \n\n- 잘 동작하나?\n(테스트1)\n\na=np.array([1,2,3,4])\nb=a\n\n\ntest(a,b)\n\n별명\n\n\n(테스트2)\n\na=np.array([1,2,3,4])\nb=a.view()\n\n\ntest(a,b)\n\n뷰\n\n\n(테스트3)\n\na=np.array([1,2,3,4])\nb=a.view()\nc=a.view()\n\n\ntest(b,c)\n\n공통의 base를 가짐\n\n\n\ntest(a,b)\n\n뷰\n\n\n\ntest(a,c)\n\n뷰\n\n\n(테스트4)\n\na=np.array([1,2,3,4])\nb=a.copy()\n\n\ntest(a,b)\n\n카피, 혹은 아무 관련없는 오브젝트"
  },
  {
    "objectID": "PP2023/posts/2023-06-21-13wk-1.html#결론",
    "href": "PP2023/posts/2023-06-21-13wk-1.html#결론",
    "title": "13wk-1: 깊은복사와 얕은복사",
    "section": "결론",
    "text": "결론\n- 참조, 뷰, 카피의 개념을 잘 알고 있고 때에 따라 메모리를 아끼면서 이들을 적절하게 사용하고 싶을것 같음. 하지만 이건 불가능한 소망임.\n- 우리가 사용했던 어떠한 것들이 뷰가 나올지 카피가 나올지 잘 모른다. (그래서 원리를 이해해도 대응할 방법이 사실없음)\n\n예시1\n\na=np.array([1,2,3,4])\nb=a[:3]\n\n\na\n\narray([1, 2, 3, 4])\n\n\n\nb\n\narray([1, 2, 3])\n\n\n\ntest(a,b)\n\n뷰\n\n\n\nc=a[[0,1,2]]\nc\n\narray([1, 2, 3])\n\n\n\ntest(a,c)\n\n카피, 혹은 아무 관련없는 오브젝트\n\n\n\n\n예시2\n\na=np.array([[1,2],[3,4]])\na\n\narray([[1, 2],\n       [3, 4]])\n\n\n\nb=a.flatten() # 플래튼은 펼치는건데..\nc=a.ravel() # 라벨도 펼치라는 뜻인데..\nd=a.reshape(-1) # 이것도 뜻은 펼치는건데..\n# 걍 다 똑같은거아냐?\n\n\ntest(a,b)\n\n카피, 혹은 아무 관련없는 오브젝트\n\n\n\ntest(a,c)\n\n뷰\n\n\n\ntest(a,d)\n\n뷰\n\n\n\ntest(c,d)\n\n공통의 base를 가짐\n\n\n\ntest(b,c)\n\n카피, 혹은 아무 관련없는 오브젝트\n\n\n- 심지어 copy인줄 알았던것이 사실 view라서 원치않는 side effect이 생길수 있음. \\(\\to\\) 그냥 방어적 프로그래밍이 최선인듯"
  },
  {
    "objectID": "PP2023/posts/2023-06-19-15wk-2-fin.html",
    "href": "PP2023/posts/2023-06-19-15wk-2-fin.html",
    "title": "15wk-2: 기말고사",
    "section": "",
    "text": "제출은 *.ipynb, *.html, *.pdf 파일로 제출할 것\n\nipynb 파일형태제출을 권장함.\n\n\nimports\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport datetime\n\n\n\n1. 묵찌빠 (150점)\n\n\n\n\n\n\n묵찌빠\n\n\n\nref: https://namu.wiki/w/묵찌빠\n묵찌빠는 가위바위보의 변형 놀이이다. 보통 가위바위보의 게임과 연이어 진행되는데, 가위바위보 승부 이후 이긴 사람이 공격권을 가지고, 묵(바위)/찌(가위)/빠(보자기) 가운데 하나를 외치는 동시에 말한 것과 일치하도록 손 모양을 바꾼다. 공격권을 가진 사람의 손 모양이 상대(수비권을 가진 사람)의 손 모양과 일치하면 공격권을 가진 사람의 승리한다. 승부가 갈리지 않았을 경우에는 다시 가위바위보를 하는 것이 아니라, 현 상태에서 가위바위보 규칙 상 이긴 사람이 공격권을 가져가게 된다.\n\n\n(1) 아래는 RPS_BASE 클래스의 구현예시이다.\n\nclass RPS_BASE:\n    def __init__(self,candidate):\n        self.candidate = candidate\n        self.actions = list() \n    def __setitem__(self,index,val):\n        self.actions[index] = val\n    def __getitem__(self,item):\n        return self.actions[item]        \n    def __len__(self):\n        return len(self.actions)\n    def __eq__(self,other):\n        return self[-1] == other[-1]\n    def __gt__(self,other):\n        return [self[-1],other[-1]] in [['묵','찌'],['찌','빠'],['빠','묵']]\n    def __ge__(self,other):\n        return (self == other) or (self &gt; other)\n    def __lt__(self,other):\n        return not (self &gt;= other)\n    def __le__(self,other):\n        return (self == other) or (self &lt; other)    \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} &lt;br/&gt;\n        기록: {}\n        \"\"\"        \n        return html_str.format(self.candidate,self.actions)       \n    def pick(self):\n        self.actions.append(np.random.choice(self.candidate))        \n\n이 클래스에서 아래와 같은 2명의 플레이어 인스턴스를 생성하라.\n\na: [‘묵’,‘찌’] 중에 하나를 랜덤으로 선택\nb: [‘찌’,‘빠’] 중에 하나를 랜덤으로 선택\n\n두 인스턴스를 100회 랜덤대결하고 결과를 기록하라. 어떠한 플레이어가 더 유리한가?\n\n답안은 100회중 a몇회 승리, b몇회 승리와 같은 숫자형식으로만 나오면 인정한다. (코드를 정리하거나 별도의 클래스를 만드는 것을 요구하지 않음)\n\n\n(2) RPS_BASE에서 아래와 같은 두명의 플레이어 인스턴스를 생성하라.\n\na: [‘묵’,‘찌’,‘빠’] 중 하나를 랜덤으로 선택\nb: [‘찌’,‘빠’] 중 하나를 랜덤으로 선택\n\n아래와 같은 a,b의 attribute을 변경하라.\n\na.modes = [None]\na.actions = [None] \nb.modes = [None]\nb.actions = [None]\n\n플레이어 a,b를 이용하여 반복적으로 가위바위보 대결을 수행하고 아래와 같이 대결결과에 따라 공격권을 결정하는 함수 mul을 만들어라.\n경우1: 플레이어 a가 승리할 경우\n\na가 공격모드, b가 수비모드가 된다.\na.modes에는 ‘Attack’ 이 b.modes에는 Defence가 추가된다.\na.actions와 b.actions는 각각의 플레이어가 선택한 패(묵,찌,빠)가 기록된다.\n\n경우2: 플레이어 b가 승리할 경우\n\nb가 공격모드, a가 수비모드가 된다.\nb.modes에는 ‘Attack’ 이 a.modes에는 Defence가 추가된다.\na.actions와 b.actions는 각각의 플레이어가 선택한 패(묵,찌,빠)가 기록된다.\n\n경우3: 비길경우\n\n공격권의 변화는 없다.\na.modes,b.modes는 각각 이전의 값이 추가된다.\na.actions와 b.actions는 각각의 플레이어가 선택한 패(묵,찌,빠)가 기록된다.\n\n아래는 함수 mul을 사용한 예시이다.\n시점1: 둘다 찌를 내어 공격권을 아무도 획득하지못함\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌']\n        \n\n\n\na.modes\n\n[None, None]\n\n\n\nb.modes\n\n[None, None]\n\n\n시점2: 이번에도 둘다 찌를 내어 아무도 공격권을 획득하지 못함\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '찌']\n        \n\n\n\na.modes\n\n[None, None, None]\n\n\n\nb.modes\n\n[None, None, None]\n\n\n시점3: 이번에는 a가 공격권을 획득 (묵&gt;찌)\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '묵']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '찌', '찌']\n        \n\n\n\na.modes\n\n[None, None, None, 'Attack']\n\n\n\nb.modes\n\n[None, None, None, 'Defence']\n\n\n시점4: 이번에는 b가 공격권을 획득 (찌&gt;빠)\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '묵', '빠']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '찌', '찌', '찌']\n        \n\n\n\na.modes\n\n[None, None, None, 'Attack', 'Defence']\n\n\n\nb.modes\n\n[None, None, None, 'Defence', 'Attack']\n\n\n\n(3) RPS_BASE를 상속받아 MookjjibbaPlayer라는 새로운 클래스를 정의하라. MookjjibbaPlayer 클래스에서 아래의 메소드를 새롭게 정의 혹은 재정의하여\n\n__init__\n_repr_html_\n__mul__\nreset\n\n인스턴스가 아래와 같은 동작을 하도록 설계하라.\n시점0: 생성예시 (__init__)\n\na=MookjjibbaPlayer(['묵','찌','빠'])\nb=MookjjibbaPlayer(['묵','찌','빠'])\n\n\na.actions\n\n[None]\n\n\n\na.modes\n\n[None]\n\n\n\n\n\n\n\n\n__init__ 의 동작\n\n\n\n\n슈퍼클래스(RPS_BASE)의 __init__을 동작시킴\nMookjjibbaPlayer의 인스턴가 가지는 actions, modes 값을 [None] 으로 초기화\n\n\n\n시점0: 출력예시(_repr_html_)\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\n\n\n\n\n\n_repr_html_ 의 동작\n\n\n\n위와 같이 “낼 수 있는 패”, “기록”, “모드” 가 함께 출력되도록 설계할 것\n\n\n시점1: 대결 및 결과출력 (__mul__, _repr_html_)\n\na*b\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵'] \n        모드: [None, None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵'] \n        모드: [None, None] \n        \n\n\n\n\n\n\n\n\n__mul__ 의 동작\n\n\n\n\n두 플레이어의 대결을 진행\n결과를 보고 modes 의 값을 update\n\n위의 상황은 두 플레이어 모두 “묵”을 내어 어느쪽도 공격권을 가지지 못한 상태를 의미\n\n\n시점2: 대결 및 결과출력 (__mul__, _repr_html_)\n\na*b\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵', '묵'] \n        모드: [None, None, 'Defence'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵', '빠'] \n        모드: [None, None, 'Attack'] \n        \n\n\n\n\n\n\n\n\n__mul__ 의 동작\n\n\n\n\n두 플레이어의 대결을 진행\n결과를 보고 modes 의 값을 update\n\n위의 상황은 a가 묵, b가 빠를 내어 b가 공격권을 획득한 상황을 의미\n\n\n시점3: 대결결과의 초기화 (reset)\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵', '묵'] \n        모드: [None, None, 'Defence'] \n        \n\n\n\na.reset()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\n\n\n\n\n\nreset 의 동작\n\n\n\n\n플레이어의 기록을 초기화\n플레이어의 모드를 초기화\n\n\n\n(4) (3) 에서 생성된 MookjjibbaPlayer의 두 개의 인스턴스 a,b를 입력으로 받고 최초공격권을 결정하는 함수 jumpball을 설계하라.\n아래는 jumpball함수의 사용예시이다.\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\njumpball(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '찌'] \n        모드: [None, None, None, 'Defence'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '묵'] \n        모드: [None, None, None, 'Attack'] \n        \n\n\nhint: 아래의 코드를 관찰\n\na = [] \nb = [] \na.append(np.random.choice([0,1,2]))\nb.append(np.random.choice([0,1,2]))\nwhile a==b: \n    a.append(np.random.choice([0,1,2]))\n    b.append(np.random.choice([0,1,2]))\n\n\na\n\n[0, 0, 0, 1]\n\n\n\nb\n\n[0, 0, 0, 0]\n\n\n(5) 지금까지 코드를 바탕으로\n\na: [‘묵’,‘찌’] 중 하나를 랜덤으로 고르는 플레이어\nb: [‘찌’,‘빠’] 중 하나를 랜덤으로 고르는 플레이어\n\n를 설정하여 100회 가상대결을 진행하라. 100회 가상대결결과를 제시하라.\n(참고) – 아래는 제가 구현한 예시입니다. 참고용일 뿐이며 이와 같은 방식으로 구현할 필요는 없습니다.\n1. a,b 두명의 플레이어 생성\n\na=MookjjibbaPlayer(['묵','찌'])\nb=MookjjibbaPlayer(['찌','빠'])\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\na,b 플레이어가 초기화\n\n2. a,b 두명의 플레이어를 입력으로 하여 게임1을 생성후 1회 게임진행\n\ngame = PlayMookjjibba(a,b)\n\n\ngame.play()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None, '찌', '묵', '묵', '찌'] \n        모드: [None, 'Attack', 'Defence', 'Defence', 'Defence'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '빠', '빠', '빠', '찌'] \n        모드: [None, 'Defence', 'Attack', 'Attack', 'Attack'] \n        \n\n\n\na가 찌, b가 빠를 내어 최초 공격권을 a가 획득하였지만 이후 공격권을 상실한 상실함. 이후 4번째 가위바위보에서 b가 a가 동시에 찌를 내며 b의 승리로 마무리됨\n\n3. game.records 에 b의 승리가 기록되어 있음\n\ngame.records \n\n['b']\n\n\n4. 1회 대결기록을 삭제하고 또 다른 게임을 진행: 이번에는 a의 승리\n\ngame.reset_player_history()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\ngame.play()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None, '찌', '찌', '찌'] \n        모드: [None, None, 'Attack', 'Attack'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '빠', '찌'] \n        모드: [None, None, 'Defence', 'Defence'] \n        \n\n\n\n공격권은 2번만에 A가 획득, 1번의 공격을 통하여 마무리\n\n5. 이번에는 a의 승리가 기록됨\n\ngame.records\n\n['b', 'a']\n\n\n\n\n2. 종합문항 (50점)\n(1) LinearRegression 이라는 이름의 클래스를 만들고 아래의 기능을 넣어라.\n__init__: “클래스 \\(\\to\\) 인스턴스” 인 시점에 길이가 \\(n\\)인 numpy array \\({\\bf x}=(x_1,\\dots,x_n)\\), \\({\\bf y}=(y_1,\\dots,y_n)\\)을 입력으로 받아 내부에 저장한다.\nfit: fit은 내부에 저장된 \\({\\bf x}\\), \\({\\bf y}\\)를 이용하여 \\(\\hat{\\bf y}=(\\hat{y}_1,\\dots,\\hat{y}_n)\\)을 계산하는 역할을 한다. 계산은 아래의 수식을 이용한다. \\[\\hat{\\bf y}= {\\bf X}({\\bf X}^T {\\bf X})^{-1}{\\bf X}^T {\\bf y}, \\quad {\\bf X}=\\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\dots \\\\ 1 & x_n \\end{bmatrix}\\]\nplot: plot은 \\((x_i,y_i)\\)와 \\((x_i,\\hat{y}_i)\\)를 시각화하는 역할을 한다.\n아래의 자료를 LinearRegression의 입력으로 받고 시각화하는 분석을 수행하라.\n\nx = np.linspace(0,1,100)\ny = 2*x + np.random.normal(size=100)\nplt.plot(x,y,'o')\n\n\n\n\n(2) 앞면과 뒷면이 나올 확률이 각각 1/2인 동전을 생각하자. 하니와 규빈은 이 동전을 연속으로 던져서 아래와 같은 룰을 정하여 내기를 하였다.\n\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,앞면) 이 나오면 하니의 승리\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,뒷면) 이 나오면 규빈의 승리\n\n이 내기는 하니가 유리한가? 규빈이 유리한가? 시뮬레이션을 통해 검증하라.\n\n\n\n\n\n\nNote\n\n\n\nhint: 똑같이 유리하다\n\n\n(3) 앞면과 뒷면이 나올 확률이 각각 1/2인 동전을 생각하자. 하니와 규빈은 이 동전을 연속으로 던져서 아래와 같은 룰을 정하여 내기를 하였다.\n\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (앞면,뒷면) 이 나오면 하니의 승리\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,뒷면) 이 나오면 규빈의 승리\n\n이 내기는 하니가 유리한가? 규빈이 유리한가? 시뮬레이션을 통해 검증하라.\n\n\n\n\n\n\nNote\n\n\n\nhint: 이 내기는 하니가 유리하다.\n\n\n(4) Time을 상속받아 Init 클래스를 만들고 __repr__을 조작하여 아래와 같이 인스턴스 생성시점을 출력하는 기능을 구현하라.\n\nclass Time:\n    def time(self):\n        return datetime.datetime.now().strftime('%y-%m-%d %X')\n\n\na = Init()\n\n\na\n\n인스턴스생성시점: 23-06-16 10:27:19\n\n\n\nb = Init()\n\n\na,b\n\n(인스턴스생성시점: 23-06-16 10:27:19, 인스턴스생성시점: 23-06-16 10:27:28)\n\n\n(5) tuple 클래스와 아래의 Check를 상속받아 아래와 같은 역할을 하는 새로운 Tuple 클래스를 만들라.\n\nclass Check:\n    def ckeck(self):\n        return [l for l in dir(self) if l[0]!='_']\n\n\ntpl = Tuple('asdfassdfsasdf')\ntpl # 값과 함께 사용가능한 메소드가 함께 출력 \n\n('a', 's', 'd', 'f', 'a', 's', 's', 'd', 'f', 's', 'a', 's', 'd', 'f')\n\nmethods=['ckeck', 'count', 'freq', 'index']\n\n\n\ntpl.freq()\n\n{'d': 3, 'a': 3, 's': 5, 'f': 3}\n\n\n(6) 아래와 같은 클래스를 고려하자.\n\nclass Init(object):\n    def __init__(self,value):\n        self.value = value\n        \nclass Times2(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value * 2\n        \nclass Plus5(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value + 5\n\nPlus5와 Times2를 상속하여 적당한 클래스 Times2Plus5를 정의하고 생성과 동시에 \\(x \\to (x\\times 2)+5\\) 를 수행도록 하라.\n사용예시\n\na=Times2Plus5(0)\na.value\n\n5\n\n\n\na=Times2Plus5(1)\na.value\n\n7\n\n\n\na=Times2Plus5(5)\na.value\n\n15\n\n\n(7) 아래의 함수가 있다고 하자.\n\ndef f(x): \n    return np.sin(x)\n\n적당한 함수 derivate를 정의하여 함수를 입력으로 받으면 그 도함수를 출력으로 리턴하도록 하라. 아래의 코드를 이용하여 검증하라.\n\nx = np.linspace(-6,6,100)\nplt.plot(x,f(x),label=r'$f(x)=\\sin(x)$')\nplt.plot(x,(derivate(f))(x),label=r'$f\\'(x)=\\cos(x)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f236da92ee0&gt;\n\n\n\n\n\n(8) Student 클래스를 생성지침 및 사용예시를 참고하여 설계하라.\n생성지침\nattributes\n\nname: 이름을 저장하는 변수\nage: 나이를 저장하는 변수\nsemester: 학기를 저장하는 변수\n\nmethods\n\n__init__: name, age, semester 세 가지 매개변수를 입력받아 인스턴스의 attribute로 저장\n__str__: 인스턴스의 정보(이름,나이,학기)를 문자열 형태로 반환\n\n사용예시\n\n# 사용 예시\nboram = Student(name='김보람', age=20, semester=1)\nprint(boram)\n\n이름: 김보람\n나이: 20\n학기: 1\n\n\n(9) 8의 클래스를 상속받아 Student2 만들라. __add__ 재정의하여 Student2의 인스턴스가 아래와 같이 동작하도록 하라.\n\nboram = Student2()\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록'+ '휴학' + '등록' + '휴학'\nboram\n\n\n        나이: 22.0 \n        학기: 2 \n        \n\n\n\n4학기가 지났으므로 나이는 22살이 된다. 4학기중 2학기만 등록하였으므로 현재는 2학기를 마친상태이다.\n\n(10) 적당한 클래스를 선언하여 \\(f(x)=x+{\\tt const}\\)를 수행하는 함수를 생성하도록 하라.\n사용예시1\n\nf = AddConstant(5) # f(x) = x+5 \n\n\nf(10)\n\n15\n\n\n사용예시2\n\nf = AddConstant(-3) # f(x) = x-3\n\n\nf(10)\n\n7"
  },
  {
    "objectID": "PP2023/posts/2023-03-06-1wk-1.html",
    "href": "PP2023/posts/2023-03-06-1wk-1.html",
    "title": "01wk-1: 강의소개",
    "section": "",
    "text": "이 수업을 들어야 하는 이유\n생략\n\n\n\n이 수업을 듣지 말아야 하는 이유\n1. F학점을 많이 준다.\n\n30%까지 F를 줄 수 있음.\nF학점은 태도점수+시험성적을 종합하여 부여함 (태도점수로만 부여하지 않음)\n\n2. 파이썬을 배울 수 있는 다른 대안이 많다.\n\nChatGPT\n패스트캠퍼스\n학원\n각종 캠프\n\n3. cost-effective 하지 않음\n\n열심히 공부해도 시험성적이 안 좋을 수 있음. \\(\\to\\) 학점도 안좋아짐\n왜? (1) 타전공 고수들이 많음 (2) 시험문제가 어려움 (3) 기출문제가 별 의미없음 (4) 적성에 안 맞음\n\n4. 꼭 파이썬을 배워야 할까?\n이거 꼭 들어야 졸업가능? –&gt; 파이썬을 못하면 선택의 폭이 좁아지긴 하지만 졸업불가능한 정도는 아님\n\nhttps://stat.jbnu.ac.kr/stat/6453/subview.do\n\n파이썬 못하면 굶어죽을까? –&gt; 몇몇 진로에서는 파이썬이 필요함. 그런데 다 그런건 아님\n통계학과 졸업생이 갈 수 있는 진로들\n\n의약계열: 전북대병원, XX병원, XX제약, 셀트리온, 삼성바이오\n\n금융계열: 전북은행, XX은행, XX증권, XX화재\n공무원,공기업: 통계청, 9급공무원, 국민연금 등\n기타 대기업: 삼성전자 (인사과)…\n국책연구기관: 에트리, 한국교통연구원 등\n금융공기업: 한국은행, 금융감독원, 한국거래소 등\n제조업: 삼성전자, 하이닉스, LG전자, 현대자동차 등 (스마트팩토리)\n통신사: SKT, KT, LGU\n컨설팅: 베가스, 삼성SDS, LG-CNS 등\n게임회사: 엔씨, 넷마블, 위메이드 등\n인공지능, 빅데이터: 네이버, 카카오, 라인, 쿠팡, 배민(?), SKT, 삼성, LG, …\n순수IT:\n\n\n\n\n수업진행\n\n다음시간부터 개인 노트북 지참\nwifi: 218-5G-1. 218-5G-2\n가급적 영상 올릴 생각… (복습용도)\n질문: 카톡, 이메일, 직접방문, 줌, 등등~"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-07-14wk-2.html#비밀12-__iter__-starstarstarstarstar",
    "href": "PP2023/posts/03_Class/2023-06-07-14wk-2.html#비밀12-__iter__-starstarstarstarstar",
    "title": "14wk-2: 클래스공부 4단계 – 파이썬의 비밀 (3)",
    "section": "비밀12: __iter__ (\\(\\star\\star\\star\\star\\star\\))",
    "text": "비밀12: __iter__ (\\(\\star\\star\\star\\star\\star\\))\n\nfor문의 복습\n- 아래와 같은 예제들을 관찰하여 for문을 복습하자.\n(예제1) [1,2,3,4]\n\nfor i in [1,2,33,4]:\n    print(i)\n\n1\n2\n33\n4\n\n\n(예제2) (1,2,3,4)\n\nfor i in (1,2,33,4):\n    print(i)\n\n1\n2\n33\n4\n\n\n(예제3) ‘1234’\n\nfor i in '123asdf':\n    print(i)\n\n1\n2\n3\na\ns\nd\nf\n\n\n(예제4) 5\n\nfor i in 5:\n    print(i)\n\nTypeError: 'int' object is not iterable\n\n\n- 의문1:\nfor i in ???:\n    print(i)\n에서 ??? 자리에 올수 있는 것이 무엇일까?\n(예제5) [[1,2,3,4],[3,4,5,6]], pd.DataFrame([[1,2,3,4],[3,4,5,6]])\n\nlst = [[1,2,3,4],[3,4,5,6]]\nlst\n\n[[1, 2, 3, 4], [3, 4, 5, 6]]\n\n\n\nfor l in lst:\n    print(l)\n\n[1, 2, 3, 4]\n[3, 4, 5, 6]\n\n\n\nfor l in np.array(lst):\n    print(l)\n\n[1 2 3 4]\n[3 4 5 6]\n\n\n\nfor l in pd.DataFrame(lst):\n    print(l)\n\n0\n1\n2\n3\n\n\n- 데이터프레임인 경우는 colname이 반복\n\ndf = pd.DataFrame({'x':[1,2,3],'y':[2,3,4]})\ndf\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n1\n2\n\n\n1\n2\n3\n\n\n2\n3\n4\n\n\n\n\n\n\n\n\nfor d in df:\n    print(d)\n\nx\ny\n\n\n- 의문2: for의 출력결과는 어떻게 예측할 수 있을까?\n\n\nfor문의 동작원리\n- 의문1의 해결: 아래의 ??? 자리에 올 수 있는 것은 dir()하여 __iter__가 있는 object이다.\nfor i in ???:\n    print(i)\n이러한 오브젝트를 iterable object라고 한다.\n- 예제1~4 확인\n\nlst = [1,2,3]\nset(dir(lst)) & {'__iter__'}\n\n{'__iter__'}\n\n\n\ntpl = 1,2,3\nset(dir(tpl)) & {'__iter__'}\n\n{'__iter__'}\n\n\n\nstring = '123'\nset(dir(string)) & {'__iter__'}\n\n{'__iter__'}\n\n\n\na = 5\nset(dir(a)) & {'__iter__'}\n\nset()\n\n\n- __iter__의 역할: iterable object를 iterator로 만들 수 있다!\n\nlst = [1,22,-33]\n\n\nlst_iterator = lst.__iter__() \n# lst_iterator = iter(lst)\n\n- iterator가 되면 무엇이 좋은가? -&gt; 숨겨진 기능 __next__가 열린다.\n\nset(dir(lst_iterator)) & {'__next__'}\n\n{'__next__'}\n\n\n- 그래서 __next__의 기능은? -&gt; 원소를 차례대로 꺼내준다 + 더 이상 꺼낼 원소가 없으면 StopIteration Error를 발생시킨다.\n\nnext(lst_iterator)\n# lst_iterator.__next__() # 같은코드\n\n1\n\n\n\nnext(lst_iterator)\n# lst_iterator.__next__() # 같은코드\n\n22\n\n\n\nnext(lst_iterator)\n# lst_iterator.__next__() # 같은코드\n\n-33\n\n\n\nnext(lst_iterator)\n# lst_iterator.__next__() # 같은코드\n\nStopIteration: \n\n\n- for문의 동작원리\nfor i in iterable:\n    ...\n\n이터레이터생성: .__iter__() 혹은 iter()을 이용하여 iterable을 iterator로 만든다.\n\\(i\\)생성 및 반복: 1에서 만들어진 iterator에서 .__next__()함수를 호출하고 결과를 \\(i\\)에 저장한뒤 for문 블락안의 내용 (들여쓰기 된 내용) 을 실행한다. \\(\\to\\) 반복한다.\n정지: .__next__()함수를 호출할때 StopIteration Error가 나오면 for문을 멈춘다.\n\n\n\n\n\nflowchart LR\n  A[iterable] --&gt; |\"__iter__()\"| B(iterator)\n  B --&gt; |\"__next__()\"| C{stop?}\n  C --&gt; |NO| D[i] --&gt; E[...] --&gt; B\n  C --&gt; |YES| F[end]\n\n\n\n\n\n- 아래의 구조도 잘 돌아갈까?\nfor i in iterator:\n    print(i)\n\niterator의 iter가 자기자신을 리턴하도록 하는 트릭을 쓰면 “1.이터레이터생성 2.\\(i\\)생성 및 반복 3.정지”의 동작원리를 수정하지 않고 for문을 안전하게 돌릴 수 있다.\n\n\n\n\n\nflowchart LR\n  A(iterator) --&gt; |\"__iter__()\"| B(iterator)\n  B --&gt; |\"__next__()\"| C{stop?}\n  C --&gt; |NO| D[i] --&gt; E[...] --&gt; B\n  C --&gt; |YES| F[end]\n\n\n\n\n\n- 요약\n\niterable object는 숨겨진 기능으로 __iter__를 가진다.\niterator는 숨겨진 기능으로 __iter__와 __next__를 가진다. 따라서 정의상 iterator는 그 자체로 iterable object가 된다!\niterator의 __iter__는 자기자신을 리턴한다.\n\n- 의문2의 해결: for의 출력결과는 어떻게 예측할 수 있을까? iterator를 만들어서 .__next__()의 출력값을 확인하면 알 수 있다.\n\n_df_itertor = iter(df)\n\n\nnext(_df_itertor)\n\n'x'\n\n\n\nnext(_df_itertor)\n\n'y'\n\n\n\nnext(_df_itertor)\n\nStopIteration: \n\n\n\n\n사용자정의 이터레이터\n- 내가 이터레이터를 만들어보자.\n- 찌를 내는 순간 for문이 멈추도록 하는 이터레이터를 만들자.\n\nclass RPS_ITERATOR: # 찌를 내는순간 for문이 멈추도록 하는 이터레이터를 만들자\n    def __init__(self): \n        self.candidate = [\"묵\",\"찌\",\"빠\"] \n    def __iter__(self):\n        return self \n    def __next__(self):\n        action = np.random.choice(self.candidate)\n        if action == \"찌\":\n            print(\"찌가 나와서 for문을 멈춥니다\")\n            raise StopIteration\n        else:\n            return action\n\n\na = RPS_ITERATOR()\n\n\na.__next__()\n\n'빠'\n\n\n\na.__next__()\n\n'묵'\n\n\n\na.__next__()\n\n'묵'\n\n\n\na.__next__()\n\n찌가 나와서 for문을 멈춥니다\n\n\nStopIteration: \n\n\n\nfor i in a:\n    print(i)\n\n빠\n묵\n묵\n빠\n빠\n찌가 나와서 for문을 멈춥니다\n\n\n\n\nrange()\n- 파이썬에서 for문을 처음 배울 때: range(5)를 써라!\n\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\nrange(5)가 도데체 무엇이길래?\n\n- range(5)의 정체는 그냥 iterable object이다.\n\nset(dir(range(5))) & {'__iter__','__next__'}\n\n{'__iter__'}\n\n\n- 그래서 언제든지 iterator로 바꿀 수 있다.\n\nrtor= iter(range(5))\nrtor\n\n&lt;range_iterator at 0x7f9a8e84f5d0&gt;\n\n\n\nset(dir(rtor)) &  {'__iter__','__next__'}\n\n{'__iter__', '__next__'}\n\n\n- for문에서 range(5)가 행동하는 방법?\n\nrtor = iter(range(5))\n\n\nrtor.__next__()\n\n0\n\n\n\nrtor.__next__()\n\n1\n\n\n\nrtor.__next__()\n\n2\n\n\n\nrtor.__next__()\n\n3\n\n\n\nrtor.__next__()\n\n4\n\n\n\nrtor.__next__()\n\nStopIteration: \n\n\n\n\nzip\n- 이터레이터의 개념을 알면 for문에 대한 이해도가 대폭 상승한다.\n\nfor i,j in zip([1,2,3],'abc'):\n    print(i,j)\n\n1 a\n2 b\n3 c\n\n\n\nzip은 뭐지?\n\n\nzip([1,2,3],'abc')\n\n&lt;zip at 0x7f9a8e7dd5c0&gt;\n\n\n- 어차피 for i in ????: 의 ???? 자리는 iterable object의 자리이다.\n\nset(dir(zip([1,2,3],'abc'))) & {'__iter__','__next__'}\n\n{'__iter__', '__next__'}\n\n\n\n__next__()함수가 있음 \\(\\to\\) zip([1,2,3],'abc')은 그자체로 iterator 였다!\n\n\nz= zip([1,2,3],'abc')\n\n\nz.__next__()\n\n(1, 'a')\n\n\n\nz.__next__()\n\n(2, 'b')\n\n\n\nz.__next__()\n\n(3, 'c')\n\n\n\nz.__next__()\n\nStopIteration: \n\n\n또다른 이해: 그러고보니까 zip([1,2,3],'abc')은 뭐하는 문법이지?\n\nzip?\n\n\nInit signature: zip(self, /, *args, **kwargs)\nDocstring:     \nzip(*iterables) --&gt; A zip object yielding tuples until an input is exhausted.\n   &gt;&gt;&gt; list(zip('abcdefg', range(3), range(4)))\n   [('a', 0, 0), ('b', 1, 1), ('c', 2, 2)]\nThe zip object yields n-length tuples, where n is the number of iterables\npassed as positional arguments to zip().  The i-th element in every tuple\ncomes from the i-th iterable argument to zip().  This continues until the\nshortest argument is exhausted.\nType:           type\nSubclasses:     \n\n\n\n\n너 클래스였어?\n\n\niterator_from_zip = zip.__call__([1,2,3],'abc')\n\n\nfor i,j in iterator_from_zip:\n    print(i,j)\n\n1 a\n2 b\n3 c\n\n\n\n파이썬의 작은 비밀: zip은 iterator를 찍어내는 클래스이다.\n\n\n\nenumerate\n- zip의 짝궁으로 enumerate가 있음\n\nfor i,s in enumerate('abc'):\n    print(i,s)\n\n0 a\n1 b\n2 c\n\n\n- enumerate('abc')도 문법상 iterable object 아니면 iterator 임.\n\nset(dir(enumerate('abc'))) & {'__iter__', '__next__'}\n\n{'__iter__', '__next__'}\n\n\n\niterator 였군\n\n\niterator = enumerate('abc')\n\n\nnext(iterator)\n\n(0, 'a')\n\n\n\nnext(iterator)\n\n(1, 'b')\n\n\n\nnext(iterator)\n\n(2, 'c')\n\n\n\nnext(iterator)\n\nStopIteration: \n\n\n- 참고: enumerate 는 클래스임\n\nenumerate?\n\n\nInit signature: enumerate(iterable, start=0)\nDocstring:     \nReturn an enumerate object.\n  iterable\n    an object supporting iteration\nThe enumerate object yields pairs containing a count (from start, which\ndefaults to zero) and a value yielded by the iterable argument.\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...\nType:           type\nSubclasses:     \n\n\n\n\n파이썬의 작은 비밀: enumerate 역시 iterator를 찍어내는 클래스다.\n\n\n파이썬의 비밀12: iterator나 iterable object만 for문과 함께 사용할 수 있다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-07-14wk-2.html#비밀을-알아서-좋은점",
    "href": "PP2023/posts/03_Class/2023-06-07-14wk-2.html#비밀을-알아서-좋은점",
    "title": "14wk-2: 클래스공부 4단계 – 파이썬의 비밀 (3)",
    "section": "비밀을 알아서 좋은점",
    "text": "비밀을 알아서 좋은점\n\n파이썬의 에러메시지 이해\nTypeError: 타입이 맞지 않는 연산을 수행하려고 할 때 발생. 예를 들어, 숫자와 문자열을 더하려고 할 때 발생.\n\nresult = 10 + \"20\"  # TypeError: unsupported operand type(s) for +: 'int' and 'str'\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\n\nSyntaxError: 코드의 구문이 잘못되었을 때 발생. 주로 오타, 괄호 불일치, 콜론(:) 빠뜨림 등의 문제로 인해 발생.\n\nif x == 5\n    print(\"x is equal to 5\")  # SyntaxError: invalid syntax\n\nSyntaxError: invalid syntax (&lt;ipython-input-23-5259b3c47c58&gt;, line 1)\n\n\nNameError: 정의되지 않은 변수나 함수를 사용하려고 할 때 발생.\n\nprint(unknown_variable)  # NameError: name 'unknown_variable' is not defined\n\nNameError: name 'unknown_variable' is not defined\n\n\nValueError: 함수나 메서드에 전달되는 인자의 값이 올바르지 않을 때 발생.\n\nint_value = int(\"abc\")  # ValueError: invalid literal for int() with base 10: 'abc'\n\nValueError: invalid literal for int() with base 10: 'abc'\n\n\nAttributeError: 객체가 속성(attribute)이나 메서드(method)를 가지고 있지 않을 때 발생\n\nmy_list = [1, 2, 3]\nmy_list.append(4)\nmy_list.upper()  # AttributeError: 'list' object has no attribute 'upper'\n\nAttributeError: 'list' object has no attribute 'upper'\n\n\nImportError: 모듈을 임포트하는 과정에서 문제가 발생할 때 발생. 임포트하려는 모듈이 존재하지 않거나, 임포트 경로 설정이 잘못된 경우에 해당.\n\nimport non_existent_module  # ImportError: No module named 'non_existent_module'\n\nModuleNotFoundError: No module named 'non_existent_module'\n\n\nIOError: 파일 입출력 작업 중에 발생하는 에러. 파일이 존재하지 않거나, 파일에 쓰기 권한이 없는 경우 등에 해당.\n\nfile = open('file.txt', 'r')  # IOError: [Errno 2] No such file or directory: 'file.txt'\n\nFileNotFoundError: [Errno 2] No such file or directory: 'file.txt'\n\n\nKeyboardInterrupt: 사용자가 프로그램의 실행을 중단할 때 발생.\n\nwhile True:\n    pass  # 무한 루프\n# KeyboardInterrupt: \n\nKeyboardInterrupt: \n\n\nIndexError: 유효하지 않은 인덱스를 사용하여 시퀀스(리스트, 튜플, 문자열 등)의 요소에 접근하려고 할 때 발생.\n\nmy_list = [1, 2, 3]\nprint(my_list[5])  # IndexError: list index out of range\n\nIndexError: list index out of range\n\n\nKeyError: 딕셔너리에서 존재하지 않는 키를 사용하여 요소에 접근하려고 할 때 발생.\n\nmy_dict = {'name': 'John', 'age': 25}\nprint(my_dict['address'])  # KeyError: 'address'\n\nKeyError: 'address'\n\n\nFileNotFoundError: 존재하지 않는 파일을 열려고 할 때 발생.\n\nfile = open('nonexistent_file.txt')  # FileNotFoundError: [Errno 2] No such file or directory: 'nonexistent_file.txt'\n\nFileNotFoundError: [Errno 2] No such file or directory: 'nonexistent_file.txt'\n\n\nZeroDivisionError: 0으로 나누기 연산을 수행하려고 할 때 발생.\n\nresult = 10 / 0  # ZeroDivisionError: division by zero\n\nZeroDivisionError: division by zero\n\n\n\n\nTypeError에 대한 심층분석\n- .__add__ 가 올바르게 정의되지 않아서 생기는 경우\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[37], line 1\n----&gt; 1 boram + '등록'+ '휴학' + '등록' + '휴학'\n\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'str'\n- .__getitem__이 정의되지 않은 오브젝트에서 인덱싱을 시도할때 생기는 오류\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[57], line 1\n----&gt; 1 a[0], a[1]\n\nTypeError: 'RPS' object is not subscriptable\n- .__setitem__이 정의되지 않은 오브젝트에서 할당을 시도할때 생기는 오류\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[77], line 1\n----&gt; 1 a[0] = '보' \n\nTypeError: 'RPS_Ver2' object does not support item assignment\n- .__len__ 이 정의되지 않은 오브젝트에서 len을 이용할때 생기는 오류\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[122], line 1\n----&gt; 1 len(a)\n\nTypeError: object of type 'RPS_Ver3' has no len()\n\n- .__call__이 정의되지 않은 오브젝트를 함수처럼 이용하려 할때 생기는 오류\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[402], line 1\n----&gt; 1 a()\n\nTypeError: 'Klass' object is not callable\n- .__iter__가 정의되지 않은 오브젝트를 iterable 오브젝트처럼 사용하려 할때 생기는 오류\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[422], line 2\n      1 a=5 \n----&gt; 2 for i in a:\n      3     print(i) \n\nTypeError: 'int' object is not iterable"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀1-자료형에-대한-비밀",
    "href": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀1-자료형에-대한-비밀",
    "title": "13wk-2: 클래스공부 4단계 – 파이썬의 비밀 (1)",
    "section": "비밀1: 자료형에 대한 비밀",
    "text": "비밀1: 자료형에 대한 비밀\n탐구: 인스턴스의 자료형이 뭔지 탐구해보자!\n- 아래의 클래스를 선언해보자.\n\nclass JungKKuckMa:\n    def __init__(self):\n        self.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\n        self.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\n        self.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\n        self.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\n        self.highlight = '마음'\n        self.html_str =\\\n        '''\n        &lt;style&gt;\n            .title {{\n                font-family: \"Times New Roman\", serif;\n                font-size: 30px;\n                font-weight: 900;\n            }}\n            .text {{\n                font-family: \"Arial\", sans-serif;\n                font-size: 20px;\n                font-style: italic;\n            }}\n            .highlight {{\n                font-family: \"Montserrat\", monospace;\n                font-size: 35px;\n                font-weight: 900;\n                text-decoration: underline;\n                font-style: normal;\n                color: darkblue;\n                background-color: #FFFF00;\n            }}\n        &lt;/style&gt;\n        &lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n        &lt;img src={url} width=\"600\"&gt;\n        &lt;p&gt; \\n &lt;/p&gt;\n        &lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n        &lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n        &lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n        '''    \n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str)) \n\n- 인스턴스를 생성해보자.\n\npp2023 = JungKKuckMa()\n\n\npp2023.show()\n\n\n        \n        파이썬 프로그래밍 중간고사 패배는 괜찮다.\n        \n         \n \n        Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n        A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n        중요한 것은 꺾이지 않는 마음\n        \n\n\n- 타입을 알아보자.\n\npp2023?\n\n\nType:        JungKKuckMa\nString form: &lt;__main__.JungKKuckMa object at 0x7f02a12c93d0&gt;\nDocstring:   &lt;no docstring&gt;\n\n\n\n- ??? 타입은 자료형, 즉 int, float, list 이런것 아니었나??\n\na=[1,2,3]\na?\n\n\n\nType:        list\nString form: [1, 2, 3]\nLength:      3\nDocstring:  \nBuilt-in mutable sequence.\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\n\n\n\n- 그런데 지금 pp2023의 자료형은 JungKKuckMa 이다.\n\n가설1: 사실 파이썬 내부에 JungKKuckMa 이라는 자료형이 있었다. 그런데 내가 만든 pp2023 이라는 인스턴스는 우연히 그 자료형을 따르는 것! (이건 너무 억지스럽다)\n가설2: 사실 “인스턴스의 자료형 = 인스턴스를 찍어낸 클래스 이름” 이다. 따라서 pp2023의 자료형이 JungKKuckMa 가 된다. 그렇다면 자료형이 list인것은 사실 list라는 클래스에서 생긴 인스턴스라고 유추할 수 있다 -&gt; 리스트자료형을 찍어낼 수 있는 어떠한 클래스가 파이썬에 내부적으로 존재할 것이다. (이게 맞는것 같다)\n\n깨달음1\n- 가설2가 맞다? 그렇다면 아래는 모두 어딘가에서 찍혀진 인스턴스이다.\n\na=[1,2,3]\na?\n\n\n\nType:        list\nString form: [1, 2, 3]\nLength:      3\nDocstring:  \nBuilt-in mutable sequence.\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\n\n\n\n\n\na=1,2,3\na?\n\n\n\nType:        tuple\nString form: (1, 2, 3)\nLength:      3\nDocstring:  \nBuilt-in immutable sequence.\nIf no argument is given, the constructor returns an empty tuple.\nIf iterable is specified the tuple is initialized from iterable's items.\nIf the argument is a tuple, the return value is the same object.\n\n\n\n\n\na=1\na?\n\n\nType:        int\nString form: 1\nDocstring:  \nint([x]) -&gt; integer\nint(x, base=10) -&gt; integer\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n&gt;&gt;&gt; int('0b100', base=0)\n4\n\n\n\n\n\na='1'\na?\n\n\nType:        str\nString form: 1\nLength:      1\nDocstring:  \nstr(object='') -&gt; str\nstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.\n\n\n\n\n- 그리고 위의 a=[1,2,3]과 같은 것들은 모두 “클래스-&gt;인스턴스”에 해당하는 과정이었음\n깨달음2\n- 생각해보니까 아래와 같이 list를 선언하는 방식도 있었음\n\na=list()\na\n\n[]\n\n\n\n이거 지금 생각하니까 list라는 이름의 클래스에서 a라는 인스턴스를 찍어내는 문법이다?!\n\n- 아래도 가능함\n\na=list((1,2,3))\na?\n\n\n\nType:        list\nString form: [1, 2, 3]\nLength:      3\nDocstring:  \nBuilt-in mutable sequence.\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\n\n\n\n\n\n이것도 지금 보니까 list라는 이름의 클래스에서 a라는 인스턴스를 찍어내는 문법이다. 여기에서 (1,2,3)은 __init__()의 입력이다.\n\n깨달음3\n- 그러고보니까 각 자료형마다 특수한 기능들이 있었음\n\na=[1,2,3] \n\n- a.+tab 을 하면 append, clear 등등이 나온다.\n- 이러한 기능은 지금까지 우리가 “list자료형 특수기능들”이라고 부르면서 사용했었다. 그런데 a가 list클래스에서 생성된 인스턴스라는 관점에서 보면 이러한 기능들은 list클래스에서 정의된 메소드라고 볼 수 있다.\n\n파이썬의 비밀1: 인스턴스의 자료형은 클래스의 이름이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀2-__init__",
    "href": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀2-__init__",
    "title": "13wk-2: 클래스공부 4단계 – 파이썬의 비밀 (1)",
    "section": "비밀2: __init__",
    "text": "비밀2: __init__\n- 예시1\n\na = '123'  \nlist(a)\n\n['1', '2', '3']\n\n\n- 예시2\n\na = list()\na.__init__('123')\na\n\n['1', '2', '3']\n\n\n- 예시3\n\na = list()\na.__init__('123') \na.__init__() # 이런식으로 다시 리스트롤 초기화하는 것도 가능\na\n\n[]\n\n\n\n파이썬의 비밀2: list(‘123’)은 사실 자료형을 변환하는 것이 아니라, ’123’을 list 클래스의 __init__() 입력으로 하여 “list 클래스 \\(\\to\\) 인스턴스” 를 수행하는 코드로 해석가능하다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀3-__str__",
    "href": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀3-__str__",
    "title": "13wk-2: 클래스공부 4단계 – 파이썬의 비밀 (1)",
    "section": "비밀3: __str__",
    "text": "비밀3: __str__\n\nmotive\n- 아래와 같은 클래스를 관찰하자.\n\nclass UpJump:\n    def __init__(self):\n        self.reset()\n    def up(self):\n        self.a = self.a + 1  \n        print(\"a의 값이 1 증가합니다.\")\n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n        print(\"a의 값이 {} 증가합니다.\".format(jump_size))\n    def show(self):\n        print('a={}'.format(self.a))\n    def reset(self):\n        self.a = 0\n        print(\"a의 값이 0으로 초기화 되었습니다.\")\n\n\nupjump = UpJump()\n\na의 값이 0으로 초기화 되었습니다.\n\n\n\nupjump?\n\n\nType:        UpJump\nString form: &lt;__main__.UpJump object at 0x7f02a149f0a0&gt;\nDocstring:   &lt;no docstring&gt;\n\n\n\n\nupjump.up()\n\na의 값이 1 증가합니다.\n\n\n\nupjump.jump(-2)\n\na의 값이 -2 증가합니다.\n\n\n\nupjump.show()\n\na=-1\n\n\n\nupjump.reset()\n\na의 값이 0으로 초기화 되었습니다.\n\n\n- 모티브: 생각해보니까 show와 print의 기능이 거의 비슷함 \\(\\to\\) print(upjump)를 하면 upjump.show()와 동일한 효과를 내도록 만들수 있을까?\n- 말도 안되는 소리 같음. 왜?\n\n이유1: print는 파이썬 내장기능이다. 내장기능을 우리가 마음대로 커스터마이징해서 쓰기는 어려울 것 같다.\n이유2: 이유1이 해결된다고 쳐도 문제이다. 그럼 지금까지 우리가 써왔던 수많은 print()의 결과는 어떻게 되는가?\n\n- 그런데 upjump의 자료형(UpJump자료형)에 해당하는 오브젝트들에 한정하여 print를 수정하는 방법이 가능하다면? (그럼 다른 오브젝트들은 수정된 print에 영향을 받지 않음)\n\n\n관찰1\n- 현재 print(upjump)의 결과는 아래와 같다.\n\nprint(upjump)\n\n&lt;__main__.UpJump object at 0x7f02a149f0a0&gt;\n\n\n\nupjump는 UpJump 클래스에서 만들어진 인스턴스이며, upjump가 저장된 메모리주소는 0x7f02a149f0a0 라는 의미\n\n\n\n관찰2\n- upjump 에는 __str__()이라는 숨겨진 메소드가 있다.\n\n결국 print(upjump) 는 print(upjump.__str__()) 와 같은 역할\n\n\n\n해킹?\n- upjump.__str__()의 기능을 재정의하면 print(upjump)의 결과도 바뀌지 않을까??\n예비학습: 함수 덮어씌우기 (재정의하기)\n\ndef f():\n    print('asdf')\n\n\nf()\n\nasdf\n\n\n\ndef f():\n    print('guebin hahaha')\n\n\nf()\n\nguebin hahaha\n\n\n이런식으로 함수가 이미 정의되어 있더라도, 내가 나중에 덮어씌우면 그 함수의 기능을 다시 정의한다.\n예비학습 끝\n- 이제 .__str__()의 기능을 재정의 하여 보자.\n\nclass UpJump:\n    def __init__(self):\n        self.reset()\n    def up(self):\n        self.a = self.a + 1  \n        print(\"a의 값이 1 증가합니다.\")\n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n        print(\"a의 값이 {} 증가합니다.\".format(jump_size))\n    def __str__(self):\n        return 'a={}'.format(self.a)\n    def reset(self):\n        self.a = 0\n        print(\"a의 값이 0으로 초기화 되었습니다.\")\n\n\nupjump = UpJump()\n\na의 값이 0으로 초기화 되었습니다.\n\n\n\nupjump.__str__()\n\n'a=0'\n\n\n\nprint(upjump.__str__())\n\na=0\n\n\n\nprint(upjump) ## 성공!\n\na=0\n\n\n\n\n지금까지의 print 다시 확인\n- 예시1\n\na=[1,2,3]\nprint(a)\n\n[1, 2, 3]\n\n\n\na.__str__()\n\n'[1, 2, 3]'\n\n\n\nprint(a.__str__())\n\n[1, 2, 3]\n\n\n- 예시2\n\na={1,2,3}\nprint(a)\n\n{1, 2, 3}\n\n\n\na.__str__()\n\n'{1, 2, 3}'\n\n\n\nprint(a.__str__())\n\n{1, 2, 3}\n\n\n- 예시3\n\na= np.arange(4).reshape(2,2)\nprint(a)\n\n[[0 1]\n [2 3]]\n\n\n\na.__str__()\n\n'[[0 1]\\n [2 3]]'\n\n\n\nprint(a.__str__())\n\n[[0 1]\n [2 3]]\n\n\n\n파이썬의 비밀3: print(a)는 사실 print(a.__str__()) 의 축약버전이었다.\n\n직관: 클래스에서 정의된 숨겨진 메소드 __????__ 들이 사실 파이썬의 비밀 덩어리였음!!!"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀4-__repr__",
    "href": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀4-__repr__",
    "title": "13wk-2: 클래스공부 4단계 – 파이썬의 비밀 (1)",
    "section": "비밀4: __repr__",
    "text": "비밀4: __repr__\n\nmotive\n\nrepr은 representation의 약자이다.\n\n- 모티브: 생각해보니까 print를 해서 우리가 원하는 정보를 확인하는건 아니었음\n\na=[1,2,3]\n\n\na\n\n[1, 2, 3]\n\n\n\nprint(a)\n\n[1, 2, 3]\n\n\n- 의문: a + 엔터는 print(a) + 엔터와 같은 효과인가?\n- 반례\n\na= np.arange(4).reshape(2,2)\na\n\narray([[0, 1],\n       [2, 3]])\n\n\n\nprint(a)\n\n[[0 1]\n [2 3]]\n\n\n\n\n__repr__ 의 역할\n- a + 엔터와 print(a) + 엔터가 다른 경우도 있다. \\(\\to\\) 추측: 서로 다른 숨겨진 기능이 있다! \\(\\to\\) 결론: 추측이 맞다. 그 기능은 __repr__에 저장되어있음.\n\na.__str__()\n\n'[[0 1]\\n [2 3]]'\n\n\n\na.__repr__() # 이렇게 조잡하다고? ㅋㅋㅋ\n\n'array([[0, 1],\\n       [2, 3]])'\n\n\n\nprint(a.__str__()) # print(a) + 엔터와 같은 효과\n\n[[0 1]\n [2 3]]\n\n\n\nprint(a.__repr__()) # a + 엔터와 같은 효과\n\narray([[0, 1],\n       [2, 3]])\n\n\n\n\n연습\n\nclass UpJump:\n    def __init__(self):\n        self.reset()\n    def up(self):\n        self.a = self.a + 1  \n        print(\"a의 값이 1 증가합니다.\")\n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n        print(\"a의 값이 {} 증가합니다.\".format(jump_size))\n    def __str__(self):\n        return 'a의 값은 {}입니다.'.format(self.a)\n    def reset(self):\n        self.a = 0\n        print(\"a의 값이 0으로 초기화 되었습니다.\")\n    def __repr__(self):\n        return 'a={}'.format(self.a)\n    \n\n\nupjump = UpJump()\n\na의 값이 0으로 초기화 되었습니다.\n\n\n\nprint(upjump)\n\na의 값은 0입니다.\n\n\n\nupjump\n\na=0\n\n\n\n\n__repr__() \\(\\Rightarrow\\) __str__()\n- 만약에 __repr__() 만 정의되었고 __str__()이 정의되지 않았다면 __repr__()의 내용이 __str__()의 내용을 대신한다. (하지만 역은 성립하지 않음)\n\nclass UpJump:\n    def __init__(self):\n        self.reset()\n    def up(self):\n        self.a = self.a + 1  \n        print(\"a의 값이 1 증가합니다.\")\n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n        print(\"a의 값이 {} 증가합니다.\".format(jump_size))\n    # def __str__(self):\n    #     return 'a의 값은 {}입니다.'.format(self.a)\n    def reset(self):\n        self.a = 0\n        print(\"a의 값이 0으로 초기화 되었습니다.\")\n    def __repr__(self):\n        return 'a={}'.format(self.a)\n    \n\n\nupjump = UpJump()\n\na의 값이 0으로 초기화 되었습니다.\n\n\n\nprint(upjump)\n\na=0\n\n\n\nupjump\n\na=0\n\n\n- 역은 성립안함! 즉 __str__() 만 정의되었고 __repr__()이 정의되지 않은경우에는 __str__()의 내용이 __repr__()의 내용을 대신할 수 없다.\n\nclass UpJump:\n    def __init__(self):\n        self.reset()\n    def up(self):\n        self.a = self.a + 1  \n        print(\"a의 값이 1 증가합니다.\")\n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n        print(\"a의 값이 {} 증가합니다.\".format(jump_size))\n    def __str__(self):\n        return 'a의 값은 {}입니다.'.format(self.a)\n    def reset(self):\n        self.a = 0\n        print(\"a의 값이 0으로 초기화 되었습니다.\")\n    # def __repr__(self):\n    #     return 'a={}'.format(self.a)    \n\n\nupjump = UpJump()\n\na의 값이 0으로 초기화 되었습니다.\n\n\n\nprint(upjump)\n\na의 값은 0입니다.\n\n\n\nupjump\n\n&lt;__main__.UpJump at 0x7f028f6b18b0&gt;\n\n\n\n파이썬의 비밀4: 대화형콘솔에서 a+엔터하여 나오는 출력결과는 print(a.__repr__()) 이라고 생각할 수 있다. (생각할수 있다? 아닐 수도 있다는 거야?)"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀5-_repr_html_",
    "href": "PP2023/posts/03_Class/2023-05-31-13wk-2.html#비밀5-_repr_html_",
    "title": "13wk-2: 클래스공부 4단계 – 파이썬의 비밀 (1)",
    "section": "비밀5: _repr_html_",
    "text": "비밀5: _repr_html_\n\nmotive\n- 모티브: 요즘에는 IDE의 발전에 따라서 오브젝트이름 + 엔터 를 입력할때 나오는 출력의 형태도 다양해지고 있음.\n\ndf = pd.DataFrame({'a':[1,2,3],'b':[2,3,4]})\ndf\n\n\n\n\n\n\n\n\na\nb\n\n\n\n\n0\n1\n2\n\n\n1\n2\n3\n\n\n2\n3\n4\n\n\n\n\n\n\n\n\n예쁘게 나온다… 이건 근데 문자열따위로 구현할 수 있는 출력 기능이 아닌것 같은데?\n\n\nprint(df.__repr__())\n\n   a  b\n0  1  2\n1  2  3\n2  3  4\n\n\n\nprint(df.__str__())\n\n   a  b\n0  1  2\n1  2  3\n2  3  4\n\n\n\n\n_repr_html_ 의 역할\n\ndf._repr_html_()\n\n'&lt;div&gt;\\n&lt;style scoped&gt;\\n    .dataframe tbody tr th:only-of-type {\\n        vertical-align: middle;\\n    }\\n\\n    .dataframe tbody tr th {\\n        vertical-align: top;\\n    }\\n\\n    .dataframe thead th {\\n        text-align: right;\\n    }\\n&lt;/style&gt;\\n&lt;table border=\"1\" class=\"dataframe\"&gt;\\n  &lt;thead&gt;\\n    &lt;tr style=\"text-align: right;\"&gt;\\n      &lt;th&gt;&lt;/th&gt;\\n      &lt;th&gt;a&lt;/th&gt;\\n      &lt;th&gt;b&lt;/th&gt;\\n    &lt;/tr&gt;\\n  &lt;/thead&gt;\\n  &lt;tbody&gt;\\n    &lt;tr&gt;\\n      &lt;th&gt;0&lt;/th&gt;\\n      &lt;td&gt;1&lt;/td&gt;\\n      &lt;td&gt;2&lt;/td&gt;\\n    &lt;/tr&gt;\\n    &lt;tr&gt;\\n      &lt;th&gt;1&lt;/th&gt;\\n      &lt;td&gt;2&lt;/td&gt;\\n      &lt;td&gt;3&lt;/td&gt;\\n    &lt;/tr&gt;\\n    &lt;tr&gt;\\n      &lt;th&gt;2&lt;/th&gt;\\n      &lt;td&gt;3&lt;/td&gt;\\n      &lt;td&gt;4&lt;/td&gt;\\n    &lt;/tr&gt;\\n  &lt;/tbody&gt;\\n&lt;/table&gt;\\n&lt;/div&gt;'\n\n\n\nHTML(df._repr_html_())\n\n\n\n\n\n\n\n\na\nb\n\n\n\n\n0\n1\n2\n\n\n1\n2\n3\n\n\n2\n3\n4\n\n\n\n\n\n\n\n참고: 그럼 df.__repr__()의 역할은 뭐야?\n\n대화형콘솔중 HTML 출력을 지원하면 오브젝트이름+엔터는 HTML(df._repr_html_()) 의 효과\n대화형콘솔중 HTML 출력을 지원하지 않으면 오브젝트이름+엔터는 print(df.__str__()) 의 효과\n\n\n\n\n그림1: HTML을 지원하는 않는 대화형 콘솔에서의 df출력예시\n\n\n\n\n_repr_html_() // __repr__() \\(\\Rightarrow\\) __str__()\n\nclass UpJump:\n    def __init__(self):\n        self.reset()\n    def up(self):\n        self.a = self.a + 1  \n        print(\"a의 값이 1 증가합니다.\")\n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n        print(\"a의 값이 {} 증가합니다.\".format(jump_size))\n    # def __str__(self):\n    #     return 'a의 값은 {}입니다.'.format(self.a)\n    def reset(self):\n        self.a = 0\n        print(\"a의 값이 0으로 초기화 되었습니다.\")\n    # def __repr__(self):\n    #     return 'a={}'.format(self.a)    \n    def _repr_html_(self):\n        return 'a={}'.format(self.a)            \n\n\nupjump = UpJump()\n\na의 값이 0으로 초기화 되었습니다.\n\n\n\nupjump\n\na=0\n\n\n\nprint(upjump)\n\n&lt;__main__.UpJump object at 0x7f027d189d90&gt;\n\n\n\n꿀팁: __repr__() 과 __str__() 을 재정의하지 않고 _repr_html_만을 재정의하여 출력결과를 바꿀 수 있다.\n\n\n\n연습\n\nclass JungKKuckMa:\n    def __init__(self):\n        self.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\n        self.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\n        self.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\n        self.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\n        self.highlight = '마음'\n        self.html_str =\\\n        '''\n        &lt;style&gt;\n            .title {{\n                font-family: \"Times New Roman\", serif;\n                font-size: 30px;\n                font-weight: 900;\n            }}\n            .text {{\n                font-family: \"Arial\", sans-serif;\n                font-size: 20px;\n                font-style: italic;\n            }}\n            .highlight {{\n                font-family: \"Montserrat\", monospace;\n                font-size: 35px;\n                font-weight: 900;\n                text-decoration: underline;\n                font-style: normal;\n                color: darkblue;\n                background-color: #FFFF00;\n            }}\n        &lt;/style&gt;\n        &lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n        &lt;img src={url} width=\"600\"&gt;\n        &lt;p&gt; \\n &lt;/p&gt;\n        &lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n        &lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n        &lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n        '''    \n    def _repr_html_(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        return _str\n\n\na = JungKKuckMa()\n\n\na\n\n\n        \n        파이썬 프로그래밍 중간고사 패배는 괜찮다.\n        \n         \n \n        Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n        A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n        중요한 것은 꺾이지 않는 마음\n        \n\n\n\n파이썬의 비밀5: 대화형콘솔에서 a+엔터하여 나오는 출력결과는 print(a.__repr__()) 혹은 HTML(a._repr_html_()) 이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#모티브",
    "href": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#모티브",
    "title": "12wk-1: 클래스공부 2단계 – __init__",
    "section": "모티브",
    "text": "모티브\n- 모티브: 태어날때마다 변수들 (pp2023.title, pp2023.ans, …) 을 선언하는게 귀찮다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#트릭1",
    "href": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#트릭1",
    "title": "12wk-1: 클래스공부 2단계 – __init__",
    "section": "트릭1",
    "text": "트릭1\n- 아래의 코드까지는 동일\n\nclass JungKKuckMa:\n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str)) \n\n\npp2023 = JungKKuckMa()\n\n(참고) 이 시점에서 pp2023. + tab을 누르면 show 가 자동완성 된다.\n- init을 선언하자.\n\ndef init(pp2023):\n    pp2023.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\n    pp2023.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\n    pp2023.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\n    pp2023.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\n    pp2023.highlight = '마음'\n    pp2023.html_str =\\\n    '''\n    &lt;style&gt;\n        .title {{\n            font-family: \"Times New Roman\", serif;\n            font-size: 30px;\n            font-weight: 900;\n        }}\n        .text {{\n            font-family: \"Arial\", sans-serif;\n            font-size: 20px;\n            font-style: italic;\n        }}\n        .highlight {{\n            font-family: \"Montserrat\", monospace;\n            font-size: 35px;\n            font-weight: 900;\n            text-decoration: underline;\n            font-style: normal;\n            color: darkblue;\n            background-color: #FFFF00;\n        }}\n    &lt;/style&gt;\n    &lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n    &lt;img src={url} width=\"600\"&gt;\n    &lt;p&gt; \\n &lt;/p&gt;\n    &lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n    &lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n    &lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n    '''\n\n현재 변수,함수,클래스의 상황은 아래와 같다. (참고로 변수,함수,클래스를 모두 뭉뚱그려서 오브젝트라고 표현할 수도 있음)\n- JungKKuckMa \n- pp2023 \n    - pp2023.show\n- init \n- init을 실행\n\ninit(pp2023)\n\n*(참고) 이제 pp2023. + tab 을 누르게 되면 아래와 같이 보인다.\n\n현재 오브젝트들의 상황은 아래와 같다.\n- JungKKuckMa \n- pp2023 \n    - pp2023.show\n    - pp2023.ans\n    - pp2023.highlight\n    - pp2023.html_str\n    - pp2023.imgurl\n    - pp2023.ques \n    - pp2023.title\n- init \n\npp2023.show()\n\n\n    \n    파이썬 프로그래밍 중간고사 패배는 괜찮다.\n    \n     \n \n    Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n    A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n    중요한 것은 꺾이지 않는 마음"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#트릭2",
    "href": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#트릭2",
    "title": "12wk-1: 클래스공부 2단계 – __init__",
    "section": "트릭2",
    "text": "트릭2\n- 외부에 선언된 init을 클래스 내부로 넣어서 선언. (외부에 선언된 함수를 클래스 내부의 메소드로 선언)\n\nclass JungKKuckMa:\n    def init(self):\n        self.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\n        self.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\n        self.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\n        self.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\n        self.highlight = '마음'\n        self.html_str =\\\n        '''\n        &lt;style&gt;\n            .title {{\n                font-family: \"Times New Roman\", serif;\n                font-size: 30px;\n                font-weight: 900;\n            }}\n            .text {{\n                font-family: \"Arial\", sans-serif;\n                font-size: 20px;\n                font-style: italic;\n            }}\n            .highlight {{\n                font-family: \"Montserrat\", monospace;\n                font-size: 35px;\n                font-weight: 900;\n                text-decoration: underline;\n                font-style: normal;\n                color: darkblue;\n                background-color: #FFFF00;\n            }}\n        &lt;/style&gt;\n        &lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n        &lt;img src={url} width=\"600\"&gt;\n        &lt;p&gt; \\n &lt;/p&gt;\n        &lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n        &lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n        &lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n        '''    \n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str)) \n\n- 클래스로 부터 인스턴스 생성\n\npp2023 = JungKKuckMa()\n\n(참고) 이 시점에서 pp2023. + tab 을 입력하면 아래와 같이 보인다.\n\n- init 실행\n\npp2023.init()\n\n(참고) 이 시점에서 pp2023. + tab 을 입력하면 아래와 같이 보인다.\n\n- show 실행\n\npp2023.show()\n\n\n        \n        파이썬 프로그래밍 중간고사 패배는 괜찮다.\n        \n         \n \n        Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n        A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n        중요한 것은 꺾이지 않는 마음"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#트릭2의-사용",
    "href": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#트릭2의-사용",
    "title": "12wk-1: 클래스공부 2단계 – __init__",
    "section": "트릭2의 사용",
    "text": "트릭2의 사용\n\nt=1 – 밈1: 파이썬 프로그래밍 중간고사\n\npp2023 = JungKKuckMa()\n\n(참고) 이 시점에서 pp2023. + tab 을 누르면?\n\n\npp2023.init()\n\n(참고) 이 시점에서 pp2023. + tab을 누르면?\n\n\npp2023.show()\n\n\n        \n        파이썬 프로그래밍 중간고사 패배는 괜찮다.\n        \n         \n \n        Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n        A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n        중요한 것은 꺾이지 않는 마음\n        \n\n\n\n\nt=2 – 밈2: 버거킹\n\nburger = JungKKuckMa() \nburger.init()\n\n\nburger.title = '버거 2개를 골라도 6000원!' \nburger.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/burgerking.png?raw=true'\nburger.ques = '기간: 11월28일(월)~12.4(일)'\nburger.ans = '콰트로치즈 와퍼 주니어, 통새우 와퍼 주니어, 롱치킨 버거 최대 42% 할인!'\nburger.highlight = '할인'\n\n\nburger.show()\n\n\n        \n        버거 2개를 골라도 6000원!\n        \n         \n \n        기간: 11월28일(월)~12.4(일)\n        콰트로치즈 와퍼 주니어, 통새우 와퍼 주니어, 롱치킨 버거 최대 42% 할인!\n        중요한 것은 꺾이지 않는 할인\n        \n\n\n\n\nt=3 – 밈1변경: 중요한 것은 꺾이지 않는 “집중력”\n\npp2023.highlight = '집중력' \n\n\npp2023.show()\n\n\n        \n        파이썬 프로그래밍 중간고사 패배는 괜찮다.\n        \n         \n \n        Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n        A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n        중요한 것은 꺾이지 않는 집중력\n        \n\n\n\n\nt=4 – 밈2변경: 버거 종류 수정 + 할인뒤에 느낌표 2개 추가\n\nburger.ans = '기네스콰트로치즈와퍼, 기네스와퍼, 몬스터와퍼, 몬스터X 최대 ??% 할인!'\nburger.highlight = '할인!!'\n\n\nburger.show()\n\n\n        \n        버거 2개를 골라도 6000원!\n        \n         \n \n        기간: 11월28일(월)~12.4(일)\n        기네스콰트로치즈와퍼, 기네스와퍼, 몬스터와퍼, 몬스터X 최대 ??% 할인!\n        중요한 것은 꺾이지 않는 할인!!"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#init__",
    "href": "PP2023/posts/03_Class/2023-05-22-12wk-1.html#init__",
    "title": "12wk-1: 클래스공부 2단계 – __init__",
    "section": "__init__()",
    "text": "__init__()\n- 모티브: 생각해보니까 트릭2는 (1) 인스턴스를 만든 뒤 (2) pp2023.init() 를 수행하는 것이 고정임!\n세트실행의 예시\nburger = JungKKuckMa() \nburger.init()\n- 하고 싶은 것: 인스턴스를 만드는 시점에서 자동으로 init()이 실행되도록 하고 싶다.\n\nclass JungKKuckMa:\n    def __init__(self):\n        self.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\n        self.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\n        self.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\n        self.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\n        self.highlight = '마음'\n        self.html_str =\\\n        '''\n        &lt;style&gt;\n            .title {{\n                font-family: \"Times New Roman\", serif;\n                font-size: 30px;\n                font-weight: 900;\n            }}\n            .text {{\n                font-family: \"Arial\", sans-serif;\n                font-size: 20px;\n                font-style: italic;\n            }}\n            .highlight {{\n                font-family: \"Montserrat\", monospace;\n                font-size: 35px;\n                font-weight: 900;\n                text-decoration: underline;\n                font-style: normal;\n                color: darkblue;\n                background-color: #FFFF00;\n            }}\n        &lt;/style&gt;\n        &lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n        &lt;img src={url} width=\"600\"&gt;\n        &lt;p&gt; \\n &lt;/p&gt;\n        &lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n        &lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n        &lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n        '''    \n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str)) \n\n- 사용예시\n\npp2023 = JungKKuckMa()\n\n(참고) 이 시점에서 pp2023. + tab을 하면? 예상: __init__과 show가 보일것이다?\n\n실제로는 위와 같이 보임\n\n변수들이 미리 선언되어 있음.\n함수 __init__ 은 안보임 (숨어있음)\n\n(참고) 숨은 __init__을 강제소환\n\npp2023.__init__??\n\n\nSignature: pp2023.__init__()\nDocstring: Initialize self.  See help(type(self)) for accurate signature.\nSource:   \n    def __init__(self):\n        self.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\n        self.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\n        self.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\n        self.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\n        self.highlight = '마음'\n        self.html_str =\\\n        '''\n        &lt;style&gt;\n            .title {{\n                font-family: \"Times New Roman\", serif;\n                font-size: 30px;\n                font-weight: 900;\n            }}\n            .text {{\n                font-family: \"Arial\", sans-serif;\n                font-size: 20px;\n                font-style: italic;\n            }}\n            .highlight {{\n                font-family: \"Montserrat\", monospace;\n                font-size: 35px;\n                font-weight: 900;\n                text-decoration: underline;\n                font-style: normal;\n                color: darkblue;\n                background-color: #FFFF00;\n            }}\n        &lt;/style&gt;\n        &lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n        &lt;img src={url} width=\"600\"&gt;\n        &lt;p&gt; \\n &lt;/p&gt;\n        &lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n        &lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n        &lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n        '''\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-36-ca7605a04b40&gt;\nType:      method\n\n\n\n\n# pp2023.init() # 아까는 이게 필요했는데 이제 필요없다.\npp2023.show()\n\n\n        \n        파이썬 프로그래밍 중간고사 패배는 괜찮다.\n        \n         \n \n        Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n        A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n        중요한 것은 꺾이지 않는 마음"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#코드줄바꿈",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#코드줄바꿈",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "코드줄바꿈",
    "text": "코드줄바꿈\n\\: 코드가 길때 줄을 바꾸는 기능\n- 예시1\n\na\\\n=55\n\n\na\n\n55\n\n\n\na=\\\n33\n\n\na\n\n33\n\n\n- 예시2\n\na=0.5 \na\n\n0.5\n\n\n\\(a+a^2+a^3+a^4+a^5\\) 를 계산하고 싶다면?\n(방법1)\n\na + a**2 + a**3 + a**4 + a**5 \n\n0.96875\n\n\n(방법2)\n\na +\\\na**2 +\\\na**3 +\\\na**4 +\\\na**5 \n\n0.96875"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#으로-선언하는-문자열",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#으로-선언하는-문자열",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "'''으로 선언하는 문자열",
    "text": "'''으로 선언하는 문자열\n- 예시1\n\nstring = '\\n1. asdf\\n2. sdfa\\n3. dfas\\n4. fasd\\n'\nprint(string)\n\n\n1. asdf\n2. sdfa\n3. dfas\n4. fasd\n\n\n\n\nstring = \\\n'''\n1. asdf\n2. sdfa\n3. dfas\n4. fasd\n'''\nprint(string)\n\n\n1. asdf\n2. sdfa\n3. dfas\n4. fasd\n\n\n\n- 예시2\n\nstring = \\\n'''\n1. asdf\n2. sdfa\n3. dfas\n4. fasd\n5. {}\n6. {}\n'''\n\n\nprint(string.format('aaaa','bbbb'))\n\n\n1. asdf\n2. sdfa\n3. dfas\n4. fasd\n5. aaaa\n6. bbbb"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#문자열-포맷팅",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#문자열-포맷팅",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "문자열 포맷팅",
    "text": "문자열 포맷팅\n- 예시1\n\nstring = \\\n'''\n1. 이름: {}\n2. 소속: {}\n'''\n\n\nprint(string.format('최규빈','통계학과'))\n\n\n1. 이름: 최규빈\n2. 소속: 통계학과\n\n\n\n\nprint(string.format('통계학과','최규빈'))\n\n\n1. 이름: 통계학과\n2. 소속: 최규빈\n\n\n\n- 예시2\n\nstring = \\\n'''\n1. 이름: {name}\n2. 소속: {affiliation}\n'''\n\n\nprint(string.format(name='최규빈', affiliation='통계학과'))\n\n\n1. 이름: 최규빈\n2. 소속: 통계학과\n\n\n\n\nprint(string.format(affiliation='통계학과',name='최규빈'))\n\n\n1. 이름: 최규빈\n2. 소속: 통계학과"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#html",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#html",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "HTML",
    "text": "HTML\n- 예제1: 텍스트 출력\n\nhtml_str = '''\n&lt;p&gt; 파이썬 프로그래밍 2023 &lt;/p&gt;\n'''\n\n\nHTML(html_str)\n\n\n 파이썬 프로그래밍 2023 \n\n\n- 예제2: 텍스트의 스타일변경\n\nhtml_str = '''\n&lt;style&gt;\n    .title {\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }\n&lt;/style&gt;\n&lt;p class=\"title\"&gt;파이썬 프로그래밍 2023&lt;/p&gt;\n'''\n\n\nHTML(html_str)\n\n\n\n파이썬 프로그래밍 2023\n\n\n- 예제3: 이미지의 삽입\n\nhtml_str = '''\n&lt;img src = https://github.com/guebin/PP2023/blob/main/posts/03_Class/JungGGuckMa.jpg?raw=true&gt;\n'''\nHTML(html_str)\n\n\n\n\n\n- 예제4: 텍스트 + 이미지\n\nhtml_str = '''\n&lt;p&gt; 로그전 패배는 괜찮아 &lt;/p&gt;\n&lt;img src = https://github.com/guebin/PP2023/blob/main/posts/03_Class/JungGGuckMa.jpg?raw=true&gt;\n&lt;p&gt; 중요한 건 꺾이지 않는 마음 &lt;/p&gt;\n'''\nHTML(html_str)\n\n\n 로그전 패배는 괜찮아 \n\n 중요한 건 꺾이지 않는 마음"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#display",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#display",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "display",
    "text": "display\n- 아래는 HTML(html_str)의 내용을 명시적으로 display 하는 코드이다.\n\ndisplay(HTML(html_str))\n\n\n 로그전 패배는 괜찮아 \n\n 중요한 건 꺾이지 않는 마음 \n\n\n- 이것은 마치 아래와 유사함.\n\na=1\n\n\na\n\n1\n\n\n\nprint(a)\n\n1"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#구현",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#구현",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "구현",
    "text": "구현\n- 기사처럼 보이도록 html_str 을 선언\n\nhtml_str = '''\n&lt;style&gt;\n    .title {\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }\n    .text {\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }\n    .highlight {\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }\n&lt;/style&gt;\n\n&lt;p class=\"title\"&gt;RGE전 패배는 괜찮다.&lt;/p&gt;\n&lt;img src=https://github.com/guebin/PP2023/blob/main/posts/03_Class/JungGGuckMa.jpg?raw=true width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt; Q: 로그와 2라운드 재대결, 어떤 점에 유의해야 할까?&lt;/p&gt;\n&lt;p class=\"text\"&gt; A: 상대팀에 대해서 더 분석할 건 없는 것 같고, 저희가 저희 플레이 잘하는 게 제일 중요한 것 같고 오늘 지긴 했지만 저희끼리만 안 무너지면 충분히 이길 수 있을 것 같아요.\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;마음&lt;/span&gt;&lt;/p&gt;\n'''\n\n\ndisplay(HTML(html_str))\n\n\n\n\nRGE전 패배는 괜찮다.\n\n \n \n Q: 로그와 2라운드 재대결, 어떤 점에 유의해야 할까?\n A: 상대팀에 대해서 더 분석할 건 없는 것 같고, 저희가 저희 플레이 잘하는 게 제일 중요한 것 같고 오늘 지긴 했지만 저희끼리만 안 무너지면 충분히 이길 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 마음"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-밈의-구상",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-밈의-구상",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "1단계: 밈의 구상",
    "text": "1단계: 밈의 구상\n- 파이썬 프로그래밍 2023 중간고사.\n\nhttps://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true\n\n\nhtml_str = '''\n&lt;style&gt;\n    .title {\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }\n    .text {\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }\n    .highlight {\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }\n&lt;/style&gt;\n\n&lt;p class=\"title\"&gt;파이썬 프로그래밍 중간고사 패배는 괜찮다.&lt;/p&gt;\n&lt;img src=https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt; Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?&lt;/p&gt;\n&lt;p class=\"text\"&gt; A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;마음&lt;/span&gt;&lt;/p&gt;\n'''\n\n\ndisplay(HTML(html_str))\n\n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다.\n\n \n \n Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 마음\n\n\n- 이거 왠지 재미있는데?\n- 밈의 속성을 추려보자.\n\ntitle: 타이틀에 해당하는 텍스트\nimg: DEFT의 인터뷰 이미지\nQ: 인터뷰질문에 해당하는 텍스트\nA: 인터뷰답변에 해당하는 텍스트\n중꺽마에서의 “마음”"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-양식틀의-완성-함수이용",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-양식틀의-완성-함수이용",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "2단계: 양식틀의 완성 (함수이용)",
    "text": "2단계: 양식틀의 완성 (함수이용)\n\nhtml_str = '''\n&lt;style&gt;\n    .title {{\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }}\n    .text {{\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }}\n    .highlight {{\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }}\n&lt;/style&gt;\n\n&lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n&lt;img src={url} width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt; {Q}&lt;/p&gt;\n&lt;p class=\"text\"&gt; {A}&lt;/p&gt;\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n'''\n\n\ntitle = '파이썬 프로그래밍 중간고사 패배는 괜찮다!!!'\nimgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true'\nques = 'Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?'\nans = 'A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.'\nhighlight = '마음'\n\n\n_str = html_str.format(\n    ttl = title,\n    url = imgurl,\n    Q = ques,\n    A = ans,\n    hl = highlight\n)\ndisplay(HTML(_str))\n\n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다!!!\n\n \n \n Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 마음\n\n\n- 함수의 선언\n\ndef show_JungGGuckMa(html_str,title,imgurl,ques,ans,highlight):\n    _str = html_str.format(\n        ttl = title,\n        url = imgurl,\n        Q = ques,\n        A = ans,\n        hl = highlight\n    )\n    display(HTML(_str))\n\n\nshow_JungGGuckMa(html_str,title,imgurl,ques,ans,highlight)\n\n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다!!!\n\n \n \n Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 마음"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-밈놀이-함수",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-밈놀이-함수",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "3단계: 밈놀이 (함수)",
    "text": "3단계: 밈놀이 (함수)\n\nt=1 – 밈1: 파이썬 프로그래밍 중간고사\n\n# 필요한 변수들 선언\n# show_JungGGuckMa 함수 선언 \n# 사용\nshow_JungGGuckMa(html_str,title,imgurl,ques,ans,highlight)\n\n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다!!!\n\n \n \n Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 마음\n\n\n\n\nt=2 – 밈2: 버거킹\nref: https://i2.ruliweb.com/ori/22/12/03/184d62f98aace2c4.png\n\ntitle = '버거 2개를 골라도 6000원'\nimgurl2 = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/burgerking.png?raw=true'\nques = '기간: 11월28일(월)-12월4일(일)'\nans = '콰트로치즈 와퍼 주니어, 통새우 와퍼 주니어, 롱치킨 버거 최대 42% 할인'\nhighlight = '할인'\n\n\nshow_JungGGuckMa(html_str,title,imgurl2,ques,ans,highlight)\n\n\n\n\n버거 2개를 골라도 6000원\n\n \n \n 기간: 11월28일(월)-12월4일(일)\n 콰트로치즈 와퍼 주니어, 통새우 와퍼 주니어, 롱치킨 버거 최대 42% 할인\n중요한 것은 꺾이지 않는 할인\n\n\n\n\nt=3 – 밈1변경: 중요한 것은 꺾이지 않는 “집중력”\n\ntitle = '파이썬 프로그래밍 중간고사 패배는 괜찮다!!!'\nimgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true'\nques = 'Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?'\nans = 'A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.'\nhighlight = '집중력'\n\n\nshow_JungGGuckMa(html_str,title,imgurl,ques,ans,highlight)\n\n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다!!!\n\n \n \n Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 집중력\n\n\n- 수정이 아니라 거의 새로 만든 수준인데?\n\n\nt=4 – 밈2변경: 버거 종류 수정\n- 귀찮아서…\n\n\n이러한 코드의 비판\n- 변수들이 정리가 되어있지 않고 산만함"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-밈놀이-클래스",
    "href": "PP2023/posts/03_Class/2023-05-15-11wk-1.html#단계-밈놀이-클래스",
    "title": "11wk-1: 밈과 클래스 (2)",
    "section": "3단계: 밈놀이 (클래스)",
    "text": "3단계: 밈놀이 (클래스)\n\nclass JungKKuckMa:\n    pass \n\n\nt=1 – 밈1: 파이썬 프로그래밍 중간고사\n\npp2023 = JungKKuckMa()\npp2023\n\n&lt;__main__.JungKKuckMa at 0x7f101ca06fd0&gt;\n\n\n(참고) 여기에서 pp2023.을 치고 tab을 눌러도 아무런 변화가 없음.\n\n\npp2023.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다!!!'\npp2023.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true'\npp2023.ques = 'Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?'\npp2023.ans = 'A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.'\npp2023.highlight = '마음'\npp2023.html_str =\\\n'''\n&lt;style&gt;\n    .title {{\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }}\n    .text {{\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }}\n    .highlight {{\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }}\n&lt;/style&gt;\n\n&lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n&lt;img src={url} width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt; {Q}&lt;/p&gt;\n&lt;p class=\"text\"&gt; {A}&lt;/p&gt;\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n'''\n\n(참고) 이 상태에서 pp2023. + tab 을 하면 아래와 같이 보인다.\n\n\n\nimage.png\n\n\n\ndef show(pp2023):\n    _str = pp2023.html_str.format(\n        ttl = pp2023.title,\n        url = pp2023.imgurl,\n        Q = pp2023.ques,\n        A = pp2023.ans,\n        hl = pp2023.highlight\n    )\n    display(HTML(_str))\n\n\nshow(pp2023)\n\n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다!!!\n\n \n \n Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 마음\n\n\n\n\nt=2 – 밈2: 버거킹\n\nburger = JungKKuckMa()\nburger\n\n&lt;__main__.JungKKuckMa at 0x7f101ca069d0&gt;\n\n\n(참고) 여기에서 burger.을 치고 tab을 눌러도 아무런 변화가 없음.\n\n\nburger.title = '버거 2개를 골라도 6000원'\nburger.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/burgerking.png?raw=true'\nburger.ques = '기간: 11월28일(월)-12월4일(일)'\nburger.ans = '콰트로치즈 와퍼 주니어, 통새우 와퍼 주니어, 롱치킨 버거 최대 42% 할인'\nburger.highlight = '할인'\nburger.html_str =\\\n'''\n&lt;style&gt;\n    .title {{\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }}\n    .text {{\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }}\n    .highlight {{\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }}\n&lt;/style&gt;\n\n&lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n&lt;img src={url} width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt; {Q}&lt;/p&gt;\n&lt;p class=\"text\"&gt; {A}&lt;/p&gt;\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n'''\n\n(참고) 이 순간은 burger. + tab 을 하면 아래와 같이 나온다.\n\n- show() 함수는 재사용가능하겠는데?\n\n# def show(pp2023):\n#     _str = pp2023.html_str.format(\n#         ttl = pp2023.title,\n#         url = pp2023.imgurl,\n#         Q = pp2023.ques,\n#         A = pp2023.ans,\n#         hl = pp2023.highlight\n#     )\n#     display(HTML(_str))\n\n\npp2023, burger 를 show 함수의 입력 x로 생각해도 무방\n\n\nshow(burger)\n\n\n\n\n버거 2개를 골라도 6000원\n\n \n \n 기간: 11월28일(월)-12월4일(일)\n 콰트로치즈 와퍼 주니어, 통새우 와퍼 주니어, 롱치킨 버거 최대 42% 할인\n중요한 것은 꺾이지 않는 할인\n\n\n\n\nt=3 – 밈1변경: 중요한 것은 꺾이지 않는 “집중력”\n\npp2023.highlight = '집중력'\n\n\nshow(pp2023)\n\n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다!!!\n\n \n \n Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\n A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 집중력\n\n\n\n\nt=4 – 밈2변경: 버거 종류 수정\n\nburger.ans = '기네스콰트로치즈와퍼, 기네스와퍼, 몬스터와퍼, 몬스터X 최대 XX% 할인' \n\n\nshow(burger)\n\n\n\n\n버거 2개를 골라도 6000원\n\n \n \n 기간: 11월28일(월)-12월4일(일)\n 기네스콰트로치즈와퍼, 기네스와퍼, 몬스터와퍼, 몬스터X 최대 XX% 할인\n중요한 것은 꺾이지 않는 할인\n\n\n\n\n코드의 복습 + 대응하는 용어의 정리\n- 코드조각1: 아래의 과정은 “JungKKuckMa라는 이름의 클래스를 선언한다.” 라고 표현한다.\n\nclass JungKKuckMa:\n    pass \n\n\n’JungKKuckMa.HWP’라는 빈 한글파일을 만들어 두는 과정이라 비유할 수 있다.\n\n- 코드조각2: 아래의 과정은 “JungKKuckMa라는 클래스에서 pp2023이라는 인스턴스를 생성시켰다.” 고 표현한다.\n\npp2023 = JungKKuckMa()\npp2023\n\n&lt;__main__.JungKKuckMa at 0x7f101ca06fa0&gt;\n\n\n\n만들어둔 ‘JungKKuckMa.HWP’를 Ctrl + C,V 하여 새로운 hwp파일을 만들고 파일이름을 ’pp2023.HWP’ 파일로 변경한 상황으로 비유하라 수 있다.\n느낌: ’JungKKuckMa.HWP’에서 ’pp2023.HWP’이 태어난 느낌!!\n\n- 코드조각3: 아래의 과정은 pp2023 안의 소속된 변수를 정의한다.\n\n여기에서 정의된 pp2023.title 등을 “pp2023의 attribute” 라고 표현한다.\n\n\npp2023.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다!!!'\npp2023.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true'\npp2023.ques = 'Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?'\npp2023.ans = 'A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 제가 제 코드를 잘 구현하는 게 제일 중요한 것 같고 오늘 중간고사는 망하긴 했지만 저 스스로가 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.'\npp2023.highlight = '마음'\npp2023.html_str =\\\n'''\n&lt;style&gt;\n    .title {{\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }}\n    .text {{\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }}\n    .highlight {{\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }}\n&lt;/style&gt;\n\n&lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n&lt;img src={url} width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt; {Q}&lt;/p&gt;\n&lt;p class=\"text\"&gt; {A}&lt;/p&gt;\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n'''\n\n\n‘pp2023.HWP’ 라는 문서안에 내용을 채우는 과정이라고 비유할 수 있다.\n\n- 코드조각4: 아래의 과정은 클래스에서 생성된 인스턴스를 입력으로 받아서 어떠한 동작을 수행할 함수를 정의\n\ndef show(pp2023):\n    _str = pp2023.html_str.format(\n        ttl = pp2023.title,\n        url = pp2023.imgurl,\n        Q = pp2023.ques,\n        A = pp2023.ans,\n        hl = pp2023.highlight\n    )\n    display(HTML(_str))\n\n\n특징: show의 입력은 너무 깔끔하다. 클래스에서 생성된 인스턴스의 이름을 받아서 여러변수를 한번에 정리하였음.\n\n- 코드조각5: 아래의 과정은 생성된 인스턴스를 입력으로 받아서 어떠한 함수를 수행하는 과정이다.\n\n# show(pp2023)\n# show(burger)\n\n\nshow 라는 버튼을 눌러서 ‘pp2023.HWP’ 혹은 ‘burger.HWP’ 를 보는 느낌\nshow 라는 버튼은 ‘pp2023.HWP’ 혹은 ‘burger.HWP’ 외부에서 독립적으로 선언된 함수임."
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-05-01-9wk-1.html",
    "href": "PP2023/posts/02_DataScience/2023-05-01-9wk-1.html",
    "title": "09wk-1: Numpy와 Pandas의 활용",
    "section": "",
    "text": "강의영상\n\nyoutube: https://youtube.com/playlist?list=PLQqh36zP38-w-stglh0uVkQxHpCT9lH9C\n\n\n\nimports\n\nimport numpy as np\nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport urllib.request\n\n\n\n회귀분석\n1--7.\n1. \\(x_i\\)가 아래와 같이 주어졌다고 가정하자.\n\nx =  np.array([0.00983, 0.01098, 0.02951, 0.0384 , 0.03973, 0.04178, 0.0533 ,\n               0.058  , 0.09454, 0.1103 , 0.1328 , 0.1412 , 0.1497 , 0.1664 ,\n               0.1906 , 0.1923 , 0.198  , 0.2141 , 0.2393 , 0.2433 , 0.3157 ,\n               0.3228 , 0.3418 , 0.3552 , 0.3918 , 0.3962 , 0.4    , 0.4482 ,\n               0.496  , 0.507  , 0.53   , 0.5654 , 0.582  , 0.5854 , 0.5854 ,\n               0.6606 , 0.7007 , 0.723  , 0.7305 , 0.7383 , 0.7656 , 0.7725 ,\n               0.831  , 0.8896 , 0.9053 , 0.914  , 0.949  , 0.952  , 0.9727 ,\n               0.982  ])\n\n아래의 수식에 따라 \\(y_i\\)를 생성하라.\n\n\\(y_i = 2+3x_i +\\epsilon_i,\\quad \\epsilon_i \\overset{iid}{\\sim} N(0,1)\\)\n\n\\((x_i,y_i)\\)를 산점도를 이용하여 시각화하라.\n(풀이)\n\ny = 2+3*x + np.random.randn(50) \n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f457a486790&gt;\n\n\n\n\n\n2. 1과 같은 자료를 잘 표현할 수 있는 적절한 추세선 \\((x_i, \\hat{y}_i)\\)를 그리기 위하여 아래의 수식을 고려하자.\n\n\\(\\hat{y}_i = ax_i+b\\)\n\na,b를 각각 아래의 표에 의하여 선택하였을 경우 추세선을 문제하단에 명시된 요구사항에 맞추어 시각화하라.\n\n\n\n\n\\(a\\)\n\\(b\\)\n\n\n\n\n(a)\n\\(1\\)\n\\(0\\)\n\n\n(b)\n\\(2.5\\)\n\\(2\\)\n\n\n(c)\n\\(3\\)\n\\(2\\)\n\n\n\n요구사항\n\n\\((x_i,y_i)\\)를 산점도로 그리고 각 (a),(b),(c)에 대한 \\((x_i,\\hat{y}_i)\\)를 lineplot으로 겹쳐그릴 것\n범례를 포함할 것\n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.plot(x,1*x+0,'--',label=r'(a) $(x_i,\\hat{y}_i)$')\nplt.plot(x,2.5*x+2,'--',label=r'(b) $(x_i,\\hat{y}_i)$')\nplt.plot(x,3*x+2,'--',label=r'(c) $(x_i,\\hat{y}_i)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f4579b17520&gt;\n\n\n\n\n\n3. 아래를 각각 계산하라.\n(a) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-x_i)^2\\)\n(b) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-2-2.5x_i)^2\\)\n(c) \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-2-3x_i)^2\\)\n가장 작은 값을 가지는 것은 무엇인가?\n(풀이)\n\nnp.mean((y-(1*x+0))**2), np.mean((y-(2.5*x+2))**2), np.mean((y-(3*x+2))**2)\n\n(9.310962556625569, 1.1267147296257563, 1.0907585903281032)\n\n\n가장 작은 값을 가지는 것은 (c)이다.\n4. 3의 결과를 근거로 (a)-(c)중 가장 적절한 추세선을 판단하고 적절한 순서대로 나열하라.\n(풀이)\n3-(a),(b),(c)는 각각\n\n\\(\\hat{y}_i=x_i\\)\n\\(\\hat{y}_i=2+2.5x_i\\)\n\\(\\hat{y}_i=2+3x_i\\)\n\n일 경우\n\\[{\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y}) = \\frac{1}{n}\\sum_{i=1}^{n}(y_i -\\hat{y}_i)^2\\]\n를 계산한 것이라 해석할 수 있다. 그런데 \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\)의 값은\n\n\\(y_1 \\approx \\hat{y}_1\\)\n\\(y_2 \\approx \\hat{y}_2\\)\n\\(\\dots\\)\n\\(y_n \\approx \\hat{y}_n\\)\n\n일수록 작은 값을 가진다. 그리고 위의 조건은 더 적절하게 추세선을 그렸을때 만족된다. 요약하면\n\n적절한 추세선을 그림 \\(\\Rightarrow\\) \\(y_i \\approx \\hat{y}_i\\) \\(\\Rightarrow\\) \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\) 값이 작아짐\n\n와 같은 관계가 있음을 파악할 수 있다. 따라서 \\({\\tt mse}({\\boldsymbol y}, \\hat{\\boldsymbol y})\\)의 값이 작을수록 적절한 추세선이라 생각할 수 있다.\n5. 아래와 같은 수식을 이용하여 \\(\\hat{\\beta}_0, \\hat{\\beta}_1\\) 을 계산하라.\n\\[\\begin{bmatrix} \\hat{\\beta}_0 \\\\ \\hat{\\beta}_1 \\end{bmatrix} = ({\\bf X}^T {\\bf X})^{-1}{\\bf X}^T {\\boldsymbol y}, \\quad {\\bf X}=\\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\dots \\\\ 1 & x_n \\end{bmatrix}\\]\n(풀이)\n\nX = np.stack([[1]*50 ,x],axis=1)\nnp.linalg.inv(X.T @ X)@X.T@y \n\narray([1.97914281, 2.90834079])\n\n\n\\(\\hat{\\beta}_0=1.97914281\\) 이고 \\(\\hat{\\beta}_1= 2.90834079\\) 이다.\n6. 5에서 계산된 \\(\\hat{\\beta}_0, \\hat{\\beta}_1\\)을 각각 \\(b=\\hat{\\beta}_0, a=\\hat{\\beta}_1\\)으로 생각하고 적절한 추세선 \\((x_i, \\hat{y}_i)\\)를 그려라. (단, \\(\\hat{y}_i=ax_i+b\\) 이다)\n(풀이)\n\nb, a = np.linalg.inv(X.T @ X)@X.T@y \nyhat = a*x +b \n\n\nplt.plot(x,y,'o',label=r'$(x_i,y_i)$')\nplt.plot(x,yhat,'--',label=r'$(x_i,\\hat{y}_i)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f4577dd45e0&gt;\n\n\n\n\n\n7. 4의 기준에 따르면, \\((a,b)=(3,2)\\) 일때 만들어지는 추세선과 \\((a,b)=(\\hat{\\beta}_1,\\hat{\\beta}_0)\\) 일때 만들어지는 추세선은 어떤 것이 더 적절한가?\n(풀이)\n\nnp.mean((y-(3*x+2))**2), np.mean((y-yhat)**2)\n\n(1.0907585903281032, 1.0862796480117118)\n\n\n\n\nMNIST data\n아래는 0~9가지의 숫자이미지가 저장된 이미지데이터를 불러오는 코드이다.\n\n# URL 설정\nurl = 'https://github.com/guebin/PP2023/raw/main/posts/02_PY4DS/mnist.npz'\n\n# URL에서 파일 다운로드\nurllib.request.urlretrieve(url, './mnist.npz')\n\n# 데이터 로드\ndata = np.load('./mnist.npz')\nxtrain, ytrain, xtest, ytest = data['x_train'], data['y_train'], data['x_test'], data['y_test']\n\n아래는 데이터에 대한 설명이다.\n\n전체의 이미지의 수는 70000개이며, 60000개의 이미지 \\({\\tt xtrain}\\)에 10000개의 이미지는 \\({\\tt xtest}\\)에 저장되어 있다.\n이미지에 대한 라벨은 각각 \\({\\tt ytrain}\\)과 \\(\\tt ytest\\)에 저장되어 있다. 따라서 \\(\\tt ytrain\\)에는 60000개의 이미지에 해당하는 라벨이, \\(\\tt ytest\\)에는 10000개의 이미지에 해당하는 라벨이 기록되어 있다.\n보통 분석에서는 60000개의 이미지를 가지고 라벨을 맞추는 “훈련”을 하고 (\\({\\tt xtrain}\\)을 이용하여 \\({\\tt ytrain}\\)을 맞추는 방법을 학습하고), 그러한 훈련이 잘 되었는지 10000개의 이미지를 이용하여 “테스트”한다.\n위와 같은 의미로 \\(({\\tt xtrain}, {\\tt ytrain})\\) 을 training data set, \\(({\\tt xtest},{\\tt ytest})\\) 를 test data set 이라고 부른다. (ref: 위키참고)\n\n아래는 이미지자료와 시각화에 대한 설명이다.\n\n각 이미지는 (28,28) 픽셀의 흑백이미지이다. 따라서 각 이미지는 (28,28,3) 이 아니라 (28,28) 의 shape을 가진 텐서로 구성되어있다.\n흑백이미지를 시각화 하기 위해서는 plt.imshow(img, cmap='gray')를 이용한다. 여기에서 \\({\\tt img}\\)은 임의의 2차원 텐서이며 이 예제의 경우 (28,28)의 shape을 가진다.\n\n아래는 \\({\\tt xtrain}\\)의 두번째 이미지, 즉 \\({\\tt xtrain[1,:,:]}\\)를 확인하는 코드의 예시이다.\n\n# plt.imshow(xtrain[1,:,:],cmap='gray')\nplt.imshow(xtrain[1],cmap='gray') ## 같은코드임\n\n&lt;matplotlib.image.AxesImage at 0x7f457418ca30&gt;\n\n\n\n\n\n이 이미지에 대한 label은 \\({\\tt ytrain[1]}\\)의 값으로 확인가능하다.\n\nytrain[1]\n\n0\n\n\n이미지와 라벨을 한번에 표현하는 코드는 아래와 같이 작성가능하다.\n\nplt.imshow(xtrain[1],cmap='gray')\nplt.title('label={}'.format(ytrain[1]));\n\n\n\n\n아래는 10개의 이미지를 라벨과 함께 출력하는 코드의 예시이다.\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(xtrain[0],cmap='gray'); ax[0][0].set_title('label={}'.format(ytrain[0]));\nax[0][1].imshow(xtrain[1],cmap='gray'); ax[0][1].set_title('label={}'.format(ytrain[1]));\nax[0][2].imshow(xtrain[2],cmap='gray'); ax[0][2].set_title('label={}'.format(ytrain[2]));\nax[0][3].imshow(xtrain[3],cmap='gray'); ax[0][3].set_title('label={}'.format(ytrain[3]));\nax[0][4].imshow(xtrain[4],cmap='gray'); ax[0][4].set_title('label={}'.format(ytrain[4]));\n\nax[1][0].imshow(xtrain[5],cmap='gray'); ax[1][0].set_title('label={}'.format(ytrain[5]));\nax[1][1].imshow(xtrain[6],cmap='gray'); ax[1][1].set_title('label={}'.format(ytrain[6]));\nax[1][2].imshow(xtrain[7],cmap='gray'); ax[1][2].set_title('label={}'.format(ytrain[7]));\nax[1][3].imshow(xtrain[8],cmap='gray'); ax[1][3].set_title('label={}'.format(ytrain[8]));\nax[1][4].imshow(xtrain[9],cmap='gray'); ax[1][4].set_title('label={}'.format(ytrain[9]));\n\nfig.tight_layout()\n\n\n\n\n(1) 70000개의 이미지중 0~9에 해당하는 이미지는 각각 몇장씩 들어있는가?\n(풀이)\n\n_y = ytrain.tolist()+ytest.tolist()\n\n\n{s:_y.count(s) for s in set(_y)}\n\n{0: 6903,\n 1: 7877,\n 2: 6990,\n 3: 7141,\n 4: 6824,\n 5: 6313,\n 6: 6876,\n 7: 7293,\n 8: 6825,\n 9: 6958}\n\n\n(2) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지만을 모아서 새로운 텐서 \\({\\tt xtrain0}\\)를 만들어라. 이 텐서에서 처음과 마지막 이미지를 출력하라.\nhint: \\({\\tt xtrain0}\\) 의 shape은 (5923,28,28)이어야 한다.\n(풀이)\n\nxtrain0 = xtrain[ytrain==0]\nxtrain0.shape\n\n(5923, 28, 28)\n\n\n\nplt.imshow(xtrain0[0],cmap='gray') # 처음이미지\n\n&lt;matplotlib.image.AxesImage at 0x7f4574142880&gt;\n\n\n\n\n\n\nplt.imshow(xtrain0[-1],cmap='gray') # 마지막이미지\n\n&lt;matplotlib.image.AxesImage at 0x7f45740b1bb0&gt;\n\n\n\n\n\n(3) \\({\\tt xtrain}\\)에서 손글씨 0을 의미하는 이미지의 평균을 계산하라. 즉 아래를 계산하라.\n\n\\({\\tt xtrain0mean} = \\frac{1}{5923}\\sum_{i=1}^{5923} {\\tt xtrain0[i, :, :]}\\)\n\n계산결과를 출력하라.\n(풀이)\n\nplt.imshow(xtrain0.mean(axis=0),cmap='gray')\n\n&lt;matplotlib.image.AxesImage at 0x7f4573d89a60&gt;\n\n\n\n\n\n(4) \\({\\tt xtrain}\\)에서 각 라벨에 대한 평균이미지를 계산하고 계산결과를 \\({\\tt imgmean}\\)에 길이가 10인 list로 저장하라. 즉 \\({\\tt imgmean}\\)은 아래와 같은 자료구조를 가지고 있어야 한다.\n\n\\({\\tt imgmean}=\\big[{\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\big]\\)\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 (28,28)의 shape을 가진 numpy array\n\\({\\tt imgmean[0]}, \\dots, {\\tt imgmean[9]}\\) 는 각각 숫자 0,1, …, 9의 평균이미지를 의미\n\n\\({\\tt imgmean[0]},\\dots, {\\tt imgmean[9]}\\)를 시각화 하라.\n(풀이)\n\nimgmean = [xtrain[ytrain==i].mean(axis=0) for i in range(10)] \n\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(imgmean[0],cmap='gray')\nax[0][1].imshow(imgmean[1],cmap='gray')\nax[0][2].imshow(imgmean[2],cmap='gray')\nax[0][3].imshow(imgmean[3],cmap='gray')\nax[0][4].imshow(imgmean[4],cmap='gray')\n\nax[1][0].imshow(imgmean[5],cmap='gray')\nax[1][1].imshow(imgmean[6],cmap='gray')\nax[1][2].imshow(imgmean[7],cmap='gray')\nax[1][3].imshow(imgmean[8],cmap='gray')\nax[1][4].imshow(imgmean[9],cmap='gray')\n\nfig.tight_layout()\n\n\n\n\n(5) \\({\\tt xtrain}\\)의 두번째 이미지와 \\({\\tt imgmean[0]}\\)의 차이를 제곱한 값의 평균을 구하라. 즉 아래를 계산하라.\n\n\\(\\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[1,p,q]}-{\\tt imgmean[0][p,q]}\\big)^2\\)\n\n(풀이)\n\nnp.mean((xtrain[1,:,:]- imgmean[0])**2)\n\n2299.9585279846365\n\n\n(6) 모든 \\(j=0,1,\\dots,9\\) 에 대하여 아래를 계산하라.\n\n\\(\\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[1,p,q]}-{\\tt imgmean[j][p,q]}\\big)^2\\)\n\n계산값이 가장 작게 나오는 \\(j\\)는 얼마인가? 위의 계산결과를 토대로 \\({\\tt xtrain}\\)의 두번째 이미지는 어떠한 숫자를 의미한다고 “분류”하는 것이 타당한가?\n\n[np.mean((xtrain[1,:,:]- imgmean[i])**2) for i in range(10)]\n\n[2299.9585279846365,\n 7474.876421640121,\n 6154.997099653264,\n 5889.84882305034,\n 6763.709480023399,\n 4616.900123430389,\n 5856.367892213506,\n 6465.999476962735,\n 5916.546346421647,\n 6385.5252510342525]\n\n\n(7) 아래와 같은 numpy array 를 생성하라.\n\\[{\\tt loss}=\n\\begin{bmatrix}\n{\\tt loss[0,0]} & \\dots & {\\tt loss[0,9]} \\\\\n{\\tt loss[1,0]} & \\dots & {\\tt loss[1,9]} \\\\\n\\dots & \\dots &  \\dots \\\\\n{\\tt loss[59999,0]}& \\dots &{\\tt loss[59999,9]} \\\\\n\\end{bmatrix}\\]\n단, \\({\\tt loss[i,j]} = \\frac{1}{28\\times 28} \\sum_{p=0}^{27}\\sum_{q=0}^{27}\\big({\\tt xtrain[i,p,q]}-{\\tt imgmean[j][p,q]}\\big)^2\\)\n위에서 생성한 \\({\\tt loss}\\)를 이용해 (6)와 같은 방식으로 \\({\\tt xtrain}\\)의 모든 이미지에 대한 분류를 수행하라.\nhint: \\({\\tt loss}\\)에서 “최소값을 가지는 원소의 인덱스를 출력”하는 함수를 각 행별로 적용하면 된다.\n(풀이)\n\nloss = np.array([[np.mean((xtrain[j,:,:]- imgmean[i])**2) for i in range(10)] for j in range(60000)])\n\n\nloss.argmin(axis=1)\n\narray([5, 0, 4, ..., 5, 6, 8])\n\n\n(8) (7)에서 수행한 분류결과와 실제 라벨 \\({\\tt ytrain}\\)을 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nnp.sum(ytrain == loss.argmin(axis=1)) / 60000\n\n0.8079833333333334\n\n\n(9) \\({\\tt xtrain}\\)에서 학습한 평균이미지 \\({\\tt imgmean}\\)를 바탕으로 \\({\\tt xtest}\\)의 이미지를 분류하라. 분류결과를 \\({\\tt ytest}\\)와 비교하라. 얼마나 많은 결과가 일치하는지 비율을 계산하라.\n(풀이)\n\nest = np.array([[np.mean((xtest[j,:,:]- imgmean[i])**2) for i in range(10)] for j in range(10000)]).argmin(axis=1)\n\n\nnp.sum(est == ytest)/10000\n\n0.8203\n\n\n(10) (9)의 과정에서 잘못분류된 이미지 10개를 선택하여 시각화 하라.\n\n실제 라벨과 잘못된 라벨을 구분하여 시각화 할 것\n\n\n_ytest = ytest[est != ytest]\n_xtest = xtest[est != ytest]\n_est = est[est != ytest]\n\n\nfig, ax = plt.subplots(2,5,figsize=(10,5))\n\nax[0][0].imshow(_xtest[0],cmap='gray'); ax[0][0].set_title('{}/{}'.format(_ytest[0],_est[0]));\nax[0][1].imshow(_xtest[1],cmap='gray'); ax[0][1].set_title('{}/{}'.format(_ytest[1],_est[1]));\nax[0][2].imshow(_xtest[2],cmap='gray'); ax[0][2].set_title('{}/{}'.format(_ytest[2],_est[2]));\nax[0][3].imshow(_xtest[3],cmap='gray'); ax[0][3].set_title('{}/{}'.format(_ytest[3],_est[3]));\nax[0][4].imshow(_xtest[4],cmap='gray'); ax[0][4].set_title('{}/{}'.format(_ytest[4],_est[4]));\n\nax[1][0].imshow(_xtest[5],cmap='gray'); ax[1][0].set_title('{}/{}'.format(_ytest[5],_est[5]));\nax[1][1].imshow(_xtest[6],cmap='gray'); ax[1][1].set_title('{}/{}'.format(_ytest[6],_est[6]));\nax[1][2].imshow(_xtest[7],cmap='gray'); ax[1][2].set_title('{}/{}'.format(_ytest[7],_est[7]));\nax[1][3].imshow(_xtest[8],cmap='gray'); ax[1][3].set_title('{}/{}'.format(_ytest[8],_est[8]));\nax[1][4].imshow(_xtest[9],cmap='gray'); ax[1][4].set_title('{}/{}'.format(_ytest[9],_est[9]));\n\nfig.tight_layout()\n\n\n\n\n\n\nFIFA23 자료분석\n아래는 FIFA23 자료를 불러오는 코드이다.\n\ndf=pd.read_csv('https://raw.githubusercontent.com/guebin/DV2022/master/posts/FIFA23_official_data.csv').drop(columns=['Loaned From', 'Best Overall Rating']).dropna()\ndf.head()\n\n\n\n\n\n\n\n\nID\nName\nAge\nPhoto\nNationality\nFlag\nOverall\nPotential\nClub\nClub Logo\n...\nWork Rate\nBody Type\nReal Face\nPosition\nJoined\nContract Valid Until\nHeight\nWeight\nRelease Clause\nKit Number\n\n\n\n\n0\n209658\nL. Goretzka\n27\nhttps://cdn.sofifa.net/players/209/658/23_60.png\nGermany\nhttps://cdn.sofifa.net/flags/de.png\n87\n88\nFC Bayern München\nhttps://cdn.sofifa.net/teams/21/30.png\n...\nHigh/ Medium\nUnique\nYes\n&lt;span class=\"pos pos28\"&gt;SUB\nJul 1, 2018\n2026\n189cm\n82kg\n€157M\n8.0\n\n\n1\n212198\nBruno Fernandes\n27\nhttps://cdn.sofifa.net/players/212/198/23_60.png\nPortugal\nhttps://cdn.sofifa.net/flags/pt.png\n86\n87\nManchester United\nhttps://cdn.sofifa.net/teams/11/30.png\n...\nHigh/ High\nUnique\nYes\n&lt;span class=\"pos pos15\"&gt;LCM\nJan 30, 2020\n2026\n179cm\n69kg\n€155M\n8.0\n\n\n2\n224334\nM. Acuña\n30\nhttps://cdn.sofifa.net/players/224/334/23_60.png\nArgentina\nhttps://cdn.sofifa.net/flags/ar.png\n85\n85\nSevilla FC\nhttps://cdn.sofifa.net/teams/481/30.png\n...\nHigh/ High\nStocky (170-185)\nNo\n&lt;span class=\"pos pos7\"&gt;LB\nSep 14, 2020\n2024\n172cm\n69kg\n€97.7M\n19.0\n\n\n3\n192985\nK. De Bruyne\n31\nhttps://cdn.sofifa.net/players/192/985/23_60.png\nBelgium\nhttps://cdn.sofifa.net/flags/be.png\n91\n91\nManchester City\nhttps://cdn.sofifa.net/teams/10/30.png\n...\nHigh/ High\nUnique\nYes\n&lt;span class=\"pos pos13\"&gt;RCM\nAug 30, 2015\n2025\n181cm\n70kg\n€198.9M\n17.0\n\n\n4\n224232\nN. Barella\n25\nhttps://cdn.sofifa.net/players/224/232/23_60.png\nItaly\nhttps://cdn.sofifa.net/flags/it.png\n86\n89\nInter\nhttps://cdn.sofifa.net/teams/44/30.png\n...\nHigh/ High\nNormal (170-)\nYes\n&lt;span class=\"pos pos13\"&gt;RCM\nSep 1, 2020\n2026\n172cm\n68kg\n€154.4M\n23.0\n\n\n\n\n5 rows × 27 columns\n\n\n\n(1) 선수들의 평균임금(Wage)을 구하라.\n\n\n삼성전자와 SK하이닉스\n아래는 삼성전자와 SK하이닉스의 주가를 load하는 코드이다.\n\nimport yfinance as yf\n\n# 삼성전자와 SK하이닉스의 종목 코드\ntickers = [\"005930.KS\", \"017670.KS\"]\n\n# 주가 데이터를 불러올 기간\nstart_date = \"2021-01-01\"\nend_date = \"2023-05-02\"\n\n# yfinance를 이용하여 데이터 다운로드\ndf = yf.download(tickers, start=start_date, end=end_date)['Adj Close']\ndf.columns = pd.Index(['삼성전자','SKT']) \n\n# 데이터 확인\ndf\n\n[*********************100%***********************]  2 of 2 completed\n\n\n\n\n\n\n\n\n\n삼성전자\nSKT\n\n\nDate\n\n\n\n\n\n\n2021-01-04\n79093.812500\n69000.554688\n\n\n2021-01-05\n79951.445312\n71620.828125\n\n\n2021-01-06\n78331.453125\n72930.960938\n\n\n2021-01-07\n78998.507812\n78608.226562\n\n\n2021-01-08\n84620.843750\n77152.507812\n\n\n...\n...\n...\n\n\n2023-04-24\n65200.000000\n47700.000000\n\n\n2023-04-25\n63600.000000\n47750.000000\n\n\n2023-04-26\n64100.000000\n47500.000000\n\n\n2023-04-27\n64600.000000\n47350.000000\n\n\n2023-04-28\n65500.000000\n47700.000000\n\n\n\n\n574 rows × 2 columns"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#부분-데이터-꺼내기-판다스를-왜-써야할까",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#부분-데이터-꺼내기-판다스를-왜-써야할까",
    "title": "08wk-1: Pandas (1)",
    "section": "부분 데이터 꺼내기: 판다스를 왜 써야할까?",
    "text": "부분 데이터 꺼내기: 판다스를 왜 써야할까?\n- 예시1: 때로는 인덱스로 때로는 key로 데이터를 부르고 싶다.\n\nnp.random.seed(43052)\natt = np.random.choice(np.arange(10,21)*5,20)\nrep = np.random.choice(np.arange(5,21)*5,20)\nmid = np.random.choice(np.arange(0,21)*5,20)\nfin = np.random.choice(np.arange(0,21)*5,20)\nkey = ['2022-12'+str(s) for s in np.random.choice(np.arange(300,501),20,replace=False)]\n\n학번 ’2022-12363’에 해당하는 학생의 출석점수를 알고 싶다면?\n(풀이1) – dct로 자료를 저장하고 출력\n\ndct = {'att':{key[i]:att[i] for i in range(20)}, \n       'rep':{key[i]:rep[i] for i in range(20)}, \n       'mid':{key[i]:mid[i] for i in range(20)}, \n       'fin':{key[i]:fin[i] for i in range(20)}}\n#dct\n\n\ndct['att']['2022-12363']\n\n65\n\n\n(풀이2) – ndarray로 자료를 저장하고 출력\n\narr = np.array([att,rep,mid,fin,key]).T\narr\n\narray([['65', '55', '50', '40', '2022-12380'],\n       ['95', '100', '50', '80', '2022-12370'],\n       ['65', '90', '60', '30', '2022-12363'],\n       ['55', '80', '75', '80', '2022-12488'],\n       ['80', '30', '30', '100', '2022-12312'],\n       ['75', '40', '100', '15', '2022-12377'],\n       ['65', '45', '45', '90', '2022-12463'],\n       ['60', '60', '25', '0', '2022-12471'],\n       ['95', '65', '20', '10', '2022-12400'],\n       ['90', '80', '80', '20', '2022-12469'],\n       ['55', '75', '35', '25', '2022-12318'],\n       ['95', '95', '45', '0', '2022-12432'],\n       ['95', '55', '15', '35', '2022-12443'],\n       ['50', '80', '40', '30', '2022-12367'],\n       ['50', '55', '15', '85', '2022-12458'],\n       ['95', '30', '30', '95', '2022-12396'],\n       ['50', '50', '45', '10', '2022-12482'],\n       ['65', '55', '15', '45', '2022-12452'],\n       ['70', '70', '40', '35', '2022-12387'],\n       ['90', '90', '80', '90', '2022-12354']], dtype='&lt;U21')\n\n\n\narr[arr[:,-1] == '2022-12363',0] # 읽기어려운 코드\n\narray(['65'], dtype='&lt;U21')\n\n\n(풀이2)가 (풀이1)에 비하여 불편한 점\n\narr 마지마칼럼이 student id 이고 첫번째 칼럼은 att라는 사실을 암기하고 있어야 한다.\n자료형이 문자로 강제로 바뀌어서 저장되어있음\n작성한 코드의 가독성이 없다. (위치로 접근하기 때문)\n\n- 요약: hash 스타일로 정보를 추출하는 것이 유용할 때가 있다. 그리고 보통 hash 스타일로 정보를 뽑는 것이 유리하다. (사실 numpy는 정보추출을 위해 개발된 자료형이 아니라 행렬 및 벡터의 수학연산을 지원하기 위해 개발된 자료형이다)\n- 소망: 정보를 추출할때는 hash 스타일도 유용하다는 것은 이해함 \\(\\to\\) 하지만 나는 가끔 넘파이스타일로 정보를 뽑고 싶은걸? 그리고 딕셔너리 형태가 아니고 엑셀처럼(행렬처럼) 데이터를 보고 싶은걸? \\(\\to\\) pandas의 개발"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#엑셀처럼-데이터를-테이블-형태로-정리하고-싶다",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#엑셀처럼-데이터를-테이블-형태로-정리하고-싶다",
    "title": "08wk-1: Pandas (1)",
    "section": "엑셀처럼 데이터를 테이블 형태로 정리하고 싶다",
    "text": "엑셀처럼 데이터를 테이블 형태로 정리하고 싶다\n(방법1) – 넘파이\n\narr\n\narray([['65', '55', '50', '40', '2022-12380'],\n       ['95', '100', '50', '80', '2022-12370'],\n       ['65', '90', '60', '30', '2022-12363'],\n       ['55', '80', '75', '80', '2022-12488'],\n       ['80', '30', '30', '100', '2022-12312'],\n       ['75', '40', '100', '15', '2022-12377'],\n       ['65', '45', '45', '90', '2022-12463'],\n       ['60', '60', '25', '0', '2022-12471'],\n       ['95', '65', '20', '10', '2022-12400'],\n       ['90', '80', '80', '20', '2022-12469'],\n       ['55', '75', '35', '25', '2022-12318'],\n       ['95', '95', '45', '0', '2022-12432'],\n       ['95', '55', '15', '35', '2022-12443'],\n       ['50', '80', '40', '30', '2022-12367'],\n       ['50', '55', '15', '85', '2022-12458'],\n       ['95', '30', '30', '95', '2022-12396'],\n       ['50', '50', '45', '10', '2022-12482'],\n       ['65', '55', '15', '45', '2022-12452'],\n       ['70', '70', '40', '35', '2022-12387'],\n       ['90', '90', '80', '90', '2022-12354']], dtype='&lt;U21')\n\n\n(방법2) – 판다스 with stacked dict\n\ndf = pd.DataFrame(dct)\ndf.head()\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n\n\n\n\n\n(방법3) – 판다스 with index\n\ndf = pd.DataFrame({'att':att,'rep':rep,'mid':mid,'fin':fin},index=key)\ndf.head()\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#해싱으로-원하는-정보를-뽑으면-좋겠다-마치-딕셔너리처럼",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#해싱으로-원하는-정보를-뽑으면-좋겠다-마치-딕셔너리처럼",
    "title": "08wk-1: Pandas (1)",
    "section": "해싱으로 원하는 정보를 뽑으면 좋겠다 (마치 딕셔너리처럼)",
    "text": "해싱으로 원하는 정보를 뽑으면 좋겠다 (마치 딕셔너리처럼)\n- 예제1: 출석점수를 출력 (딕셔너리가 되면 판다스도 된다)\n\n# dct['att']\ndf['att']\n\n2022-12380    65\n2022-12370    95\n2022-12363    65\n2022-12488    55\n2022-12312    80\n2022-12377    75\n2022-12463    65\n2022-12471    60\n2022-12400    95\n2022-12469    90\n2022-12318    55\n2022-12432    95\n2022-12443    95\n2022-12367    50\n2022-12458    50\n2022-12396    95\n2022-12482    50\n2022-12452    65\n2022-12387    70\n2022-12354    90\nName: att, dtype: int64\n\n\n- 예제2: 학번 2022-12380 의 출석점수 출력\n\n#dct['att']['2022-12380']\ndf['att']['2022-12380']\n\n65"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#인덱싱으로-정보를-뽑는-기능도-지원을-하면-좋겠다-마치-리스트나-넘파이처럼",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#인덱싱으로-정보를-뽑는-기능도-지원을-하면-좋겠다-마치-리스트나-넘파이처럼",
    "title": "08wk-1: Pandas (1)",
    "section": "인덱싱으로 정보를 뽑는 기능도 지원을 하면 좋겠다 (마치 리스트나 넘파이처럼)",
    "text": "인덱싱으로 정보를 뽑는 기능도 지원을 하면 좋겠다 (마치 리스트나 넘파이처럼)\n- 예제1: 첫번째 학생의 기말고사 성적을 출력하고 싶다.\n\ndf.iloc[0,-1]\n\n40\n\n\n\n벼락치기: df에서 iloc이라는 특수기능을 이용하면 넘파이 인덱싱처럼 원소출력이 가능하다.\n\n\ndf는 딕셔너리 같은것이지만 df.iloc은 넘파이같은것이라고 생각하면 된다.\n\n- 예제2: 홀수번째 학생 의 점수를 뽑고 싶다. (홀수번째 학생은 인덱스 0,2,4,… 에 대응)\n\ndf.iloc[::2,:]\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12312\n80\n30\n30\n100\n\n\n2022-12463\n65\n45\n45\n90\n\n\n2022-12400\n95\n65\n20\n10\n\n\n2022-12318\n55\n75\n35\n25\n\n\n2022-12443\n95\n55\n15\n35\n\n\n2022-12458\n50\n55\n15\n85\n\n\n2022-12482\n50\n50\n45\n10\n\n\n2022-12387\n70\n70\n40\n35\n\n\n\n\n\n\n\n- 예제3: 맨 끝에서 3명의 점수를 출력하고 싶다.\n\ndf.iloc[-3:,:]\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12452\n65\n55\n15\n45\n\n\n2022-12387\n70\n70\n40\n35\n\n\n2022-12354\n90\n90\n80\n90\n\n\n\n\n\n\n\n- 예제4: 맨 끝에서 3명의 점수중 마지막 2개의 칼럼만 출력하고 싶다.\n\ndf.iloc[-3:,-2:]\n\n\n\n\n\n\n\n\nmid\nfin\n\n\n\n\n2022-12452\n15\n45\n\n\n2022-12387\n40\n35\n\n\n2022-12354\n80\n90"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#궁극-해싱과-인덱싱을-모두-지원하는-아주-우수한-자료형을-만들고-싶음",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#궁극-해싱과-인덱싱을-모두-지원하는-아주-우수한-자료형을-만들고-싶음",
    "title": "08wk-1: Pandas (1)",
    "section": "궁극: 해싱과 인덱싱을 모두 지원하는 아주 우수한 자료형을 만들고 싶음",
    "text": "궁극: 해싱과 인덱싱을 모두 지원하는 아주 우수한 자료형을 만들고 싶음\n- 예제1: ’mid &gt;= 20 and att &lt;60’인 학생들의 ’fin’을 출력\n(방법1) query\n\n데이터베이스 스타일\n\n\ndf.query('mid&gt;=20 and att&lt;60')['fin']\n\n2022-12488    80\n2022-12318    25\n2022-12367    30\n2022-12482    10\nName: fin, dtype: int64\n\n\n(방법2) numpy\n\narr[(arr[:,2].astype(dtype=np.int64) &gt;= 20) & (arr[:,0].astype(dtype=np.int64) &lt; 60),3]\n\narray(['80', '25', '30', '10'], dtype='&lt;U21')\n\n\n- 예제2: ’중간고사점수&lt;기말고사점수’인 학생들의 출석점수 평균을 구하자.\n\ndf.query('mid&lt;fin')['att'].mean()\n\n76.66666666666667"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#데이터프레임-선언",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#데이터프레임-선언",
    "title": "08wk-1: Pandas (1)",
    "section": "데이터프레임 선언",
    "text": "데이터프레임 선언\n- 방법1: dictionary에서 만든다.\n\npd.DataFrame({'att':[30,40,50],'mid':[50,60,70]})\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\n0\n30\n50\n\n\n1\n40\n60\n\n\n2\n50\n70\n\n\n\n\n\n\n\n\npd.DataFrame({'att':(30,40,50),'mid':(50,60,70)})\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\n0\n30\n50\n\n\n1\n40\n60\n\n\n2\n50\n70\n\n\n\n\n\n\n\n\npd.DataFrame({'att':np.array([30,40,50]),'mid':np.array([50,60,70])})\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\n0\n30\n50\n\n\n1\n40\n60\n\n\n2\n50\n70\n\n\n\n\n\n\n\n- 방법: 2차원 ndarray에서 만든다.\n\nnp.arange(2*3).reshape(2,3)\n\narray([[0, 1, 2],\n       [3, 4, 5]])\n\n\n\npd.DataFrame(np.arange(2*3).reshape(2,3))\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#열의-이름-부여",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#열의-이름-부여",
    "title": "08wk-1: Pandas (1)",
    "section": "열의 이름 부여",
    "text": "열의 이름 부여\n- 방법1: 딕셔너리를 통하여 만들면 딕셔너리의 key가 자동으로 열의 이름이 된다.\n\npd.DataFrame({'att':np.array([30,40,50]),'mid':np.array([50,60,70])})\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\n0\n30\n50\n\n\n1\n40\n60\n\n\n2\n50\n70\n\n\n\n\n\n\n\n- 방법2: pd.DataFrame()의 옵션에 columns를 이용\n\npd.DataFrame(np.arange(2*3).reshape(2,3),columns=['X1','X2','X3'])\n\n\n\n\n\n\n\n\nX1\nX2\nX3\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n- 방법3: df.columns에 원하는 열이름을 덮어씀 (1)\n\ndf=pd.DataFrame(np.arange(2*3).reshape(2,3))\ndf\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n\ndf.columns = ['X1','X2','X3']\ndf\n\n\n\n\n\n\n\n\nX1\nX2\nX3\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n- 방법4: df.columns에 원하는 열이름을 덮어씀 (2)\n\ndf=pd.DataFrame(np.arange(2*3).reshape(2,3))\ndf\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n\ndf.columns = pd.Index(['X1','X2','X3'])\n\n\ndf\n\n\n\n\n\n\n\n\nX1\nX2\nX3\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n방법4가 방법3의 방식보다 컴퓨터가 이해하기 좋다. (= 불필요한 에러 혹은 경고메시지를 방지할 수 있다)"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#행의-이름-부여",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#행의-이름-부여",
    "title": "08wk-1: Pandas (1)",
    "section": "행의 이름 부여",
    "text": "행의 이름 부여\n- 방법1: 중첩 dict이면 nested dic의 key가 알아서 행의 이름으로 된다.\n\npd.DataFrame({'att':{'guebin':30, 'iu':40, 'hynn':50} , 'mid':{'guebin':5, 'iu':45, 'hynn':90}})\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\nguebin\n30\n5\n\n\niu\n40\n45\n\n\nhynn\n50\n90\n\n\n\n\n\n\n\n- 방법2: pd.DataFrame()의 index 옵션 이용\n\npd.DataFrame({'att':[30,40,50] , 'mid':[5,45,90]},index=['guebin','iu','hynn'])\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\nguebin\n30\n5\n\n\niu\n40\n45\n\n\nhynn\n50\n90\n\n\n\n\n\n\n\n- 방법3: df.index에 덮어씌움\n\ndf=pd.DataFrame({'att':[30,40,50] , 'mid':[5,45,90]})\ndf\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\n0\n30\n5\n\n\n1\n40\n45\n\n\n2\n50\n90\n\n\n\n\n\n\n\n\ndf.index = pd.Index(['guebin','iu','hynn'])\n#df.index = ['guebin','iu','hynn'] &lt;- 이것도 실행가능하기는함 \ndf\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\nguebin\n30\n5\n\n\niu\n40\n45\n\n\nhynn\n50\n90\n\n\n\n\n\n\n\n- 방법4: df.set_index() 를 이용하여 덮어씌운다\n\ndf=pd.DataFrame({'att':[30,40,50] , 'mid':[5,45,90]})\ndf\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\n0\n30\n5\n\n\n1\n40\n45\n\n\n2\n50\n90\n\n\n\n\n\n\n\n\ndf.set_index(pd.Index(['guebin','iu','hynn']))\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\nguebin\n30\n5\n\n\niu\n40\n45\n\n\nhynn\n50\n90\n\n\n\n\n\n\n\n\ndf.set_index(['guebin','iu','hynn'])\n\nKeyError: \"None of ['guebin', 'iu', 'hynn'] are in the columns\"\n\n\n\ndf.set_index([['guebin','iu','hynn']]) # 꺽쇠를 한번 더 넣어주면 에러를 피할수 있다. \n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\nguebin\n30\n5\n\n\niu\n40\n45\n\n\nhynn\n50\n90\n\n\n\n\n\n\n\n\n그러나 이런 코드를 권장하지 않음"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#자료형-len-shape-for문의-반복변수",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#자료형-len-shape-for문의-반복변수",
    "title": "08wk-1: Pandas (1)",
    "section": "자료형, len, shape, for문의 반복변수",
    "text": "자료형, len, shape, for문의 반복변수\n\ndf = pd.DataFrame({'att':[30,40,50],'mid':[5,45,90]})\ndf\n\n\n\n\n\n\n\n\natt\nmid\n\n\n\n\n0\n30\n5\n\n\n1\n40\n45\n\n\n2\n50\n90\n\n\n\n\n\n\n\n- type\n\ntype(df)\n\npandas.core.frame.DataFrame\n\n\n- len\n\nlen(df) # row의 갯수 \n\n3\n\n\n- shape\n\ndf.shape \n\n(3, 2)\n\n\n- for문의 반복변수\n\nfor k in df:\n    print(k) # 딕셔너리같죠\n\natt\nmid\n\n\n\nfor k in {'att':[30,40,50],'mid':[5,45,90]}: \n    print(k)\n\natt\nmid\n\n\n참고: df는 진짜 딕셔너리 느낌 강해요\n\ndf.keys()\n\nIndex(['att', 'mid'], dtype='object')\n\n\n\nfor k,v in df.items():\n    print(k)\n\natt\nmid"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#pd.series",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#pd.series",
    "title": "08wk-1: Pandas (1)",
    "section": "pd.Series",
    "text": "pd.Series\n- 2차원 ndarray가 pd.DataFrame에 대응한다면 1차원 ndarray는 pd.Series에 대응한다.\n\na=pd.Series(np.random.randn(10))\na\n\n0    0.106173\n1    0.723759\n2    0.217990\n3    0.194022\n4   -0.688990\n5   -0.351670\n6    0.990933\n7    1.212147\n8   -0.608965\n9    0.032549\ndtype: float64\n\n\n\ntype(a)\n\npandas.core.series.Series\n\n\n\nlen(a)\n\n10\n\n\n\na.shape\n\n(10,)\n\n\n\nfor value in a: \n    print(value)\n\n0.10617283591748639\n0.7237590624253404\n0.21798967912700873\n0.1940223087322443\n-0.6889899757985083\n-0.3516696436204985\n0.9909329773184973\n1.2121468150185186\n-0.6089654373693767\n0.03254898346416765"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#열의-선택",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#열의-선택",
    "title": "08wk-1: Pandas (1)",
    "section": "열의 선택",
    "text": "열의 선택\n- 방법1: df[] + 칼럼이름, 칼럼이름의 list\n\n# df['att'] # 칼럼이름 \n# df[['att']] # 칼럼이름의 list \n# df[['att','rep']] # 칼럼이름의 list \n\n- 방법2: df.iloc[:,] + 정수, 정수의 list, range, 슬라이싱, 스트라이딩, bool의 list\n\n# df.iloc[:,0] # 정수\n# df.iloc[:,[0]] # 정수의 list \n# df.iloc[:,[0,1]] # 정수의 list \n# df.iloc[:,range(2)] # range\n# df.iloc[:,-2:] # 슬라이싱\n# df.iloc[:,1::2] # 스트라이딩\n# df.iloc[:,[True,True,False,False]] # bool의 list \n\n- 방법3: df.loc[:,] + 칼럼이름, 컬럼이름의 list, 칼럼이름으로 슬라이싱(\\(\\star\\)), 칼럼이름으로 스트라이딩(\\(\\star\\)), bool의 list\n\n# df.loc[:,'att'] # 칼럼이름\n# df.loc[:,['att']] # 칼럼이름의 list \n# df.loc[:,['att','rep']] # 칼럼이름의 list \n# df.loc[:,'rep':'mid'] # 칼럼이름으로 슬라이싱 \n# df.loc[:,'rep'::2] # 칼럼이름으로 스트라이딩\n# df.loc[:,[True,False,False,True]] # bool의 list"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#행의-선택",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#행의-선택",
    "title": "08wk-1: Pandas (1)",
    "section": "행의 선택",
    "text": "행의 선택\n여기서는 df=중첩된list 라고 생각해야 코드가 잘 읽힌다.\n- 방법1: df.iloc[] + 정수, 정수의리스트, range, 슬라이싱, 스트라이딩, bool의 list\n\n# df.iloc[0] # 정수 \n# df.iloc[[0]] # 정수의 list \n# df.iloc[[0,1]] # 정수의 list \n# df.iloc[range(2)] # range\n# df.iloc[-2:] # 슬라이싱\n# df.iloc[1::2] # 스트라이딩\n# df.iloc[[True]+[False]*19] # bool의 list \n# df.iloc[list(df['att']&gt;70)] # bool의 list \n\n여기서는 df=2차원array라고 생각해야 코드가 잘 읽힌다.\n- 방법1: df.iloc[,:] + 정수, 정수의리스트, range, 슬라이싱, 스트라이딩, bool의 list\n\n# df.iloc[0,:] # 정수 \n# df.iloc[[0],:] # 정수의 list \n# df.iloc[[0,1],:] # 정수의 list \n# df.iloc[range(2),:] # range\n# df.iloc[-2:,:] # 슬라이싱\n# df.iloc[1::2,:] # 스트라이딩\n# df.iloc[[True]+[False]*19,:] # bool의 list \n# df.iloc[list(df['att']&gt;70),:] # bool의 list \n\n- 방법2: df.loc[,:] + 인덱스이름의 리스트, 인덱스이름으로 슬라이싱(\\(\\star\\)), 인덱스이름으로 스트라이딩(\\(\\star\\)), bool의 list\n\n# df.loc['2022-12380',:] # 인덱스이름 \n# df.loc[['2022-12380','2022-12370'],:] # 인덱스이름의 리스트\n# df.loc['2022-12452':,:] # 인덱스이름으로 슬라이싱\n# df.loc['2022-12380'::3,:] # 인덱스이름으로 스트라이딩\n# df.loc[list(df['att']&gt;70),:] # bool의 list \n# df.loc[df['att']&gt;70,:] # bool의 list"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#안썼으면-좋겠는-코드",
    "href": "PP2023/posts/02_DataScience/2023-04-24-8wk-1.html#안썼으면-좋겠는-코드",
    "title": "08wk-1: Pandas (1)",
    "section": "안썼으면 좋겠는 코드",
    "text": "안썼으면 좋겠는 코드\n- 제가 안쓰는 코드1:\n\ndf['2022-12380':'2022-12370']\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12370\n95\n100\n50\n80\n\n\n\n\n\n\n\n이러면 내 입장에서는 마치 아래가 동작할 것 같잖아..\n\ndf['2022-12380']\n\nKeyError: '2022-12380'\n\n\n- 제가 안쓰는 코드2: bool의 list를 사용할때 iloc은 가급적 쓰지마세요\n\ndf.iloc[list(df['att']&lt;80),:]\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12377\n75\n40\n100\n15\n\n\n2022-12463\n65\n45\n45\n90\n\n\n2022-12471\n60\n60\n25\n0\n\n\n2022-12318\n55\n75\n35\n25\n\n\n2022-12367\n50\n80\n40\n30\n\n\n2022-12458\n50\n55\n15\n85\n\n\n2022-12482\n50\n50\n45\n10\n\n\n2022-12452\n65\n55\n15\n45\n\n\n2022-12387\n70\n70\n40\n35\n\n\n\n\n\n\n\n이러면 마치 아래도 동작할 것 같잖아..\n\ndf.iloc[df['att']&lt;80,:]\n\nValueError: Location based indexing can only have [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array] types\n\n\n- 참고: 맨날 틀리는 코드\n\ndf.loc['att']\n\nKeyError: 'att'"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#line-plot",
    "href": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#line-plot",
    "title": "07wk-1: Numpy 활용 (1)",
    "section": "line plot",
    "text": "line plot\n\n기본플랏\n- 예시1\n\nx=[1,2,3,4]\ny=[1,2,4,3] \n\n\nplt.plot(x,y)\n\n\n\n\n\n\n모양변경\n- 예시1\n\nplt.plot(x,y,'--')\n\n\n\n\n- 예시2\n\nplt.plot(x,y,':')\n\n\n\n\n- 예시3\n\nplt.plot(x,y,'-.')\n\n\n\n\n\n\n색상변경\n- 예시1\n\nplt.plot(x,y,'r')\n\n\n\n\n- 예시2\n\nplt.plot(x,y,'k')\n\n\n\n\n\n\n모양 + 색상변경\n- 예시1\n\nplt.plot(x,y,'--r')\n\n\n\n\n- 예시2: 순서변경 가능\n\nplt.plot(x,y,'r--')\n\n\n\n\n\n\n원리? (\\(\\star\\))\n- r--등의 옵션은 Markers + Line Styles + Colors 의 조합으로 표현가능\nref: https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html\n\n--r: 점선(dashed)스타일 + 빨간색\nr--: 빨간색 + 점선(dashed)스타일\n:k: 점선(dotted)스타일 + 검은색\nk:: 검은색 + 점선(dotted)스타일\n\n- 우선 Marker를 무시하면 Line Styles + Color로 표현가능한 조합은 \\(4\\times 8=32\\) 개\n(Line Styles) 모두 4개\n\n\n\ncharacter\ndescription\n\n\n\n\n‘-’\nsolid line style\n\n\n‘–’\ndashed line style\n\n\n‘-.’\ndash-dot line style\n\n\n‘:’\ndotted line style\n\n\n\n(Color) 모두 8개\n\n\n\ncharacter\ncolor\n\n\n\n\n‘b’\nblue\n\n\n‘g’\ngreen\n\n\n‘r’\nred\n\n\n‘c’\ncyan\n\n\n‘m’\nmagenta\n\n\n‘y’\nyellow\n\n\n‘k’\nblack\n\n\n‘w’\nwhite"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#scatter-plot",
    "href": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#scatter-plot",
    "title": "07wk-1: Numpy 활용 (1)",
    "section": "scatter plot",
    "text": "scatter plot\n\n기본플랏\n- 예시1\n\nplt.plot(x,y,'o')\n\n\n\n\n- 예시2\n\nplt.plot(x,y,'.')\n\n\n\n\n- 예시3\n\nplt.plot(x,y,'x')\n\n\n\n\n\n\n색깔변경\n- 예시1\n\nplt.plot(x,y,'or')\n\n\n\n\n- 예시2\n\nplt.plot(x,y,'db')\n\n\n\n\n- 예시3\n\nplt.plot(x,y,'bx')"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#dot-connected-plot",
    "href": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#dot-connected-plot",
    "title": "07wk-1: Numpy 활용 (1)",
    "section": "dot-connected plot",
    "text": "dot-connected plot\n- 예시1: 마커와 라인스타일을 동시에 사용하면 dot-connected plot이 된다.\n\nplt.plot(x,y,'o-')\n\n\n\n\n- 예시2: 당연히 색도 적용가능함\n\nplt.plot(x,y,'o--r')\n\n\n\n\n- 예시3: 서로 순서를 바꿔도 상관없다.\n\nplt.plot(x,y,'ro--')"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#겹쳐그리기",
    "href": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#겹쳐그리기",
    "title": "07wk-1: Numpy 활용 (1)",
    "section": "겹쳐그리기",
    "text": "겹쳐그리기\n- 예시1\n\nx = np.arange(-5,5,0.1)\nϵ = np.random.randn(100) \ny = 2*x + ϵ\n\n\nplt.plot(x,y,'.')\nplt.plot(x,2*x,'--')"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#이미지자료의-이해-및-시각화",
    "href": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#이미지자료의-이해-및-시각화",
    "title": "07wk-1: Numpy 활용 (1)",
    "section": "이미지자료의 이해 및 시각화",
    "text": "이미지자료의 이해 및 시각화\n- 참고: 빛의삼원색\n- 이미지자료의 이해: 이미지자료는 rgb값이 저장된 3개의 매트릭스를 쌓은것이라 이해가능\n\n이미지자료의 shape은 (가로픽셀, 세로픽셀, 3) 이다. // 5*5 이미지라면 (5,5,3)\n3은 RGB 빛의 밝기를 정의함.\n밝기는 0-255 사이의 int, 0-1 사이의 float으로 정한다.\nint 255 혹은 float 1 은 해당색이 매우 밝다는 것을 의미함.\n각 픽셀의 색깔은 RGB의 밝기 (RGB의 값) 으로 조정가능하다. (따라서 총 256256256 개의 색상을 표현할 수 있다.)\n\n- 예시1\n\nr = np.array([0]*25*3).reshape(5,5,3) \ng = np.array([0]*25*3).reshape(5,5,3) \nb = np.array([0]*25*3).reshape(5,5,3) \n\n\nr[:3,:3,0] = 255   \n\n\nr[:3,:3,0] = 255   \ng[:3,2:,1] = 255\nb[2:,:,2] = 255 \n\n\nr[:,:,0], r[:,:,1], r[:,:,2]\n\n(array([[255, 255, 255,   0,   0],\n        [255, 255, 255,   0,   0],\n        [255, 255, 255,   0,   0],\n        [  0,   0,   0,   0,   0],\n        [  0,   0,   0,   0,   0]]),\n array([[0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]]),\n array([[0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]]))\n\n\n\ng[:,:,0], g[:,:,1], g[:,:,2]\n\n(array([[0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]]),\n array([[  0,   0, 255, 255, 255],\n        [  0,   0, 255, 255, 255],\n        [  0,   0, 255, 255, 255],\n        [  0,   0,   0,   0,   0],\n        [  0,   0,   0,   0,   0]]),\n array([[0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]]))\n\n\n\nb[:,:,0], b[:,:,1], b[:,:,2]\n\n(array([[0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]]),\n array([[0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]]),\n array([[  0,   0,   0,   0,   0],\n        [  0,   0,   0,   0,   0],\n        [255, 255, 255, 255, 255],\n        [255, 255, 255, 255, 255],\n        [255, 255, 255, 255, 255]]))\n\n\n\nplt.imshow(r+g+b)\n\n&lt;matplotlib.image.AxesImage at 0x7f6a94cdd6a0&gt;\n\n\n\n\n\n- 예시2: r,g,b에 작은 숫자를 주면 점점 어두워 진다.\n\nr = np.array([0]*25*3).reshape(5,5,3) \ng = np.array([0]*25*3).reshape(5,5,3) \nb = np.array([0]*25*3).reshape(5,5,3) \n\n\nr[:3,:3,0] = 80\ng[:3,2:,1] = 80\nb[2:,:,2] = 80\n\n\nplt.imshow((r+g+b))\n\n&lt;matplotlib.image.AxesImage at 0x7f6a94c52040&gt;\n\n\n\n\n\n- 예시3: r,g,b 값이 float으로 저장되었다면 표준화가 진행된것으로 컴퓨터가 이해한다.\n\nr = np.array([0]*25*3).reshape(5,5,3) \ng = np.array([0]*25*3).reshape(5,5,3) \nb = np.array([0]*25*3).reshape(5,5,3)\n\n\nr[:3,:3,0] = 1\ng[:3,2:,1] = 1\nb[2:,:,2] = 1\n\n\nplt.imshow(r+g+b)\n\n&lt;matplotlib.image.AxesImage at 0x7f6a94b044f0&gt;\n\n\n\n\n\n\nplt.imshow((r+g+b)*1.0) # array의 각 원소의 자료형이 float이면 표준화된 자료라고 이해하고 칼라스케일을 다시 맞춰줌. \n\n&lt;matplotlib.image.AxesImage at 0x7f6a949e03a0&gt;\n\n\n\n\n\n\nplt.imshow((r+g+b)*2.0) # 2.0을 곱해도 출력하긴 해줌.. (경고메시지 발생) \n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n&lt;matplotlib.image.AxesImage at 0x7f6a949c9790&gt;"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#그래프",
    "href": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#그래프",
    "title": "07wk-1: Numpy 활용 (1)",
    "section": "그래프",
    "text": "그래프\n1. \\(y(t)=\\cos(2t)\\)와 \\(x(t)=\\sin(t)\\)를 고려하자. \\(y(t)=x(t)\\)는 \\(-3.14\\leq t \\leq 3.14\\) 에서 몇 개의 해를 가지는가? 그래프를 통하여 확인하라.\n(풀이)\n\nt = np.linspace(-3.14,3.14,1000)\ny = np.cos(2*t)\nx = np.sin(t)\n\n\nplt.plot(t,x)\nplt.plot(t,y)\n\n\n\n\n2-3. 아래와 같은 합성함수를 생각하라.\n\n\\(l(x)=w_0+w_1x\\)\n\\(a(x)=\\frac{1}{1+e^{-x}}\\)\n\n2. \\(x \\in [-5,5]\\)의 범위에서 \\(a(l(x))\\)의 그래프를 그려라. 단 이때 \\(w_0=0, w_1=1\\)로 설정한다.\n(풀이)\n\\(y=a(l(x))= a(w_0+w_1x) = 1/(1+\\exp(-w_0-w_1x))\\)\n그런데, \\(w_0=0\\) 이고 \\(w_1=1\\) 이므로 \\(y=a(l(x)) = 1/ (1+\\exp(-x))\\) 이다.\n\nx = np.linspace(-5,5,100)\ny = 1/(1+np.exp(-x))\nplt.plot(x,y)\n\n\n\n\n3. 아래는 \\(a(l(x))\\)의 성질에 대하여 토의한 내용이다. 올바르게 서술한 학생을 골라라.\n\n하영: \\(w_0=0,w_1=1\\) 이면 \\(a(l(x))\\)는 증가하는 함수이다.\n재인:\n서연:\n보람:\n지윤:\n\n(풀이)\n아래와 같은 함수를 선언한뒤에 하나씩 체크해 나가면된다.\n\ndef l(x,w0=0,w1=1): \n    return w0+w1*x \ndef a(x): \n    return 1/(1+np.exp(-x))"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#자료를-저장하는-행렬",
    "href": "PP2023/posts/02_DataScience/2023-04-17-7wk-1.html#자료를-저장하는-행렬",
    "title": "07wk-1: Numpy 활용 (1)",
    "section": "자료를 저장하는 행렬",
    "text": "자료를 저장하는 행렬\n- 제 생각: 통계학과에서 매트릭스를 바라볼때 2가지중 하나로 봐야한다.\n\n데이터를 저장하는 관점에서의 행렬: \\(X_{n\\times p}\\)인 정형자료, \\(X\\)가 이미지자료\n\n데이터를 변환하는 관점에서의 행렬: 선형변환 (회전변환, 평균을 구하는 행렬 등)\n\n\ndata=[70,80,75,85,95]\ntrans = [1/5]*5\n\n\nnp.array(data) @ np.array(trans)\n\n81.0\n\n\n\nsum(data)/5\n\n81.0\n\n\n1-2. 아래와 같은 자료를 관측하였다고 하자.\n\nX = np.array([[11.75 ,  5.72 ],\n              [12.39 ,  7.695],\n              [11.75 ,  6.93 ],\n              [11.625,  4.195],\n              [12.6  ,  6.734],\n              [11.13 ,  6.688],\n              [12.24 ,  7.33 ],\n              [13.586,  1.072],\n              [10.9  ,  4.125],\n              [10.68 ,  3.691]])\n\n1. X를 평균과 표준편차를 columnwise 하게 구하라. 즉 1열의 평균, 2열의 평균, 1열의 표준편차, 2열의 표준편차를 구하라.\nnote: 표준편차는 ddof=1과 함께 np.std()를 사용할 것\n(풀이)\n\nX.mean(axis=0)\n\narray([11.8651,  5.418 ])\n\n\n\nX.std(ddof=1,axis=0)\n\narray([0.87420064, 2.09762829])\n\n\n2. X를 columnwise 하게 표준화하라.\nhint: np.apply_along_axis의 함수의 기능을 관찰하고 이용하라.\n(예시1)\n\nX.mean(axis=0)\n\narray([11.8651,  5.418 ])\n\n\n\nX.mean(axis=0), np.apply_along_axis(np.mean,axis=0,arr=X) \n\n(array([11.8651,  5.418 ]), array([11.8651,  5.418 ]))\n\n\n(예시2)\n\ndef f(arr):\n    return arr - np.min(arr) \nX, np.apply_along_axis(f,axis=0,arr=X)\n\n(array([[11.75 ,  5.72 ],\n        [12.39 ,  7.695],\n        [11.75 ,  6.93 ],\n        [11.625,  4.195],\n        [12.6  ,  6.734],\n        [11.13 ,  6.688],\n        [12.24 ,  7.33 ],\n        [13.586,  1.072],\n        [10.9  ,  4.125],\n        [10.68 ,  3.691]]),\n array([[1.07 , 4.648],\n        [1.71 , 6.623],\n        [1.07 , 5.858],\n        [0.945, 3.123],\n        [1.92 , 5.662],\n        [0.45 , 5.616],\n        [1.56 , 6.258],\n        [2.906, 0.   ],\n        [0.22 , 3.053],\n        [0.   , 2.619]]))\n\n\n(풀이)\n\ndef f(arr): \n    return (arr-arr.mean()) / arr.std(ddof=1)\n\n\nnp.apply_along_axis(f,axis=0,arr=X)\n\narray([[-0.13166314,  0.14397212],\n       [ 0.60043424,  1.08551168],\n       [-0.13166314,  0.72081408],\n       [-0.27465091, -0.58303943],\n       [ 0.84065369,  0.62737522],\n       [-0.84088247,  0.60544569],\n       [ 0.42884892,  0.91150563],\n       [ 1.96854122, -2.07186374],\n       [-1.10397997, -0.61641045],\n       [-1.35563844, -0.82331079]])\n\n\n3-5. 아래는 이미지파일을 불러오는 코드이다.\n\nimport PIL \n\n\n!wget https://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg\nhani = np.einsum('ijk-&gt;jik',np.array(PIL.Image.open('hani.jpeg'),dtype=np.int64)/255)\n!rm hani.jpeg\n\n\nnote: 위 코드는 코랩 혹은 리눅스기반 환경에서 동작가능.\n주피터노트북의 경우 아래의 절차를 따를 것\n\nhttps://raw.githubusercontent.com/guebin/SC2022/main/hani.jpeg 에서 직접사진을 다운로드\n현재작업중인 주피터노트북과 같은폴더에 그림파일을 옮김\nhani = np.einsum('ijk-&gt;jik',np.array(PIL.Image.open('hani.jpeg'),dtype=np.int64)/255) 실행 // 그전에 import PIL 을 해야함\n그림파일 삭제\n\n\n불러온 이미지는 아래와 같다.\n\nhani,hani.shape\n\n(array([[[0.44705882, 0.48627451, 0.49411765],\n         [0.43137255, 0.46666667, 0.48627451],\n         [0.45882353, 0.50196078, 0.51764706],\n         ...,\n         [0.6627451 , 0.6627451 , 0.70196078],\n         [0.63529412, 0.62745098, 0.67058824],\n         [0.64313725, 0.63529412, 0.67843137]],\n \n        [[0.45882353, 0.49803922, 0.50588235],\n         [0.44313725, 0.47843137, 0.49803922],\n         [0.4627451 , 0.50588235, 0.52156863],\n         ...,\n         [0.63921569, 0.63921569, 0.67843137],\n         [0.64313725, 0.63529412, 0.67843137],\n         [0.63137255, 0.62352941, 0.66666667]],\n \n        [[0.45490196, 0.49411765, 0.50196078],\n         [0.4627451 , 0.49803922, 0.51764706],\n         [0.45882353, 0.50196078, 0.51764706],\n         ...,\n         [0.64313725, 0.64313725, 0.68235294],\n         [0.65490196, 0.65490196, 0.69411765],\n         [0.64705882, 0.63921569, 0.68235294]],\n \n        ...,\n \n        [[0.69411765, 0.69803922, 0.70588235],\n         [0.68627451, 0.69019608, 0.69803922],\n         [0.69411765, 0.69803922, 0.70588235],\n         ...,\n         [0.60784314, 0.6       , 0.60392157],\n         [0.6       , 0.59215686, 0.59607843],\n         [0.59607843, 0.58823529, 0.59215686]],\n \n        [[0.70196078, 0.70588235, 0.71372549],\n         [0.72156863, 0.7254902 , 0.73333333],\n         [0.69019608, 0.69411765, 0.70196078],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61568627, 0.60784314, 0.61176471]],\n \n        [[0.7254902 , 0.72941176, 0.74509804],\n         [0.73333333, 0.7372549 , 0.74509804],\n         [0.70980392, 0.71372549, 0.72156863],\n         ...,\n         [0.61176471, 0.60392157, 0.60784314],\n         [0.60392157, 0.59607843, 0.6       ],\n         [0.61960784, 0.61176471, 0.61568627]]]),\n (4032, 3024, 3))\n\n\n\n이미지는 4032 \\(\\times\\) 3024 개의 격자(픽셀)로 이루어져 있음\n\n이미지를 보는 방법은 아래와 같다.\n\nplt.imshow(hani) # 모든이미지, 하니매트릭스\n\n&lt;matplotlib.image.AxesImage at 0x7f6a956ed9d0&gt;\n\n\n\n\n\n\nplt.imshow(hani[1000:1500, 1000:2000,:]) # 얼굴만 확대, 하니의 서브매트릭스 \n\n&lt;matplotlib.image.AxesImage at 0x7f6a94572f10&gt;\n\n\n\n\n\n3. 하니이미지를 나타내는 어레이를 변형하여 빨간색을 의미하는 칼라만 남겨서 “빨간하니”를 만들고 이미지를 출력하라.\n(풀이)\n\nred_hani = hani*0 \nred_hani[:,:,0] = hani[:,:,0]\nplt.imshow(red_hani)\n\n&lt;matplotlib.image.AxesImage at 0x7f6a91b1d5e0&gt;\n\n\n\n\n\n4. 하니의 모든 값에 루트를 취하여 “루트하니”를 만들고 “원본하니”와 “루트하니”를 좌우로 나란히 배치하여 출력하라.\n(풀이)\n\nroot_hani = np.sqrt(hani)\nplt.imshow(np.concatenate([hani,root_hani],axis=1))\n\n&lt;matplotlib.image.AxesImage at 0x7f6a933b7910&gt;\n\n\n\n\n\n“루트하니”의 이미지는 “원본하니”의 이미지와 비교하여 어떤가? 왜 그러한 결과가 나왔다고 생각하는가?\n5. 하니의 모든값에 아래와 같은 함수를 적용하라.\n\n\\(f(x)=\\begin{cases} \\sqrt{x} & x&gt;0.7 \\\\ x & x \\leq 0.7 \\end{cases}\\)\n\n함수의 결과로 얻어진 매트릭스를 “후광하니”라고 부르자. “원본하니”와 “후광하니”를 좌우로 나란히 배치하여 출력하라.\n\nshiny_hani = np.sqrt(hani)*(hani&gt;0.7)+hani*(hani&lt;=0.7)\nplt.imshow(np.concatenate([hani,shiny_hani],axis=1))\n\n&lt;matplotlib.image.AxesImage at 0x7f6a921677c0&gt;"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#선언",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#선언",
    "title": "06wk-1: Numpy (1)",
    "section": "선언",
    "text": "선언\n\nl = [1,2,3]\na = np.array(l)\n\n\na=np.array([1,2,3]) # list를 만들고 ndarray화 시킴 \nl=[1,2,3]"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#기본연산-브로드캐스팅",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#기본연산-브로드캐스팅",
    "title": "06wk-1: Numpy (1)",
    "section": "기본연산 브로드캐스팅",
    "text": "기본연산 브로드캐스팅\n- 사칙연산가능\n\na+1 ## [1,2,3] + 1 = [2,3,4]\n\narray([2, 3, 4])\n\n\n\nl+1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\na*2\n\narray([2, 4, 6])\n\n\n\nl*2\n\n[1, 2, 3, 1, 2, 3]\n\n\n\na/2\n\narray([0.5, 1. , 1.5])\n\n\n\nl/2\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n- 제곱이 가능\n\na**2\n\narray([1, 4, 9])\n\n\n\nl**2\n\nTypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'\n\n\n- 나머지 연산가능\n\na%2 # %2 = 2로 나눈 나머지를 리턴 a=[1,2,3] \n\narray([1, 0, 1])\n\n\n\nl%2\n\nTypeError: unsupported operand type(s) for %: 'list' and 'int'"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#기타수학연산지원",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#기타수학연산지원",
    "title": "06wk-1: Numpy (1)",
    "section": "기타수학연산지원",
    "text": "기타수학연산지원\n\nnp.sqrt(a), np.sqrt(l)\n\n(array([1.        , 1.41421356, 1.73205081]),\n array([1.        , 1.41421356, 1.73205081]))\n\n\n\nnp.log(a), np.log(l)\n\n(array([0.        , 0.69314718, 1.09861229]),\n array([0.        , 0.69314718, 1.09861229]))\n\n\n\nnp.exp(a), np.exp(l)\n\n(array([ 2.71828183,  7.3890561 , 20.08553692]),\n array([ 2.71828183,  7.3890561 , 20.08553692]))\n\n\n\nnp.sin(a), np.sin(l)\n\n(array([0.84147098, 0.90929743, 0.14112001]),\n array([0.84147098, 0.90929743, 0.14112001]))"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-star",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-star",
    "title": "06wk-1: Numpy (1)",
    "section": "차원 (\\(\\star\\))",
    "text": "차원 (\\(\\star\\))\n- 넘파이배열의 차원은 .shape 으로 확인가능\n- 아래는 모두 미묘하게 다르다.\n\na=np.array(3.14) # 스칼라, 0d array \na, a.shape\n\n(array(3.14), ())\n\n\n\na=np.array([3.14]) # 벡터, 1d array \na, a.shape\n\n(array([3.14]), (1,))\n\n\n\na=np.array([[3.14]]) # 매트릭스, 2d array \na, a.shape\n\n(array([[3.14]]), (1, 1))\n\n\n\na=np.array([[[3.14]]]) # 텐서, 3d array \na, a.shape\n\n(array([[[3.14]]]), (1, 1, 1))"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#인덱싱-1차원",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#인덱싱-1차원",
    "title": "06wk-1: Numpy (1)",
    "section": "인덱싱 1차원",
    "text": "인덱싱 1차원\n- 선언\n\nl=[11,22,33,44,55,66] \na=np.array(l) \n\n- 인덱스로 접근\n\nl[0],l[1],l[2],l[3],l[-2],l[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n\na[0],a[1],a[2],a[3],a[-2],a[-1]\n\n(11, 22, 33, 44, 55, 66)\n\n\n- : 이용 (슬라이싱)\n\nl[2:4] # index 2에서 시작, index 4는 포함하지 않음 \n\n[33, 44]\n\n\n\na[2:4] \n\narray([33, 44])\n\n\n- 정수배열에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[0,2,4]] # index=0, index=2, index=4 에 해당하는 원소를 뽑고 싶다 \n\narray([11, 33, 55])\n\n\n\nl[[0,2,4]] # 리스트는 불가능 \n\nTypeError: list indices must be integers or slices, not list\n\n\n- 참고: 정수배열에 의한 인덱싱에서 아래의 코드는 돌아가지 않음.\n\na[(0,2,4)] # a[[0,2,4]] 는 돌아감 \n\nIndexError: too many indices for array: array is 1-dimensional, but 3 were indexed\n\n\n\n즉 a[index]에서 index의 자리에 리스트를 넣어야만 동작.\nindex자리에 튜플을 넣으면 동작하지 않음.\n이러한 사소한 지식까지 알아야 하는걸 추천하는건 아님.\n\n- 부울값에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[True, False, True, False, True, False]]\n\narray([11, 33, 55])\n\n\n응용하면?\n\na &lt; 33 \n\narray([ True,  True, False, False, False, False])\n\n\n\na[a&lt;33]\n\narray([11, 22])\n\n\n리스트는 불가능\n\nl&lt;33 # 여기에서부터 불가능 \n\nTypeError: '&lt;' not supported between instances of 'list' and 'int'\n\n\n\nl[[True,False,True,False,True,False]] # 이것도 불가능 \n\nTypeError: list indices must be integers or slices, not list"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#인덱싱-2차원",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#인덱싱-2차원",
    "title": "06wk-1: Numpy (1)",
    "section": "인덱싱 2차원",
    "text": "인덱싱 2차원\n- 중첩리스트와 2차원 np.array 선언\n\nA = [[1,2,3,4],[-1,-2,-3,-4],[5,6,7,8],[-5,-6,-7,-8]]\nA2 = np.array(A)\n\n\nA\n\n[[1, 2, 3, 4], [-1, -2, -3, -4], [5, 6, 7, 8], [-5, -6, -7, -8]]\n\n\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n- A의 원소 인덱싱\n\nnp.array(A)\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n- A(이중list)에서의 원소 추출\n\nA[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2(넘파이어레이)에서의 원소 인덱싱\n\nA2[0][0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1][2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1][0] # (4,1)의 원소 \n\n-5\n\n\n- A2에서만 되는 기술 (넘파이에서 제시하는 신기술, R에서는 기본적으로 쓰던것, 이중list는 불가능)\n\nA2[0,0] # (1,1)의 원소 \n\n1\n\n\n\nA2[1,2] # (2,3)의 원소 \n\n-3\n\n\n\nA2[-1,0] # (4,1)의 원소 \n\n-5\n\n\n- A2에서의 인덱싱예시\n(예시1) 1행,1-2열 추출\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[0,0:2] # 1행1열, 1행2열 \n\narray([1, 2])\n\n\n(예시2) 1행 추출\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[0,:] # 방법1\n\narray([1, 2, 3, 4])\n\n\n\nA2[0] # 방법2\n\narray([1, 2, 3, 4])\n\n\n(예시3) 1행,3행 추출\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[[0,2],:] # 방법1\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[[0,2]] # 방법2\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n(예시4) 1열 추출\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[:,0] # 방법1, 출력이 이상하게 보이는데?\n\narray([ 1, -1,  5, -5])\n\n\n\nA2[:,[0]] # 방법2\n\narray([[ 1],\n       [-1],\n       [ 5],\n       [-5]])\n\n\n(예시5) 1열,3열 추출\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[:,[0,2]] # 1열, 3열\n\narray([[ 1,  3],\n       [-1, -3],\n       [ 5,  7],\n       [-5, -7]])\n\n\n(예시6) 1행2행, 1열3열 추출 – 삭제하려다가 다시 설명하는 내용\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n헷갈려: 문장이 좀 모호한데 경우1,2중 수행 하라는 것인지 모호하다.\n(경우1) 이러한 숫자들을 뽑으라는 의미인지, (즉 1행 1,3열, 2행 1,3열을 뽑으란 의미인지)\n\\[\\begin{bmatrix}\n1 & | & 3 & | \\\\\n-1 & | & -3 & | \\\\\n| & | & | & | \\\\\n| & | & | & |\n\\end{bmatrix}\\]\n(경우2) 이러한 숫자들을 뽑으란 의미인지, (즉 1행1열, 2행3열을 뽑으란 의미인지)\n\\[\\begin{bmatrix}\n1 & | & | & | \\\\\n| & | & -3 & | \\\\\n| & | & | & | \\\\\n| & | & | & |\n\\end{bmatrix}\\]\n\nA2[0:2, [0,2]] # 경우1이 구현\n\narray([[ 1,  3],\n       [-1, -3]])\n\n\n\nA2[[0,1],[0,2]] # 경우2가 구현\n\narray([ 1, -3])\n\n\n- 인덱싱에 대한 미묘한 차이 \\((\\star)\\)\n관찰: 2차원 array의 인덱싱 결과가 2차원이 나올수도있고, 1차원이 나올수도 있다.\n\nA2[0], A2[0].shape\n\n(array([1, 2, 3, 4]), (4,))\n\n\n\nshape이 (4,)인 ndarray = 길이가 4인 1차원 벡터\n\n\nA2[0:2], A2[0:2].shape\n\n(array([[ 1,  2,  3,  4],\n        [-1, -2, -3, -4]]),\n (2, 4))\n\n\n\nshape이 (2,4)인 ndarray = dim이 2*4인 행렬\n\n\nA2[0:1], A2[0:1].shape\n\n(array([[1, 2, 3, 4]]), (1, 4))\n\n\n\nshape이 (1,4)인 ndarray = dim이 1*4인 행렬\nA2[0:1]은 A2[0]와 같은 코드가 아니었다!!\n\n인덱싱: 결과가 어떻게 나올지 생각해보고 인덱싱 할 것\n(예시1) 한개의 값을 뽑을때 -&gt; 출력을 0차원,1차원,2차원으로 만들 수 있다.\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[0,0] # 출력이 0차원 \n\n1\n\n\n\nA2[[0],0] # 출력이 1차원 \n\narray([1])\n\n\n\nA2[0,[0]] # 출력이 1차원 \n\narray([1])\n\n\n\nA2[0:1,0] # 출력이 1차원 \n\narray([1])\n\n\n\nA2[0,0:1] # 출력이 1차원\n\narray([1])\n\n\n\nA2[0:1,0:1] # 출력이 2차원 \n\narray([[1]])\n\n\n(예시2) 하나의 벡터를 뽑을때 -&gt; 출력을 1차원, 2차원으로 만들 수 있다.\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[:,1] # 출력이 1차원: 출력은 길이가 4인 벡터처럼 해석가능 \n\narray([ 2, -2,  6, -6])\n\n\n\nA2[:,[1]] # 출력이 2차원: 출력을 4*1 매트릭스처럼 해석가능\n\narray([[ 2],\n       [-2],\n       [ 6],\n       [-6]])\n\n\n\nA2[-1,:] # 출력이 1차원: 출력을 길이가 4인 벡터처럼 해석가능 \n\narray([-5, -6, -7, -8])\n\n\n\nA2[[-1],:] # 출력이 2차원: 출력을 1*4 매트릭스처럼 해석가능 \n\narray([[-5, -6, -7, -8]])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-배열의-선언",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-배열의-선언",
    "title": "06wk-1: Numpy (1)",
    "section": "1차원 배열의 선언",
    "text": "1차원 배열의 선언\n- 리스트나 튜플을 선언하고 형변환\n\nnp.array((1,2,3)) # 튜플-&gt;넘파이어레이 \n\narray([1, 2, 3])\n\n\n\nnp.array([1,2,3]) # 리스트 -&gt;넘파이어레이 \n\narray([1, 2, 3])\n\n\n- range()를 이용해서 선언하고 형변환\n\nnp.array(range(10)) # range(10) -&gt; 넘파이어레이 \n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n- np.zeros, np.ones\n\nnp.zeros(3) \n\narray([0., 0., 0.])\n\n\n\nnp.ones(4)\n\narray([1., 1., 1., 1.])\n\n\n- np.linspace\n\nnp.linspace(0,1,12) # 0에서 시작하고 1에서 끝남 (양끝점 모두 포함)\n\narray([0.        , 0.09090909, 0.18181818, 0.27272727, 0.36363636,\n       0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182,\n       0.90909091, 1.        ])\n\n\n\nlen(np.linspace(0,1,12)) # 길이는 12\n\n12\n\n\n- np.arange\n\nnp.arange(5) # np.array(range(5))\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.arange(1,6) # np.array(range(1,6))\n\narray([1, 2, 3, 4, 5])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#reshape-star",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#reshape-star",
    "title": "06wk-1: Numpy (1)",
    "section": "reshape (\\(\\star\\))",
    "text": "reshape (\\(\\star\\))\n- reshape: ndarray의 특수한 기능\n\na=np.array([11,22,33,44,55,66])\na ## 길이가 6인 벡터 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na.reshape(2,3) ## (2,3) matrix 라고 생각해도 무방 \n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\nnote: reshape은 a자체를 변화시키는것은 아님\n\na # a는 그대로 있음 \n\narray([11, 22, 33, 44, 55, 66])\n\n\n\nb= a.reshape(2,3) # a를 reshape한 결과를 b에 저장 \nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\na # a는 여전히 그대로 있음\n\narray([11, 22, 33, 44, 55, 66])\n\n\n- 다시 b를 a처럼 바꾸고 싶다\n\nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\nb.reshape(6) # b는 (2,3) matrix , 그런데 이것을 길이가 6인 벡터로 만들고 싶다. \n\narray([11, 22, 33, 44, 55, 66])\n\n\n- reshape with -1\n\na=np.arange(24) # np.array(range(24))\na\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.reshape(2,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(3,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7],\n       [ 8,  9, 10, 11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(4,-1)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(5,-1)\n\nValueError: cannot reshape array of size 24 into shape (5,newaxis)\n\n\n\na.reshape(6,-1)\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15],\n       [16, 17, 18, 19],\n       [20, 21, 22, 23]])\n\n\n\na.reshape(7,-1)\n\nValueError: cannot reshape array of size 24 into shape (7,newaxis)\n\n\n\na.reshape(8,-1)\n\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11],\n       [12, 13, 14],\n       [15, 16, 17],\n       [18, 19, 20],\n       [21, 22, 23]])\n\n\n\na.reshape(12,-1)\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb= a.reshape(12,-1)\nb\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb.reshape(-1) # b를 다시 길이가 24인 벡터로!\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-배열의-선언-1",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-배열의-선언-1",
    "title": "06wk-1: Numpy (1)",
    "section": "2차원 배열의 선언",
    "text": "2차원 배열의 선언\n\nnp.zeros((3,3))\n\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones((3,3))\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nnp.eye(3)\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\n\nnp.diag([1,2,3,-1])\n\narray([[ 1,  0,  0,  0],\n       [ 0,  2,  0,  0],\n       [ 0,  0,  3,  0],\n       [ 0,  0,  0, -1]])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#랜덤으로-배열-생성",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#랜덤으로-배열-생성",
    "title": "06wk-1: Numpy (1)",
    "section": "랜덤으로 배열 생성",
    "text": "랜덤으로 배열 생성\n\nnp.random.randn(10) # 표쥰정규분포에서 10개를 뽑음 \n\narray([ 0.27184979, -0.4540305 ,  0.24538219, -3.11389327,  1.06478234,\n        0.12051154,  0.01503231, -0.06744028,  2.30710253,  0.78840453])\n\n\n\nnp.random.rand(10) # 0~1사이에서 10개를 뽑음\n\narray([0.67729671, 0.19584606, 0.4564896 , 0.9308976 , 0.49080792,\n       0.03410752, 0.47480477, 0.44519947, 0.20608611, 0.85576604])\n\n\n\nnp.random.randn(4).reshape(2,2) # 표준정규분포에서 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[-0.44348217, -0.04732516],\n       [ 0.75768436, -0.15208593]])\n\n\n\nnp.random.rand(4).reshape(2,2) # 0~1 4개를 뽑고 (2,2) ndarray로 형태변환 \n\narray([[0.03708309, 0.56122376],\n       [0.80934488, 0.65723348]])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#행렬관련기능",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#행렬관련기능",
    "title": "06wk-1: Numpy (1)",
    "section": "행렬관련기능",
    "text": "행렬관련기능\n\nA=np.arange(4).reshape(2,2) \nA\n\narray([[0, 1],\n       [2, 3]])\n\n\n\nA.T # .T는 전치행렬을 구해줌 \n\narray([[0, 2],\n       [1, 3]])\n\n\n\nnp.linalg.inv(A) # np.linalg.inv는 역행렬을 구해주는 함수 \n\narray([[-1.5,  0.5],\n       [ 1. ,  0. ]])\n\n\n\nA @ np.linalg.inv(A) # @는 행렬곱을 수행 \n\narray([[1., 0.],\n       [0., 1.]])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-배열과-연립-1차-방정식",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#차원-배열과-연립-1차-방정식",
    "title": "06wk-1: Numpy (1)",
    "section": "2차원 배열과 연립 1차 방정식",
    "text": "2차원 배열과 연립 1차 방정식\n- 아래의 연립방정식 고려\n\\(\\begin{cases} y+z+w = 3 \\\\ x+z+w = 3 \\\\ x+y+w = 3 \\\\ x+y+z = 3 \\end{cases}\\)\n- 행렬표현?\n\\(\\begin{bmatrix} 0 & 1 & 1 & 1 \\\\ 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} 3 \\\\ 3 \\\\ 3 \\\\ 3 \\end{bmatrix}\\)\n- 풀이\n\nA = np.array([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]])\nA\n\narray([[0, 1, 1, 1],\n       [1, 0, 1, 1],\n       [1, 1, 0, 1],\n       [1, 1, 1, 0]])\n\n\n\nb= np.array([3,3,3,3]).reshape(4,1)\nb\n\narray([[3],\n       [3],\n       [3],\n       [3]])\n\n\n\nnp.linalg.inv(A) @ b \n\narray([[1.],\n       [1.],\n       [1.],\n       [1.]])\n\n\n- 다른풀이\nb를 아래와 같이 만들어도 된다.\n\nb=np.array([3,3,3,3])\nb\n\narray([3, 3, 3, 3])\n\n\n\nb.shape # b.shape은 길이가 1인 튜플로 나온다. \n\n(4,)\n\n\n\nnp.linalg.inv(A) @ b \n\narray([1., 1., 1., 1.])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#의-유연성",
    "href": "PP2023/posts/02_DataScience/2023-04-10-6wk-1.html#의-유연성",
    "title": "06wk-1: Numpy (1)",
    "section": "@의 유연성",
    "text": "@의 유연성\n- 엄밀하게는 아래의 행렬곱이 가능하다.\n\n(2,2) @ (2,1) =&gt; (2,1)\n(1,2) @ (2,2) =&gt; (1,2)\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nA@b\n\narray([[ 5],\n       [11]])\n\n\n\nA.shape, b.shape, (A@b).shape\n\n((2, 2), (2, 1), (2, 1))\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nb@A \n\narray([[ 7, 10]])\n\n\n\nA.shape, b.shape, (b@A).shape\n\n((2, 2), (1, 2), (1, 2))\n\n\n- 당연히 아래는 성립안한다.\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nb@A\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 2 is different from 1)\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nA@b\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1 is different from 2)\n\n\n- 아래는 어떨까? 계산가능할까? \\(\\to\\) 모두 계산가능!\n\n(2,) @ (2,2) = (2,)\n(2,2) @ (2,) = (2,)\n\n\nA = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([1,2]) \nA@b\n\narray([ 5, 11])\n\n\n\nA.shape, b.shape, (A@b).shape \n\n((2, 2), (2,), (2,))\n\n\n\nb를 마치 (2,1)처럼 해석하여 행렬곱하고 결과는 다시 (2,) 로 만든것 같다.\n\n\nb@A\n\narray([ 7, 10])\n\n\n\nA.shape, b.shape, (b@A).shape \n\n((2, 2), (2,), (2,))\n\n\n\n이때는 \\(b\\)를 마치 (1,2)처럼 해석하여 행렬곱하고 결과는 다시 (2,)로 만든것 같다.\n\n- 아래는 어떠할까?\n\nb1 = np.array([1,2,3,4]) \nb2 = np.array([1,2,3,4]) \nb1@b2 \n\n30\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((4,), (4,), ())\n\n\n\n(1,4) @ (4,1) = (1,1) 로 생각\n\n- 즉 위는 아래와 같이 해석하고 행렬곱한것과 결과가 같다.\n\nb1 = np.array([1,2,3,4]).reshape(1,4) \nb2 = np.array([1,2,3,4]).reshape(4,1) \nb1@b2 \n\narray([[30]])\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((1, 4), (4, 1), (1, 1))\n\n\n- 때로는 (4,1) @ (1,4)와 같은 계산결과를 얻고 싶을 수 있는데 이때는 차원을 명시해야함\n\nb1 = np.array([1,2,3,4]).reshape(4,1) \nb2 = np.array([1,2,3,4]).reshape(1,4) \nb1@b2 \n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\n\n참고: 평균을 구하는 신기한 코드\n\nx = np.random.randn(100)\n\n\nnp.array([1/100]*100) @ x  ## x의 평균을 구하라는 의미\n\n0.04274275334613641\n\n\n\nnp.mean(x)\n\n0.04274275334613641"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#개발환경-구축방법이-많은-이유",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#개발환경-구축방법이-많은-이유",
    "title": "05wk-1: 개발환경의 변화",
    "section": "개발환경 구축방법이 많은 이유?",
    "text": "개발환경 구축방법이 많은 이유?\n- 파이썬 개발환경 구축은 수많은 방법이 있다.\n- 이는 마치 라면의 레시피를 검색하면 수많은 방법이 나오는것과 유사함.\n\n방법1: 스프를 먼저 넣고 끓인다음 라면을 넣어야 합니다.\n방법2: 양은냄비에 물넣고 물이 끊으면 라면과 스프를 같이 넣고 마지막에 계란을 넣는다.\n방법3: 먹다남은 삼겹살을 후라이팬에 볶은다음에 물을 붓고 라면을 넣는다.\n방법4: 용기에 라면+스프+뜨거운물 랩을 씌운뒤에 젓가락으로 구멍을 뚫고 전자렌지에 돌린다.\n…\n\n- 우리는 모든 방법을 나열할 순 없지만 모든 방법을 이해할 수 있다. 왜냐하면 라면을 끓이는 공통적인 맥락을 우리는 알고 있으니까\n- 파이썬을 설치하는 다양한 방법 역시 공통맥락을 파악하면 이해하기 쉽다.\n- 저의 목적: 파이썬을 설치하고 실행하는 공통맥락을 설명하고 싶음\n- 설치하는 방법이 다양한 이유? 파이썬이 인기있음 + 다양한 방법을 설치를 하면 각자의 장점이 뚜렷해서"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#python",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#python",
    "title": "05wk-1: 개발환경의 변화",
    "section": "python",
    "text": "python\n- 윈도우에서 anaconda prompt 실행 -&gt; python\n(base) C:\\Users\\python&gt;python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; [1,2,3]+[4]\n[1, 2, 3, 4]\n&gt;&gt;&gt; a=[1,2,3]+[4]\n&gt;&gt;&gt; a\n[1, 2, 3, 4]\n- 2개를 실행할 수도 있음. (두 환경은 각각 서로 독립적인 파이썬, 변수가 공유되지 않음) \\(\\star\\)\n- 아쉬운점: `?list’와 같이 도움말 기능이 동작하지 않음\n&gt;&gt;&gt; ?list\n  File \"&lt;stdin&gt;\", line 1\n    ?list\n    ^\nSyntaxError: invalid syntax\n&gt;&gt;&gt;"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#ipython",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#ipython",
    "title": "05wk-1: 개발환경의 변화",
    "section": "ipython",
    "text": "ipython\n- 윈도우에서 anaconda prompt 실행 -&gt; ipython\n(base) C:\\Users\\python&gt;ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: a=[1,2,3]\n\nIn [2]: a\nOut[2]: [1, 2, 3]\n\nIn [3]: a+[4]\nOut[3]: [1, 2, 3, 4]\n- ?list가 가능\nIn [4]: ?list\nInit signature: list(iterable=(), /)\nDocstring:\nBuilt-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\nType:           type\nSubclasses:     _HashedSeq, StackSummary, DeferredConfigList, SList, _ImmutableLineList, FormattedText, NodeList, _ExplodedList, Stack, _Accumulator, ...\n\n- 색깔이 알록달록해서 문법을 보기 편하다. (구문강조)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-python",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-python",
    "title": "05wk-1: 개발환경의 변화",
    "section": "1세대 프로그래머의 삶 with python",
    "text": "1세대 프로그래머의 삶 with python\n- 1부터 10까지 합을 구하는 프로그램을 만들고 싶음\n- 시도1: python을 키고 아래와 같이 실행\n(base) C:\\Users\\python&gt;python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; total = 0\n&gt;&gt;&gt; for i in range(10):\n...     total=total+i\n...\n&gt;&gt;&gt; total\n45\n&gt;&gt;&gt;\n- 반성: 정답은 55인데 45가 출력되었다! \\(\\to\\) range(10)을 range(1,11)으로 바꿔야겠다!\n- 시도2: range(1,11)을 바꿔야겠다고 생각하고 다시 입력하다가 오타가 발생\n&gt;&gt;&gt; total =0\n&gt;&gt;&gt; for i in range(1,11):\n...     total = totla +i\n...\n\n앗 totla이라고 잘못쳤다.\n\n- 반성: 다음에는 정신을 똑바로 차려야겠다.\n- 불편한점: … 다.."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-ipython",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#세대-프로그래머의-삶-with-ipython",
    "title": "05wk-1: 개발환경의 변화",
    "section": "1세대 프로그래머의 삶 with ipython",
    "text": "1세대 프로그래머의 삶 with ipython\n- ipython을 사용한 프로그래머는 좀 더 상황이 낫다\n(base) C:\\Users\\python&gt;ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: total = 0\n\nIn [2]: for i in range(1,11):\n   ...:     total = total + i\n   ...:\n\nIn [3]: total\nOut[3]: 55\n\n편한점1: 자동으로 들여쓰기가 되어서 편함\n편한점2: 화살표를 이용해서 for문을 쓰는 도중에 위아래로 이동가능\n불편한점1: 화살표로 이동할수는 있는데 마우스로는 이동할 수 없다.\n불편한점2: 내가 작성한 코드를 관리하기 어렵다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델1-원격컴퓨터",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델1-원격컴퓨터",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델1: 원격컴퓨터",
    "text": "모델1: 원격컴퓨터\n- 준비상태\n\n전북대컴퓨터: ipython을 실행 + 이 컴퓨터는 인터넷 연결이 되어있어야함\n우리집노트북: 크롬실행 + 이 컴퓨터도 인터넷이 연결되어 있어야함\n\n- 명령입력\n\n우리집노트북 크롬에서 1+1을 입력하고 쉬프트 엔터를 누름\n\n- 우리집노트북 -&gt; 전북대컴퓨터\n\n우리집 노트북의 내부의 어떤프로그램은 1+1이라는 명령을 복사하여 카카오톡으로 전북대 컴퓨터에 전달\n전북대 컴퓨터의 내부의 어떤프로그램은 1+1이라는 명령을 카톡으로 받아서 그것을 ipython에게 전달\n\n- 전북대컴퓨터 -&gt; 우리집노트북\n\n전북대컴퓨터 내부의 ipython은 2라는 출력결과를 계산함\n전북대컴퓨터 내부의 어떤프로그램은 계산결과를 카톡으로 우리집 노트북에 알려줌\n나는 우리집 노트북에서 계산결과를 받아볼 수 있다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델2-원격컴퓨터-가상컴퓨터",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델2-원격컴퓨터-가상컴퓨터",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델2: 원격컴퓨터 + 가상컴퓨터",
    "text": "모델2: 원격컴퓨터 + 가상컴퓨터\n- 준비상태\n\n성능좋은 전북대 컴퓨터 1개\n내 노트북 1개 (그냥 싸고 가벼운거)\n대학원생 아이패드 1개 (그냥 싸고 가벼운거)\n\n- 아이디어\n\n성능좋은 전북대 컴퓨터를 논리적으로 3개로 분리 \\(\\to\\) 이를 각각 (base) (py39jl17) (py38r40) 컴퓨터라고 하자.\n나는 (py39jl17)에 접속하여 파이썬 3.9와 줄리아 1.7을 설치한뒤 실습한다.\n대학원생은 (py38r40)에 접속하여 파이썬 3.8과 R 4.0을 설치하고 실습한다.\n(base)는 예비용으로 아무것도 설치안한 깨끗한 상태 유지\n내가 뭘 실수해서 (py39jl17)컴퓨터가 망가졌으나 (py38r40)은 아무 타격없다.\n나는 (py39jl17)를 삭제하고 (base)로 부터 다시 새로운 컴퓨터를 복사하여 (py39jl17)을 다시 만든다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델3-가상컴퓨터",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델3-가상컴퓨터",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델3: 가상컴퓨터",
    "text": "모델3: 가상컴퓨터\n- 여러분들 사례\n\n여러분들의 컴퓨터는 (base), (py39) 2개의 컴퓨터로 나누어져 있음\n여러분들이 (py39)에만 주피터랩을 설치\n(py39)에 있는 ipython과 여러분의 크롬창이 서로 통신하면서 실습\n장점: 서로 다른 환경에 서로다른 파이썬과 R등을 설치할 수 있다. \\(\\to\\) 패키지간의 충돌이 최소화 (파이썬 입문 수업을 듣고, 이후에 파이썬을 이용하는 어떤수업을 들음)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델4-클라우드",
    "href": "PP2023/posts/01_PythonBasic/2023-04-03-5wk-1.html#모델4-클라우드",
    "title": "05wk-1: 개발환경의 변화",
    "section": "모델4: 클라우드",
    "text": "모델4: 클라우드\n- 사례1\n\n성능이 그저그런 컴퓨터 27개\n대학원생을 포함하여 쓸 사람은 5명\n한사람당 27/5(=5.4)대의 컴퓨터식 할당\n\n- 사례2: 구글코랩\n\n구글에 여러가지 성능을 가진 컴퓨터가 \\(n\\)대 있음\n\\(m\\)명의 사람이 \\(n\\)대의 컴퓨터에 접속\n적당히 컴퓨터 자언을 분배하여 사용"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#인덱싱고급-스트라이딩",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#인덱싱고급-스트라이딩",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "인덱싱고급 (스트라이딩)",
    "text": "인덱싱고급 (스트라이딩)\n- 스트라이딩 [start:end:step]\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlst[0:9:3]\n\n['a', 'd', 'g']\n\n\n- 생략\n\nlst[0:9]\n#lst[0:9:]\n#lst[0:9:1]\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']\n\n\n\nlst[0::3]\n\n['a', 'd', 'g', 'j']\n\n\n\nlst[:8:3]\n\n['a', 'd', 'g']\n\n\n- 예제1: 짝수/홀수 원소 추출\n아래와 같은 문자열이 있다고 하자.\n\nlst = list('abcdefghijk')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\nindex = 0,2,4, ... 에 해당하는 원소를 출력하라.\n\nlst[::2]\n\n['a', 'c', 'e', 'g', 'i', 'k']\n\n\nindex = 1,4,7 ... 에 해당하는 원소를 출력하라.\n\nlst[1::3]\n\n['b', 'e', 'h', 'k']\n\n\n- 예제2: 세로로..\n\n(예제2를 위한 예비학습) 문자열에서 \\n을 출력하면 출력시 줄바꿈이 일어난다.\n\nprint('1행\\n2행\\n3행')\n\n1행\n2행\n3행\n\n\n예비학습 끝\n\n아래와 같은 문자열이 있다고 하자.\n\ntxt = '너같이사랑스럽고\\n또예쁘고도멋지고\\n속훤히보이는너알\\n았어그동안고마웠\\n지정말정말사랑해'\nprint(txt)\n\n너같이사랑스럽고\n또예쁘고도멋지고\n속훤히보이는너알\n았어그동안고마웠\n지정말정말사랑해\n\n\n위 문자열을 세로로 읽는 코드를 작성하라. (9칸씩 점프하면서 읽으면 된다)\n(풀이)\n\ntxt[::9]\n\n'너또속았지'\n\n\n- step = -1 이면?\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k']\n\n\n\nlst[::-1]\n\n['k', 'j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n- 스트라이딩으로 step = -1 옵션 주기 vs 리스트의 .reverse() 메소드 이용하기\n관찰1: reverse 메소드는 리스트 자체를 변화시킴\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst.reverse()  \nlst\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n관찰2: [::-1]는 리스트는 변화시키지 않음\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n- -step은 쓰기 까다롭다.\n(예제) 처음과 끝을 생략하지 않고 아래와 동일한 효과를 주는 코드를 만들어 보자.\n\nlst = list('abcdefgh')\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n(풀이)\n결국 lst[?:?:-1]의 꼴에서 적당히 ?의 값을 채우면 된다. –&gt; 어려워\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\n\n\nNone\na\nb\nc\nd\ne\nf\ng\nh\nNone\n\n\n\n\n?\n0\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n?\n\n\n\n\nlst[-1:-9:-1] \n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#컴프리헨션-고급-if문이-포함된-컴프리헨션",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#컴프리헨션-고급-if문이-포함된-컴프리헨션",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "컴프리헨션 고급 (if문이 포함된 컴프리헨션)",
    "text": "컴프리헨션 고급 (if문이 포함된 컴프리헨션)\n- 예제: 제곱수중에서 12로 나누어 떨어지는 수만 원소로 가지는 리스트를 만들고 싶다.\n\n제곱수: 1,4,9,16,25,36, …\n12로 나누어 떨어지는 수: 36, …\n\n(예비학습1)\n\n12 % 4 # %는 나머지를 계산하는 연산자, 12를 4로 나누면 나머지가 0\n\n0\n\n\n\n12 % 5 # %는 나머지를 계산하는 연산자, 12를 5로 나누면 나머지가 2\n\n2\n\n\n(예비학습2)\n\na = 2 ## a에 2를 \"대입\" 하라. \n\n\na == 2 # a에 들어있는 값이 2인지 \"test\"하라.\n\nTrue\n\n\n\na == 3 # a에 들어있는 값이 3인지 \"test\"하라.\n\nFalse\n\n\n(예비학습3) if문\n\na= 3 \nif a%2 == 0: \n    a_is='even' ## a%2==0 이 true일 경우만 실행된다. \nelse:\n    a_is='odd' ## a%2==0 이 false일 경우만 실행된다. \n\n\na,a_is\n\n(3, 'odd')\n\n\n(풀이1) - 비어있는 리스트를 만들고 \\(\\to\\) for문 + if문\n\nlst = list()\nfor i in range(1,101): \n    if i**2 % 12 == 0:\n        lst.append(i**2)\n\n\nlst\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]\n\n\n(풀이2) - if문이 포함된 리스트컴프리헨션\n\n[i**2 for i in range(1,101) if i**2 % 12 == 0]\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#함수고급-if문이-포함된-리턴",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#함수고급-if문이-포함된-리턴",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "함수고급 (if문이 포함된 리턴)",
    "text": "함수고급 (if문이 포함된 리턴)\n- 홀수/짝수를 판별하는 함수 만들기 1\n\ndef test(x): \n    if x % 2 == 0: \n        return 'even'\n    else:\n        return 'odd'\n\n\ntest(5)\n\n'odd'\n\n\n(사용)\n\n[test(l) for l in list(range(1,11))]\n\n['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']\n\n\n- 홀수/짝수를 판별하는 함수 만들기 2\n\ndef test(x):\n    return 'even' if x % 2 == 0 else 'odd'\n\n\ntest(4)\n\n'even'\n\n\n(사용)\n\n[test(l) for l in list(range(1,11))]\n\n['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#len함수",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#len함수",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "len함수",
    "text": "len함수\n- 0차원 자료형은 len함수가 동작하지 않음\n\na=1 \nlen(a)\n\nTypeError: object of type 'int' has no len()\n\n\n\na=True\nlen(a)\n\nTypeError: object of type 'bool' has no len()\n\n\n\na=3.14\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nnote: 이것이 어떠한 수학적인 의미를 가지거나 0차원의 본질적진리를 뜻하는 것은 안미. R에서는 1,3.14,TRUE의 길이가 1로 존재함.\n\n- 1차원 자료형은 len함수가 동작\n\na='guebin'\nlen(a)\n\n6\n\n\n\na=[1,2,3,4,5,6]\nlen(a)\n\n6\n\n\n\na=1,2,3,4,5,6 \nlen(a)\n\n6\n\n\n\na=range(10)\nlen(a)\n\n10\n\n\n- 길이가 1인 1차원 자료형과 0차원 자료형은 다른것임\n\na='g'\nlen(a)\n\n1\n\n\n\na=[1]\nlen(a)\n\n1\n\n\n\na=(1,)\nlen(a)\n\n1\n\n\n\na=range(1)\nlen(a)\n\n1\n\n\n- 길이가 0인 1차원 자료형도 존재함\n\na=''\nlen(a)\n\n0\n\n\n\na=[]\nlen(a)\n\n0\n\n\n\na=()\nlen(a)\n\n0\n\n\n\na=range(0)\nlen(a)\n\n0"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#intro-str-list-tuple-정리",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#intro-str-list-tuple-정리",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "intro: str, list, tuple 정리",
    "text": "intro: str, list, tuple 정리\n- str, list, tuple은 모두 시퀀스형이라는 공통점이 있다. \\(\\to\\) 원소의 위치번호로 인덱싱이 가능\n\nlst = [1,2,3,4]\n\n\nlst[0] # 위치번호=0\n\n1\n\n\n\nlst[-1] # 위치번호=-1\n\n4\n\n\n- str, list, tuple은 차이점도 존재함. 잠깐 정리해보자.\n시퀀스형의 카테고리\n\n컨테니어형: list, tuple\n균일형: str\n가변형: list\n불변형: tuple, str\n\n표로 정리하면\n\n\n\n\n컨테니어형\n균일형\n\n\n\n\n가변형\nlist\n.\n\n\n불변형\ntuple\nstr\n\n\n\n- 시퀀스형이 아닌 1차원 자료형도 있을까? 원소의 위치번호로 인덱싱이 불가능한 자료형\n- 왜 이런게 필요할까?\n\n벡터에서 원소를 뽑는것은 정보의 모임에서 정보를 검색하는 것과 같다.\n정보를 순서대로 나열한뒤에 그 순서를 이용하여 검색하는 방법은 유용하다.\n하지만 경우에 따라서는 키워드를 기억해서 그 키워드를 바탕으로 정보에 접근하는 방법이 유용할 수 있다.\n\n카카오톡 대화내용검색\n(상황1) 오늘아침에 와이프가 뭔가를 카톡으로 부탁했었음. 그런데 그 뭔가가 기억안남.\n(상황2) 개강전에 동료교수와 함께 저녁약속을 카톡으로 잡았었음. 그런데 그게 언제인지 기억안남.\n(상황3) 오늘아침 동료교수와 함께 점심약속을 카톡으로 잡았었음. 그런데 그 장소가 기억나지 않음.\n- 순서대로 정리된 자료를 검색할때는 시퀀스형이 유리하다. 그런데 키워드로 검색하고 싶을 경우는 딕셔너리 타입이 유리하다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#선언",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#선언",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "선언",
    "text": "선언\n- 방법1: 가장 일반적\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법2: dict() 이용\n\ndct = dict(guebin=49, hanni=80)\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법3: 중첩된 리스트를 만든 뒤에 형태변환\n\n_lst = [['guebin',49],['hanni',80]]\n_lst \n\n[['guebin', 49], ['hanni', 80]]\n\n\n\ndict(_lst)\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 방법4: 중첩된 튜플을 만든 뒤에 형태변환\n\n_tpl = ('guebin',49), ('hanni',80)\n_tpl\n\n(('guebin', 49), ('hanni', 80))\n\n\n\ndict(_tpl)\n\n{'guebin': 49, 'hanni': 80}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추출",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추출",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "원소추출",
    "text": "원소추출\n- 원소의 위치로 추출할 수 없고, key로 추출해야 한다.\n\ndct = {'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\nguebin의 점수를 추출하고 싶다면?\n\ndct['guebin']\n\n49\n\n\n- 만약에 dict가 아니라 list로 정보를 저장했다면?\n(예제) 아래와 같은 리스트에서 guebin의 점수를 추출하고 싶다면?\n\nlst=[['guebin',49],['hanni',80]]\nlst\n\n[['guebin', 49], ['hanni', 80]]\n\n\n(풀이1)\n\nlst[0][1] # guebin의 점수를 출력하란 의미\n\n49\n\n\n(풀이2) – 진짜 최악\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] == 'guebin']\n\n[49]\n\n\n(풀이3) – 덜 최악\n\n[score for name,score in lst if name == 'guebin']\n\n[49]\n\n\n- ’guebin’의 점수를 추출하는 코드 비교\n\ndct['guebin'] # 코드1: 단순하고, 가독성있음\n\n49\n\n\n\nlst[0][1] # 코드2: 단순하지만, 가독성이 있는건 아님\n\n49\n\n\n\n[lst[i][1] for i in range(len(lst)) if lst[i][0] =='guebin'] # 코드3: 단순하지도 않고, 가독성도 없음.\n\n[49]\n\n\n\n[score for name,score in lst if name=='guebin' ] # 코드4: 단순하지 않지만, 가독성은 있음\n\n[49]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추가-변경-삭제",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#원소추가-변경-삭제",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "원소추가, 변경, 삭제",
    "text": "원소추가, 변경, 삭제\n\ndct={'guebin':49, 'hanni':80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n- 원소에 접근: guebin의 점수 출력\n\ndct['guebin']\n\n49\n\n\n- 추가: hynn학생의 점수를 추가\n\ndct['hynn'] = 99\n\n\ndct\n\n{'guebin': 49, 'hanni': 80, 'hynn': 99}\n\n\n- 변경: hanni의 점수를 변경\n\ndct['hanni'] = 100 \n\n\ndct\n\n{'guebin': 49, 'hanni': 100, 'hynn': 99}\n\n\n- 삭제\n(방법1)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99}\ndel dct['guebin']  \ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n(방법2)\n\ndct={'guebin':49, 'hanni':80, 'hynn':99} \ndct.pop('guebin')\n\n49\n\n\n\ndct\n\n{'hanni': 80, 'hynn': 99}\n\n\n- 참고로 리스트였다면 이러한 삭제작업역시 비효율적이었을 것임\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\nguebin의 점수를 삭제하려면?\n\n[[name,score] for name,score in lst if name != 'guebin']\n\n[['hanni', 80], ['hynn', 99]]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#연산",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#연산",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "연산",
    "text": "연산\n- 하나있어요..\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n'guebin' in dct\n\nTrue\n\n\n\n'hanni' in dct\n\nTrue\n\n\n\n'hynn' in dct\n\nFalse\n\n\n- in은 사실 다른자료형도 가능했음\n(관찰1)\n\n'a' in 'guebin' \n\nFalse\n\n\n\n'b' in 'guebin' \n\nTrue\n\n\n\n'c' in 'guebin' \n\nFalse\n\n\n(관찰2)\n\ntpl = 1,2,3 \ntpl\n\n(1, 2, 3)\n\n\n\n1 in tpl\n\nTrue\n\n\n\n4 in tpl\n\nFalse\n\n\n(관찰3)\n\nlst = [['guebin',49],['hanni',80],['hynn',99]] \nlst\n\n[['guebin', 49], ['hanni', 80], ['hynn', 99]]\n\n\n\n['guebin',49] in lst\n\nTrue\n\n\n- in연산자가 dict형에 사용되면 key를 기준으로 True, False를 판단한다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#딕셔너리-특수기능",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#딕셔너리-특수기능",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "딕셔너리 특수기능",
    "text": "딕셔너리 특수기능\n(pop)\n\ndct = {'guebin':49, 'hanni':80} \ndct.pop('hanni')\ndct\n\n{'guebin': 49}\n\n\n(get)\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\ndct.get('guebin') \n\n49\n\n\n아래와 같은 기능\n\ndct['guebin']\n\n49\n\n\n미묘한 차이점이 존재함\n\ndct['hynn'] # hynn이 없어서 키에러 출력, 그런 key는 없다.. \n\nKeyError: 'hynn'\n\n\n\ndct.get('hynn') # hynn이 없으면 아무것도 출력안함 \n\n(keys,values,items)\n- .keys()는 딕셔너리의 키를 리턴한다.\n\ndct = {'guebin':49, 'hanni':80} \ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n\n_keys=dct.keys()\n_keys\n\ndict_keys(['guebin', 'hanni'])\n\n\n\ntype(_keys) # 리턴된 자료형은 이상한것임\n\ndict_keys\n\n\n\nlist(_keys) # 아무튼 그 이상한 자료형도 리스트화 가능 \n\n['guebin', 'hanni']\n\n\n- .values()는 딕셔너리의 값들을 리턴한다.\n\n_values = dct.values()\n_values \n\ndict_values([49, 80])\n\n\n\ntype(_values)\n\ndict_values\n\n\n\nlist(_values)\n\n[49, 80]\n\n\n- .items()는 딕셔너리의 (키,값)을 리턴한다.\n\n_items = dct.items()\n_items \n\ndict_items([('guebin', 49), ('hanni', 80)])\n\n\n\ntype(_items)\n\ndict_items\n\n\n\nlist(_items)\n\n[('guebin', 49), ('hanni', 80)]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#for문과-dict-star",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#for문과-dict-star",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "for문과 dict (\\(\\star\\))",
    "text": "for문과 dict (\\(\\star\\))\n\ndct = {'guebin': 49, 'hanni': 80}\ndct\n\n{'guebin': 49, 'hanni': 80}\n\n\n(예시1)\n\nfor k in dct.keys():\n    print(k)\n\nguebin\nhanni\n\n\n\nfor k in dct:\n    print(k)\n\nguebin\nhanni\n\n\n\n딕셔너리 그자체도 for문에 넣을 수 있다.\nk에는 value가 삭제되어 들어간다. (즉 key만)\n결과를 보면 dct 대신에 dct.keys()와 list(dct)를 넣었을때와 결과가 같다.\n\n\nNote: list(dct) 하면 key만 리턴된다.\n\n(예시2)\n\nfor v in dct.values():\n    print(v)\n\n49\n80\n\n\n(예시3)\n\nfor i in dct.items():\n    print(i)\n\n('guebin', 49)\n('hanni', 80)\n\n\n(예시4)\n\nfor k,v in dct.items():\n    print(k,v)\n\nguebin 49\nhanni 80\n\n\n(예시5) – {}의 중간고사 점수는 {}점 입니다.\n\nfor name,score in dct.items():\n    print('{}의 중간고사 점수는 {}점 입니다.'.format(name,score))\n\nguebin의 중간고사 점수는 49점 입니다.\nhanni의 중간고사 점수는 80점 입니다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#dict에서-key혹은-value만-뽑아내기",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#dict에서-key혹은-value만-뽑아내기",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "dict에서 key혹은 value만 뽑아내기",
    "text": "dict에서 key혹은 value만 뽑아내기\n- 예제: 아래의 dict에서 key만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct)\n\n['guebin', 'hanni']\n\n\n(풀이2)\n\nlist(dct.keys())\n\n['guebin', 'hanni']\n\n\n(풀이3)\n\n[k for k in dct]\n\n['guebin', 'hanni']\n\n\n(풀이4)\n\n[k for k,v in dct.items()]\n\n['guebin', 'hanni']\n\n\n- 예제: 아래의 dict에서 value만 뽑아내고 싶다.\n\ndct = {'guebin':49, 'hanni':80} \n\n(풀이1)\n\nlist(dct.values())\n\n[49, 80]\n\n\n(풀이2)\n\n[dct[k] for k in dct]\n\n[49, 80]\n\n\n(풀이3)\n\n[v for v in dct.values()]\n\n[49, 80]\n\n\n(풀이4)\n\n[v for k,v in dct.items()]\n\n[49, 80]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-1",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-1",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "바꿔치기 (1)",
    "text": "바꿔치기 (1)\n- 예제1: 아래와 같은 리스트가 있다고 하자.\n\nlst = list('abcd'*2)\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n아래의 규칙에 의하여 lst의 각 원소의 값을 바꾸고 싶다고 하자. 이를 구현하는 코드를 작성하라.\n\n\n\n변환전\n변환후\n\n\n\n\n‘a’\n[1,0,0,0]\n\n\n‘b’\n[0,1,0,0]\n\n\n‘c’\n[0,0,1,0]\n\n\n‘d’\n[0,0,0,1]\n\n\n\nhint: 아래의 dct를 이용할 것\n\nlst = list('abcd'*2)\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\ndct\n\n{'a': [1, 0, 0, 0], 'b': [0, 1, 0, 0], 'c': [0, 0, 1, 0], 'd': [0, 0, 0, 1]}\n\n\n(풀이)\n\n[dct[x] for x in lst]\n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1]]\n\n\n- 예제2: 예제1을 역변환하라.\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\n\n\nlst= [[1, 0, 0, 0],\n      [0, 1, 0, 0],\n      [0, 0, 1, 0],\n      [0, 0, 0, 1],\n      [1, 0, 0, 0],\n      [0, 1, 0, 0],\n      [0, 0, 1, 0],\n      [0, 0, 0, 1]]\nlst \n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1]]\n\n\n(풀이)\n\n[x for l in lst for x,y in dct.items() if y == l]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-2",
    "href": "PP2023/posts/01_PythonBasic/2023-03-27-4wk-1.html#바꿔치기-2",
    "title": "04wk-1: 파이썬의 자료형 (6)",
    "section": "바꿔치기 (2)",
    "text": "바꿔치기 (2)\n- 예제1: 아래와 같은 리스트를 고려하자.\n\nlst = ['딸기','사과','바나나','딸기','사과','오토바이','자동차','버스','기차','오토바이','자동차']\n\n다음의 맵핑규칙에 따라서 위의 리스트의 원소를 바꾸어라.\n\n\n\n변환전\n변환후\n\n\n\n\n딸기\n과일\n\n\n사과\n과일\n\n\n바나나\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n버스\n탈것\n\n\n기차\n탈것\n\n\n\n(풀이)\n\ndct = {'과일':['딸기','사과','바나나'], '탈것':['오토바이','자동차','버스','기차']}\ndct\n\n{'과일': ['딸기', '사과', '바나나'], '탈것': ['오토바이', '자동차', '버스', '기차']}\n\n\n\n[x for l in lst for x,y in dct.items() if l in y]\n\n['과일', '과일', '과일', '과일', '과일', '탈것', '탈것', '탈것', '탈것', '탈것', '탈것']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-원소-추가",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-원소-추가",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 원소 추가",
    "text": "리스트 원소 추가\n(예제) 비어있는 리스트를 만들고 원소 0,1,2를 차례로 추가하여 보자.\n(풀이1) + 연산이용\n\na=[]\na\n\n[]\n\n\n\na= a+[0]\na\n\n[0]\n\n\n\na= a+[1] # a = [0]+[1]\na\n\n[0, 1]\n\n\n\na= a+[2] # a = [0,1] + [2]\na\n\n[0, 1, 2]\n\n\n(풀이2) += 이용\n\na=[]\na+=[0]\na+=[1] \na+=[2] \na\n\n[0, 1, 2]\n\n\n\n반복되는 문자를 제거하고 연산의 순서를 바꾼다.\n\n(풀이3) 리스트 특수기능 .append()를 이용\n\na=[] \n\n\na.append(0)\na.append(1)\na.append(2)\na\n\n[0, 1, 2]\n\n\n- 아래는 불가능하다.\n\na.append(0).append(1).append(2)\n\nAttributeError: 'NoneType' object has no attribute 'append'\n\n\n\na.append(0,1,2)\n\nTypeError: append() takes exactly one argument (3 given)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#a4와-a.append4의-차이점은",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#a4와-a.append4의-차이점은",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "a+[4]와 a.append(4)의 차이점은?",
    "text": "a+[4]와 a.append(4)의 차이점은?\n(관찰1)\n\na=[1,2,3]\na+[4] ## 리스트 a와 리스트 [4]의 연산결과를 알려줘 \n\n[1, 2, 3, 4]\n\n\n\na ## a는 그대로임. 변화없음 \n\n[1, 2, 3]\n\n\n(관찰2)\n\na=[1,2,3]\na.append(4)\n\n\na ## a자체가 변화함 \n\n[1, 2, 3, 4]\n\n\n비슷해보이지만 굉장히 미묘한 차이가 있음\na.append(4): a에 4를 append하라 \\(\\to\\) a가 변함\na+[4]: a와 [4]를 연산하라"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-특수기능",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-특수기능",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 특수기능",
    "text": "리스트 특수기능\n(append)\n\na=[1,2,3,4]\na.append?\n\n\nSignature: a.append(object, /)\nDocstring: Append object to the end of the list.\nType:      builtin_function_or_method\n\n\n\n\na.append(5)\na\n\n[1, 2, 3, 4, 5]\n\n\n(clear)\n\na=[1,2,3,4]\na.clear?\n\n\nSignature: a.clear()\nDocstring: Remove all items from list.\nType:      builtin_function_or_method\n\n\n\n\n\na.clear()\na\n\n[]\n\n\n(copy)\n\na=[1,2,3,4]\na.copy?\n\n\nSignature: a.copy()\nDocstring: Return a shallow copy of the list.\nType:      builtin_function_or_method\n\n\n\n\n\nb=a.copy()\nb\n\n[1, 2, 3, 4]\n\n\n(count)\n\na=['a','a','b','b','b','c']\na.count?\n\n\nSignature: a.count(value, /)\nDocstring: Return number of occurrences of value.\nType:      builtin_function_or_method\n\n\n\n\na.count('a')\n\n2\n\n\n\na.count('b')\n\n3\n\n\n\na.count('c')\n\n1\n\n\n(extend)\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.extend(b)\na\n\n[1, 2, 3, 4, -1, -2, -3, -4]\n\n\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.append(b)\n\n\na\n\n[1, 2, 3, 4, [-1, -2, -3, -4]]\n\n\n(index)\n\na=[11,22,'a',True, 22,'a']\na.index?\n\n\nSignature: a.index(value, start=0, stop=9223372036854775807, /)\nDocstring:\nReturn first index of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.index(11)\n\n0\n\n\n\na.index(22)\n\n1\n\n\n\na.index('a')\n\n2\n\n\n\na.index(True)\n\n3\n\n\n(insert)\n\na=[1,2,3]\na.insert?\n\n\nSignature: a.insert(index, object, /)\nDocstring: Insert object before index.\nType:      builtin_function_or_method\n\n\n\n\na.insert(1,88) \na\n\n[1, 88, 2, 3]\n\n\n(pop)\n\na=['a',1,2,'d']\na.pop?\n\n\nSignature: a.pop(index=-1, /)\nDocstring:\nRemove and return item at index (default last).\nRaises IndexError if list is empty or index is out of range.\nType:      builtin_function_or_method\n\n\n\n\na.pop() # index=-1 이므로 마지막원소가 나타남\n\n'd'\n\n\n\na # a는 마지막 원소가 사라진 상태\n\n['a', 1, 2]\n\n\n\na.pop(0) # index=0 이므로 첫번쨰 원소가 나타남\n\n'a'\n\n\n\na # a에는 첫번째 원소가 사라진 상태\n\n[1, 2]\n\n\n(remove)\n\na=['a',2,3,'d']\na.remove?\n\n\nSignature: a.remove(value, /)\nDocstring:\nRemove first occurrence of value.\nRaises ValueError if the value is not present.\nType:      builtin_function_or_method\n\n\n\n\na.remove('d')\n\n\na\n\n['a', 2, 3]\n\n\n\na.remove('a')\n\n\na\n\n[2, 3]\n\n\n(reverse)\n\na=[1,2,3,4]\na.reverse?\n\n\nSignature: a.reverse()\nDocstring: Reverse *IN PLACE*.\nType:      builtin_function_or_method\n\n\n\n\na.reverse()\na\n\n[4, 3, 2, 1]\n\n\n(sort)\n\na=[1,3,2,4]\na.sort?\n\n\n\nSignature: a.sort(*, key=None, reverse=False)\nDocstring:\nSort the list in ascending order and return None.\nThe sort is in-place (i.e. the list itself is modified) and stable (i.e. the\norder of two equal elements is maintained).\nIf a key function is given, apply it once to each list item and sort them,\nascending or descending, according to their function values.\nThe reverse flag can be set to sort in descending order.\nType:      builtin_function_or_method\n\n\n\n\na.sort()\na\n\n[1, 2, 3, 4]\n\n\n(다른예제들)\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.sort()\na\n\n['b', 'e', 'g', 'i', 'n', 'u']\n\n\n\na.sort(reverse=True)\na\n\n['u', 'n', 'i', 'g', 'e', 'b']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#중첩리스트",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#중첩리스트",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "중첩리스트",
    "text": "중첩리스트\n- 리스트는 리스트를 원소로 받을 수 있으므로 아래와 같이 중첩된 리스트를 만들 수 있다.\n\nA=[[1,2,3],\n   [4,5,6],\n   [7,8,9]]\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n- A는 1차원인 벡터가 아니라 2차원인 매트릭스로 이해할 수 있다. 구체적으로는 아래와 같은 매트릭스로 이해할 수 있다\n$\n\\[\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\n$\n- A에서 (2,1)의 원소를 뽑고싶다 = 4를 뽑고싶다\n\nA[1,0] # R에서는 이게 가능했죠\n\nTypeError: list indices must be integers or slices, not tuple\n\n\n\n실패\n\n\nA[1][0]\n\n4\n\n\n\n성공\n\n- 성공의 이유를 분석해보자.\n\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\nA[1]\n\n[4, 5, 6]\n\n\n\nA[1][0]\n\n4\n\n\n- 매트릭스는 아니지만 매트릭스 같음! - 1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습1-for문-벼락치기",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습1-for문-벼락치기",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "예비학습1: for문 벼락치기",
    "text": "예비학습1: for문 벼락치기\n- 리스트 컴프리헨션을 이해하기 전에 for문에 대하여 알아보자.\n프로그램안에서 반복해서 무엇인가를 하고싶다 \\(\\to\\) for\n\nfor i in [0,1,2,3]: ## 반복실행계획\n    print(i) ## 반복실행할내용, 탭을이용하여 들여쓰기해야한다. \n\n0\n1\n2\n3\n\n\n(예제) 1,2,3,4의 합을 for문을 이용하여 구해보자.\n\n_sum = 0 \n\n\n_sum = 0\nfor i in [1,2,3,4]: \n    _sum = _sum + i \n\n\n_sum\n\n10\n\n\n\n_sum = 0\ni=1 \n_sum = _sum + i ## 1 &lt;= 0+1\ni=2\n_sum = _sum + i ## 3 &lt;= 1+2 \ni=3 \n_sum = _sum + i ## 6 &lt;= 3+3\ni=4\n_sum = _sum + i ## 10 &lt;= 6+4 \n\n\n_sum\n\n10\n\n\n- 궁금: 아래와 같은 코드가 있다고 하자.\nfor i in ????: \n    print(i)\n??? 자리에 올 수 있는건 무엇일까?\n\n대답하기 어려움.\n일단 list는 가능했음.\n\n(예시1)\n\nfor i in [1,2,3,4]: \n    print(i)\n\n1\n2\n3\n4\n\n\n(예시2)\n\nfor i in ['a','b','c','d']: \n    print(i)\n\na\nb\nc\nd\n\n\n(예시3)\n\nfor i in 'abcd': \n    print(i)\n\na\nb\nc\nd\n\n\n(예시4)\n\nfor i in '1': \n    print(i)\n\n1\n\n\n(예시5)\n\nfor i in 1: \n    print(i)\n\nTypeError: 'int' object is not iterable\n\n\n(예시6)\n\nfor i in range(10): \n    print(i)\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습2-range",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#예비학습2-range",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "예비학습2: range",
    "text": "예비학습2: range\n- range(0,10) 선언해보기\n\nrange(0,10)\n\nrange(0, 10)\n\n\n\n이게뭐야?\n\n- 도움말 확인하기\n\n_tmp = range(0,10)\n_tmp?\n\n\nType:        range\nString form: range(0, 10)\nLength:      10\nDocstring:  \nrange(stop) -&gt; range object\nrange(start, stop[, step]) -&gt; range object\nReturn an object that produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).\n\n\n\n\n우리가 아는 범위에서는 모르겠음.. 이런게 있나보다 하고 넘어가야 하겠음\n\n- 형태변환으로 range(0,10)의 느낌 찾기\n\nlist(range(0,10)) # 0을 포함, 10을 미포함 \n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n이게 중요한것임. range(0,10)를 리스트화시키면 [0,1,…,9] 와 같은 리스트를 얻을 수 있음. \\(\\Rightarrow\\) range(0,10)은 [0,1,…,9] 와 “비슷한 것” 임\n\n- range()의 활용\n\nlist(range(10)) # 0은 생략가능\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(2,10)) # 2는 포함, 10은 미포함 \n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(1,10,2)) # 2는 포함, 10은 미포함 \n\n[1, 3, 5, 7, 9]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 컴프리헨션",
    "text": "리스트 컴프리헨션\n- 예제: \\(2^0, 2^1, 2^2, 2^3\\)를 원소로 가지는 리스트를 생성하라.\n(풀이1) 직접입력\n\nx= [2**0, 2**1, 2**2, 2**3] \nx\n\n[1, 2, 4, 8]\n\n\n(풀이2) for문을 이용함\n\nx=[] \nfor i in [0,1,2,3]:\n    x.append(2**i) \n\n\nx\n\n[1, 2, 4, 8]\n\n\n(풀이3) for문을 이용함\n\nx=[] \nfor i in [0,1,2,3]:\n    x = x+[2**i]\n\n\nx\n\n[1, 2, 4, 8]\n\n\n(풀이4) for문을 이용함\n\nx=[] \nfor i in [0,1,2,3]:\n    x += [2**i]\n\n\nx\n\n[1, 2, 4, 8]\n\n\n(풀이5) 리스트컴프리헨션을 이용한 풀이\n\n[2**i for i in [0,1,2,3]]\n\n[1, 2, 4, 8]\n\n\n- 리스트컴프리헨션의 문법 암기방법\n\n집합에서 조건제시법을 연상\n\\(\\{2^0,2^1,2^2,2^3\\}=\\{2^i: i \\in \\{0,1,2,3\\} \\}\\)\n\n- 리스트컴프리헨션이란?\n\n리스트를 매우 효율적으로 만드는 테크닉\nfor문에 비하여 가지고 있는 장점: (1) 코드가 간결하다 (2) 빠르다"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션-연습",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션-연습",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 컴프리헨션 연습",
    "text": "리스트 컴프리헨션 연습\n- 예제1: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['SSSS','PPPP','AAAA','MMMM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n(풀이)\n\n[i*4 for i in 'SPAM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n- 예제2: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1','X2','X3','Y1','Y2','Y3']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이)\n\n[i+j for i in 'XY' for j in '123']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(풀이)\n\n[i+j for i in ['stat', 'math'] for j in '123']\n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n(다른풀이) 참고로 for문을 쓰면 좀 복잡해진다.\n\n_lst = [] \nfor x in ['stat','math']: \n    for y in '123': \n        _lst = _lst + [x+y] \n\n\n_lst \n\n['stat1', 'stat2', 'stat3', 'math1', 'math2', 'math3']\n\n\n- 예제: 리스트컴프리헨션과 문자열 'jbnu'를 이용하여 아래와 같은 리스트를 만들어라.\n\n['j','b','n','u']\n\n['j', 'b', 'n', 'u']\n\n\n(다른풀이) 아래와 같이 풀면 된다는것은 알고 있음\n\nlist('jbnu')\n\n['j', 'b', 'n', 'u']\n\n\n(풀이)\n\n[i for i in 'jbnu']\n\n['j', 'b', 'n', 'u']\n\n\n- 예제: 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라.\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n\n(풀이)\n\n['X'+str(i) for i in range(1,13)]\n#['X'+str(i) for i in list(range(1,13))]\n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션과-for문의-미묘한-차이",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-컴프리헨션과-for문의-미묘한-차이",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 컴프리헨션과 for문의 미묘한 차이",
    "text": "리스트 컴프리헨션과 for문의 미묘한 차이\n(경우1)\n\nx=777 \nlst = [] \nfor x in 'jbnu': \n    lst = lst + [x]\nlst    \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n'u'\n\n\n(경우2)\n\nx=777\nlst = [x for x in 'jbnu'] \nlst \n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n777\n\n\n\n진짜 미묘하게 다르죠?"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-vs-튜플",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#리스트-vs-튜플",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "리스트 vs 튜플",
    "text": "리스트 vs 튜플\n- 컨테이너형타입이라는 점, 그리고 연산 및 인덱싱을 하는 방법은 리스트와 같음 - 차이점1: [] 대신에 ()를 사용한다. - 차이점2: 불변형이다. (원소의 값을 바꿀 수 없음) - 차이점3: 하나의 원소를 선언할 때는 (1,)와 같이 해야 한다. - 차이점4: 의미가 명확할때는 튜플의 ()를 생략가능하다.\n- 컨테이너형이라는 것이 무슨의미?\n\na=(4,6,'pencil', 3.2+4.6j, [3,4]) \n\n\ntype(a[2])\n\nstr\n\n\n\ntype(a[3])\n\ncomplex\n\n\n- 불변형이라는 것은 무슨의미?\n\na[2] = 'Pencil'\n\nTypeError: 'tuple' object does not support item assignment\n\n\n참고로 a를 튜플이 아니라 리스트로 선언하면 값이 잘 바뀐다.\n\na=[4,6,'pencil', 3.2+4.6j, [3,4]]\n\n\na[2]\n\n'pencil'\n\n\n\na[2]='Pencil'\n\n\na\n\n[4, 6, 'Pencil', (3.2+4.6j), [3, 4]]\n\n\n- 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함.\n\n[1]+[2,3,4]\n\n[1, 2, 3, 4]\n\n\n\n(1,)+(2,3,4)\n\n(1, 2, 3, 4)\n\n\n- 마지막차이점! 의미가 명확할때 튜플의 괄호는 생략가능하다. (이게 중요합니다)\n\na=1,2\na\n\n(1, 2)\n\n\n의미가 명확할때 생략해야함\n\n1,2 + 3,4,5 \n\n(1, 5, 4, 5)\n\n\n\n(1,2) + (3,4,5) \n\n(1, 2, 3, 4, 5)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#선언",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#선언",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "선언",
    "text": "선언\n- 소괄호를 이용\n\na=(1,2,3)\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 생략가능하다는 점이 포인트\n\na=1,2,3\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 원소가 하나인 튜플을 만들고 싶다면?\n\na=(1,)\na\n\n(1,)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#연산",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#연산",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "연산",
    "text": "연산\n- 리스트와 동일\n\n(1,2)+(3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n(1,2)*2\n\n(1, 2, 1, 2)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#인덱싱",
    "href": "PP2023/posts/01_PythonBasic/2023-03-20-3wk-1.html#인덱싱",
    "title": "03wk-1: 파이썬의 자료형 (4)",
    "section": "인덱싱",
    "text": "인덱싱\n- 리스트와 동일\n\na=(1,2,3,-4,-5)\na\n\n(1, 2, 3, -4, -5)\n\n\n\na[-1]\n\n-5\n\n\n\na[-3:]\n\n(3, -4, -5)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#선언",
    "href": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#선언",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "선언",
    "text": "선언\n- 예시1\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n- 예시2\n\na=\"guebin\"\n\n\na\n\n'guebin'"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#연산",
    "href": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#연산",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "연산",
    "text": "연산\n- 더하기(+)연산\n\na='X'\nb='2'\n\n\nc=a+b\nc\n\n'X2'\n\n\n- 빼기(-)연산\n\na='X2'\nb='2'\na-b\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\n이런건 없다.\n\n- 곱하기(*)연산\n\na='X'\n\n\na+a+a\n\n'XXX'\n\n\n\na*3 # a*3 = a+a+a = 'X'+'X+'X'\n\n'XXX'\n\n\n아래도 가능하다.\n\n3*a\n\n'XXX'\n\n\n그리고 아래도 가능하다.\n\na='X'\nb=3 \na*b\n\n'XXX'\n\n\n대신에 의미상 맞지 않는 것은 수행되지 않고 에러가 난다.\n\na='X'\nb='Y'\na+b\n\n'XY'\n\n\n\na*b\n\nTypeError: can't multiply sequence by non-int of type 'str'\n\n\n- 나눗셈(/)연산\n\na='XX'\n\n\na/2\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\n이런건 없다.."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#인덱싱",
    "href": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#인덱싱",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "인덱싱",
    "text": "인덱싱\n- str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하면 된다.\n\na='guebin'\n\n\na\n\n'guebin'\n\n\n\n6개의 칸에 글씨가 하나씩 들어가 있음.\n\n- 대괄호 []안에 숫자를 넣는 방식으로 벡터의 원소를 호출할 수 있다. (주의: 인덱스가 0부터 시작함)\n\na[0] #첫번째원소\n\n'g'\n\n\n\na[1] #두번째원소 \n\n'u'\n\n\n마지막원소는 -1로 호출할 수도 있다.\n\na[-1]\n\n'n'\n\n\n마지막에서 2번째 원소는 -2로 호출가능하다.\n\na[-2]\n\n'i'\n\n\n- 요약하면 아래와 같은 방식으로 호출가능함.\n\n\n\ng\nu\ne\nb\ni\nn\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n0\n-5\n-4\n-3\n-2\n-1\n\n\n\n\na[4]\n\n'i'\n\n\n\na[-2]\n\n'i'\n\n\n\na[-4]\n\n'e'\n\n\n- :을 이용하여 여러개의 원소를 호출할 수 있음.\n\na='guebin'\n\n\na[0:3] # a[0],a[1],a[2],a[3]이 아니라 a[0],a[1],a[2]까지만 뽑힌다. 즉 마지막의 3은 호출되지 않는다. \n\n'gue'\n\n\n\na[1:3] # a[1], a[2] 만 호출 // start=1,  stop=3 \n\n'ue'\n\n\nindex=1부터 시작해서 마지막원소까지 호출하려면?\n\na='guebin'\n\n\na[5] # guebin의 마지막원소 'n'이 출려 \n\n'n'\n\n\n\na[1:5] # 5는 포함되지 않으므로 틀림\n\n'uebi'\n\n\n\na[1:6] # 정답\n\n'uebin'\n\n\n안 헷갈리는 방법은 없을까? 생략한다.\n\na[1:]\n\n'uebin'\n\n\n- 생략의 응용1\n\na='k-pop' \na\n\n'k-pop'\n\n\n\na[2:5]\n\n'pop'\n\n\n\na[2:]\n\n'pop'\n\n\n- 생략의 응용2\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:2] # a[0],a[1]\n\n'k-'\n\n\n\na[:2] # a[0],a[1] \n\n'k-'\n\n\n- 생략의 응용3\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:5] # a[0],...,a[4]\n\n'k-pop'\n\n\n\na[:]\n\n'k-pop'"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#str-특수기능",
    "href": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#str-특수기능",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "str 특수기능",
    "text": "str 특수기능\n- 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다.\n\na='ABCD' # a라는 변수는 'ABCD'라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다. \na\n\n'ABCD'\n\n\n\na.lower() # a.lower()를 쓰면 a의 모든 문자를 소문자로 바꾸는 기능을 제공, lower(a)라고 읽자!\n\n'abcd'\n\n\n여기에서 lower()는 문자열에 특화된 기능임. 따라서 당연히 아래는 불가능\n\na=3.14\na.lower() # lower(a)\n\nAttributeError: 'float' object has no attribute 'lower'\n\n\n- 자료형에 특화된 기능(=함수)을 확인하는 방법? a.+ tab 으로 목록 확인 가능\n\na='guebin'\n\n\na.upper?\n\n\nSignature: a.upper()\nDocstring: Return a copy of the string converted to uppercase.\nType:      builtin_function_or_method\n\n\n\n\na.upper() # upper(a) \n\n'GUEBIN'\n\n\n\na.capitalize() # capitalize(a) \n\n'Guebin'\n\n\n\na='asdf'\n\n- 문자열에 대한 다른 내용들은 추후에 다루겠음.\n- 마음의눈: a.f() 형태를 읽는 팁\n\na.f()는 f(a)로 생각하면 편리함.\na.f(2)는 f(a,2)로 생각하면 편리함.\n이런점에서 R %&gt;% 연산자와 비슷하다고 생각할 수 있다. (약간 다르긴함)\n\n- 사실 .은 좀 더 다양한 상황에서 쓰일 수 있다. 변수이름.함수이름() 의 형태가 아니라\n\n패지키이름.함수이름()\n패키지이름.변수이름\n패키지이름.패키지이름.함수이름()\n…\n\n와 같이 다양한 형태가 가능하다. 근본적인 공통점은 .을 기준으로 상위개념.하위개념 으로 이해하는 것이 좋다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#len",
    "href": "PP2023/posts/01_PythonBasic/2023-03-13-2wk-1.html#len",
    "title": "02wk-1: 파이썬의 자료형 (2)",
    "section": "len",
    "text": "len\n- len함수 소개: 원소의 갯수를 알려주는 함수.\n\na='ABCD' \nlen(a)\n\n4\n\n\n- 참고: len은 0차원 변수형에서는 동작하지 않고 1차원 변수형에서만 동작한다.\n(0차원) len 함수가 동작하지 않음.\n\na=3.14\n\n\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nb=True\n\n\nlen(b)\n\nTypeError: object of type 'bool' has no len()\n\n\n(1차원) len 함수가 잘 동작함.\n\na='3.14'\nlen(a)\n\n4\n\n\n\nb=[1,2,3]\n\n\nlen(b)\n\n3"
  },
  {
    "objectID": "PP2023/index.html",
    "href": "PP2023/index.html",
    "title": "파이썬 프로그래밍 (2023)",
    "section": "",
    "text": "질문하는 방법\n\n카카오톡: 질문하러 가기 // 학기종료이후 폐쇄함\n이메일: guebin@jbnu.ac.kr\n직접방문: 자연과학대학 본관 205호\nZoom: 카카오톡이나 이메일로 미리 시간을 정할 것\nLMS:\n\n강의노트\n\n\n\n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nJun 21, 2023\n\n\n13wk-1: 깊은복사와 얕은복사\n\n\n최규빈 \n\n\n\n\nJun 20, 2023\n\n\n15wk-2: 기말고사 풀이\n\n\n최규빈 \n\n\n\n\nJun 19, 2023\n\n\n15wk-2: 기말고사\n\n\n최규빈 \n\n\n\n\nJun 12, 2023\n\n\n15wk-1: 클래스공부 5단계 – 상속\n\n\n최규빈 \n\n\n\n\nJun 7, 2023\n\n\n14wk-2: 클래스공부 4단계 – 파이썬의 비밀 (3)\n\n\n최규빈 \n\n\n\n\nJun 5, 2023\n\n\n14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)\n\n\n최규빈 \n\n\n\n\nMay 31, 2023\n\n\n13wk-2: 클래스공부 4단계 – 파이썬의 비밀 (1)\n\n\n최규빈 \n\n\n\n\nMay 24, 2023\n\n\n12wk-2: 클래스공부 3단계 – 문제연습\n\n\n최규빈 \n\n\n\n\nMay 22, 2023\n\n\n12wk-1: 클래스공부 2단계 – __init__\n\n\n최규빈 \n\n\n\n\nMay 17, 2023\n\n\n11wk-2: 클래스공부 1단계 – 메소드\n\n\n최규빈 \n\n\n\n\nMay 15, 2023\n\n\n11wk-1: 밈과 클래스 (2)\n\n\n최규빈 \n\n\n\n\nMay 10, 2023\n\n\n10wk-2: 밈과 클래스 (1)\n\n\n최규빈 \n\n\n\n\nMay 8, 2023\n\n\n10wk-1: 중간고사\n\n\n최규빈 \n\n\n\n\nMay 1, 2023\n\n\n09wk-1: Numpy와 Pandas의 활용\n\n\n최규빈 \n\n\n\n\nApr 26, 2023\n\n\n08wk-2: Pandas (2)\n\n\n최규빈 \n\n\n\n\nApr 24, 2023\n\n\n08wk-1: Pandas (1)\n\n\n최규빈 \n\n\n\n\nApr 19, 2023\n\n\n07wk-2: Numpy 활용 (2)\n\n\n최규빈 \n\n\n\n\nApr 17, 2023\n\n\n07wk-1: Numpy 활용 (1)\n\n\n최규빈 \n\n\n\n\nApr 12, 2023\n\n\n06wk-2: Numpy (2)\n\n\n최규빈 \n\n\n\n\nApr 10, 2023\n\n\n06wk-1: Numpy (1)\n\n\n최규빈 \n\n\n\n\nApr 5, 2023\n\n\n05wk-2: 모듈, 패키지, 라이브러리\n\n\n최규빈 \n\n\n\n\nApr 3, 2023\n\n\n05wk-1: 개발환경의 변화\n\n\n최규빈 \n\n\n\n\nMar 29, 2023\n\n\n04wk-2: 파이썬의 자료형 (7)\n\n\n최규빈 \n\n\n\n\nMar 27, 2023\n\n\n04wk-1: 파이썬의 자료형 (6)\n\n\n최규빈 \n\n\n\n\nMar 22, 2023\n\n\n03wk-2: 파이썬의 자료형 (5)\n\n\n최규빈 \n\n\n\n\nMar 20, 2023\n\n\n03wk-1: 파이썬의 자료형 (4)\n\n\n최규빈 \n\n\n\n\nMar 15, 2023\n\n\n02wk-2: 파이썬의 자료형 (3)\n\n\n최규빈 \n\n\n\n\nMar 13, 2023\n\n\n02wk-1: 파이썬의 자료형 (2)\n\n\n최규빈 \n\n\n\n\nMar 7, 2023\n\n\n01wk-2: 파이썬의 자료형 (1)\n\n\n최규빈 \n\n\n\n\nMar 6, 2023\n\n\n01wk-1: 강의소개\n\n\n최규빈 \n\n\n\n\nJun 6, 2022\n\n\n참고자료: 2022-06-final\n\n\n최규빈 \n\n\n\n\nApr 1, 2022\n\n\n참고자료: 2022-04-mid\n\n\n최규빈 \n\n\n\n\nJun 6, 2021\n\n\n참고자료: 2021-06-final\n\n\n최규빈 \n\n\n\n\nApr 1, 2021\n\n\n참고자료: 2021-04-mid\n\n\n최규빈 \n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/230912.out.html",
    "href": "posts/230912.out.html",
    "title": "2023-09-12 – Quarto Blog 만들기",
    "section": "",
    "text": "최규빈\n2023-09-12\n\n0. 꼭 해야할까?\n1. https://www.youtube.com/watch?v=SZcjvjrdomE\n\nrepo도 확인함\ncommit 은 거의 기본임\n\n2. https://www.youtube.com/watch?v=Yc56NpYW1DM&t=23s\n\n3:00 - 3:40: 깃헙과 블로그가 중요함 / commit 을 빼곡하게, repo 확인\n3:40 - : 블로그\n4:00 - : commit 링크가 없으면 X, 필수라고 해서 넣은 느낌 (영상에서는 필수 아니라고 하지만 반 필수임)\n\n\n\n1. 블로그 생성\n- 깃헙레포지토리로 이동한뒤에 아래의 명령어를 입력:\nquarto create-project --type website --template blog\n위의 명령어를 실행하면 여러가지 설정파일들이 생성된다.\n- 블로그 publish\nquarto publish gh-pages\n- 깃헙으로 이동하여 확인\n\nwindow는 자동으로 퍼블리쉬 된다.\nmac에서는 수동으로 gh-pages로 바꿔야함.\n\n\n\n2. 새로운 포스트 생성\n- 아무 노트북이나 만들어본다. (혹은 이미 만들어진 노트북을 넣어본다.)\n\n예시1: https://guebin.github.io/PP2023/ 에서 아무거나 다운로드\n예시2: git clone https://github.com/guebin/PP2023.git\n\n- 노트북을 posts 폴더에 넣는다.\n- 아래를 통하여 preview 이미지를 확인.\nquarto preview \n- 퍼블리쉬\nquarto publish --no-prompt\n\n\n3. 블로그 설정변경\n- index.qmd 메인에 보이는 화면\n---\ntitle: \"기계학습활용 (2023)\"\nlisting:\n  contents: posts\n  sort: \"date\"\n  type: table\n  categories: true\n  sort-ui: false\n  filter-ui: false\npage-layout: full\ntitle-block-banner: false\n---\n\n**질문하는 방법**\n\n- 카카오톡: [질문하러 가기](http://pf.kakao.com/_skxnxdG/chat) // 학기종료이후 폐쇄함\n- 이메일: &lt;guebin@jbnu.ac.kr&gt;\n- 직접방문: 자연과학대학 본관 205호 \n- Zoom: *카카오톡이나 이메일로 미리 시간을 정할 것*\n- LMS쪽지: &lt;https://ieilms.jbnu.ac.kr/&gt;\n\n**references**\n\n**공지사항** \n\n- 강의영상의 경우 시간이 지나면 고화질로 시청할 수 있습니다. (인코딩중에는 유튜브에서 저화질로 송출됩니다)\n- **9월7일 대면수업**: Quarto를 이용한 기술블로그 만들기 + 타이타닉 자료에 대한 발표/토론 \n\n**강의노트** \n- _quarto.yml\nproject:\n  type: website\n\nwebsite:\n  title: \"MP2023\"\n  navbar:\n    right:\n      - icon: github    \n        href: https://github.com/guebin/MP2023\n      - icon: youtube\n        href: https://www.youtube.com/channel/UCQk9RyBNgXc7ORIsYlOfQrg/playlists?view=50&sort=dd&shelf_id=2\nformat:\n  html:\n    theme: cosmo\n    css: styles.css\n- posts 폴더에서 _metadata.yml\n# options specified here will apply to all posts in this folder\n\n# freeze computational output\n# (see https://quarto.org/docs/projects/code-execution.html#freeze)\nexecute:\n  freeze: auto  # re-render only when source changes\n\n# Enable banner style title blocks\ntitle-block-banner: false\n\nnotebook-links: true\ncap-location: margin\nreference-location: margin\ncitation-location: margin\n\nformat:\n  html:\n    toc: true\n    code-fold: false\n    code-line-numbers: false\n    code-copy: true\n  ipynb: default\n- 기타 자세한 옵션은 아래에서 뒤져볼 것\n\nref: https://quarto.org/\n\n- 다른 사람들의 블로그 소개 (설정파일 구경용)\n\nhttps://seoyeonc.github.io/sy_hub/\nhttps://boram-coco.github.io/coco/\nhttps://pinkocto.github.io/Quarto-Blog/\nhttps://pinkocto.github.io/noteda/\n\n\n\n4. 이해\n- 아래를 입력\ngit add .\ngit commit -m .\ngit switch gh-pages\n\n폴더내용 확인\n\n- 다시 원래대로 돌아오기\ngit switch main\n- quarto publish 의 역할\n\n.ipynb 파일을 어떠한 규칙에 따라 변환하여 .html파일로 바꿈\n바꾼 파일들을 gh-pages라는 이름의 브랜치로 옮김\ngh-pages 브랜치를 github 으로 push\n이후에는 github이 알아서 gh-pages의 내용을 웹이 뿌려줌.\n\n- 블로그가 깨졌을때 대응하는 방법\n\ngh-pages로 이동하여 모든 파일 및 폴더 삭제\ngit add ., git commit -m . git push를 순서대로 입력\n다시 main으로 돌아와서 quarto publish --no-prompt 입력\n\n\n\n5. 추천하는 루틴\n- 정상적인 상황\ngit add .\ngit commit -m .\ngit push \nquarto publish --no-prompt\n- 포스트 제목 등, 블로그의 수정사항이 바르게 반영되지 않는 상황\ngit add .\ngit commit -m .\ngit switch gh-pages\nrm -rf * # 윈도우의 경우 수동으로 모든 파일 삭제\ngit add .\ngit commit -m .\ngit switch main \ngit push \nquarto publish --no-prompt"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mpchacha",
    "section": "",
    "text": "2023-09-12 – Quarto Blog 만들기\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\n13wk-1: 깊은복사와 얕은복사\n\n\n\n\n\n\n\n\n\n\n\n\nJun 21, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n15wk-2: 기말고사 풀이\n\n\n\n\n\n\n\n\n\n\n\n\nJun 20, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n15wk-2: 기말고사\n\n\n\n\n\n\n\n\n\n\n\n\nJun 19, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n15wk-1: 클래스공부 5단계 – 상속\n\n\n\n\n\n\n\n\n\n\n\n\nJun 12, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n14wk-2: 클래스공부 4단계 – 파이썬의 비밀 (3)\n\n\n\n\n\n\n\n\n\n\n\n\nJun 7, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)\n\n\n\n\n\n\n\n\n\n\n\n\nJun 5, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n13wk-2: 클래스공부 4단계 – 파이썬의 비밀 (1)\n\n\n\n\n\n\n\n\n\n\n\n\nMay 31, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n12wk-2: 클래스공부 3단계 – 문제연습\n\n\n\n\n\n\n\n\n\n\n\n\nMay 24, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n12wk-1: 클래스공부 2단계 – __init__\n\n\n\n\n\n\n\n\n\n\n\n\nMay 22, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n11wk-2: 클래스공부 1단계 – 메소드\n\n\n\n\n\n\n\n\n\n\n\n\nMay 17, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n11wk-1: 밈과 클래스 (2)\n\n\n\n\n\n\n\n\n\n\n\n\nMay 15, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n10wk-2: 밈과 클래스 (1)\n\n\n\n\n\n\n\n\n\n\n\n\nMay 10, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n10wk-1: 중간고사\n\n\n\n\n\n\n\n\n\n\n\n\nMay 8, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n09wk-1: Numpy와 Pandas의 활용\n\n\n\n\n\n\n\n\n\n\n\n\nMay 1, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n08wk-2: Pandas (2)\n\n\n\n\n\n\n\n\n\n\n\n\nApr 26, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n08wk-1: Pandas (1)\n\n\n\n\n\n\n\n\n\n\n\n\nApr 24, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n07wk-2: Numpy 활용 (2)\n\n\n\n\n\n\n\n\n\n\n\n\nApr 19, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n07wk-1: Numpy 활용 (1)\n\n\n\n\n\n\n\n\n\n\n\n\nApr 17, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n06wk-2: Numpy (2)\n\n\n\n\n\n\n\n\n\n\n\n\nApr 12, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n06wk-1: Numpy (1)\n\n\n\n\n\n\n\n\n\n\n\n\nApr 10, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n05wk-2: 모듈, 패키지, 라이브러리\n\n\n\n\n\n\n\n\n\n\n\n\nApr 5, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n05wk-1: 개발환경의 변화\n\n\n\n\n\n\n\n\n\n\n\n\nApr 3, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n04wk-2: 파이썬의 자료형 (7)\n\n\n\n\n\n\n\n\n\n\n\n\nMar 29, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n04wk-1: 파이썬의 자료형 (6)\n\n\n\n\n\n\n\n\n\n\n\n\nMar 27, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n03wk-2: 파이썬의 자료형 (5)\n\n\n\n\n\n\n\n\n\n\n\n\nMar 22, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n03wk-1: 파이썬의 자료형 (4)\n\n\n\n\n\n\n\n\n\n\n\n\nMar 20, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n02wk-2: 파이썬의 자료형 (3)\n\n\n\n\n\n\n\n\n\n\n\n\nMar 15, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n02wk-1: 파이썬의 자료형 (2)\n\n\n\n\n\n\n\n\n\n\n\n\nMar 13, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n01wk-2: 파이썬의 자료형 (1)\n\n\n\n\n\n\n\n\n\n\n\n\nMar 7, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n01wk-1: 강의소개\n\n\n\n\n\n\n\n\n\n\n\n\nMar 6, 2023\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n참고자료: 2022-06-final\n\n\n\n\n\n\n\n\n\n\n\n\nJun 6, 2022\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n참고자료: 2022-04-mid\n\n\n\n\n\n\n\n\n\n\n\n\nApr 1, 2022\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n참고자료: 2021-06-final\n\n\n\n\n\n\n\n\n\n\n\n\nJun 6, 2021\n\n\n최규빈\n\n\n\n\n\n\n  \n\n\n\n\n참고자료: 2021-04-mid\n\n\n\n\n\n\n\n\n\n\n\n\nApr 1, 2021\n\n\n최규빈\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "PP2023/about.html",
    "href": "PP2023/about.html",
    "title": "About",
    "section": "",
    "text": "파이썬프로그래밍\nguebin@jbnu.ac.kr\n자연과학대학 본관 205호"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-08-1wk-2.html",
    "href": "PP2023/posts/01_PythonBasic/2023-03-08-1wk-2.html",
    "title": "01wk-2: 파이썬의 자료형 (1)",
    "section": "",
    "text": "강의영상\n\nyoutube: https://youtube.com/playlist?list=PLQqh36zP38-w17wsQ3-WMvDNNWEX52GOX\n\n\n\nIntro\n- 파이썬의 기본자료형은 int, float, bool, str, list, tuple, dict, set 등이 있다.\n\n0차원 자료형: int, float, bool\n1차원 자료형: str, list, tuple, dict, set\n\n\n\nint, float, bool\n- int형\n\na=100\n\n\ntype(a)\n\nint\n\n\n- float형\n\na=1.2*3\na\n\n3.5999999999999996\n\n\n\ntype(a)\n\nfloat\n\n\n\na?\n\n\nType:        float\nString form: 3.5999999999999996\nDocstring:   Convert a string or number to a floating point number, if possible.\n\n\n\n\n- bool형\n\na=True ## 숫자1으로 생각할 수 있음 \nb=False ## 숫자0으로 생각할 수 있음\n\n\ntype(a)\n\nbool\n\n\n\ntype(b)\n\nbool\n\n\n\na?\n\n\nType:        bool\nString form: True\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\n\nb?\n\n\nType:        bool\nString form: False\nDocstring:  \nbool(x) -&gt; bool\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.\n\n\n\n\n- bool형의 연산\n\na=True ## 1\nb=False ## 0 \n\n\na+b\n\n1\n\n\n\na*b \n\n0\n\n\n- complex형\n\na=1+2j\nb=2-2j\n\n\ntype(a)\n\ncomplex\n\n\n\ntype(b)\n\ncomplex\n\n\n\na?\n\n\nType:        complex\nString form: (1+2j)\nDocstring:  \nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\n\n\n\n\n\nb?\n\n\nType:        complex\nString form: (2-2j)\nDocstring:  \nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.\n\n\n\n\n\nc=a+b\n\n\nc\n\n(3+0j)\n\n\n- 형태변환: float \\(\\to\\) int\n(예시1)\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\ntype(a)\n\nint\n\n\n(예시2) 이경우는 정보의 손실이 발생\n\na=3.14 \nint(a)\n\n3\n\n\n- 형태변환: int \\(\\to\\) float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool \\(\\to\\) int/float, int/float \\(\\to\\) bool\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1 \nbool(a)\n\nTrue\n\n\n\na=0\nbool(a)\n\nFalse\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse\n\n\n- 이상한 형태변환도 가능하다. (이런것도 바꿔주나 싶은것도 바꿔줌)\n\nbool(-3.14)\n\nTrue\n\n\n\n저는 이런 코드를 의도적으로 사용하지 않아요..\n\n\nint(3.14)\n\n3\n\n\n- 형태변환이 항상가능한것도 아님\n\nfloat(3+0j) # 사실상 3+0j=3 이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 변환불가능하다. \n\nTypeError: can't convert complex to float\n\n\n- 암묵적형변환 (implicit)\n(예비학습) implicit의 의미\n\n추운날씨 -&gt; 보일러좀 틀자! (explicit) / 오늘 날씨 좀 추운 것 같지 않아? (implicit)\n짜장면 먹을래? -&gt; 싫어! (explicit) / 난 어제 짜장면 먹었는데.. (implicit)\n\n(예제)\n\nTrue * 1 # 1을 곱할건데 너 계속 True로 있을꺼야? \n\n1\n\n\n\n1 * 1.0 # 1.0을 곱할건데 너 계속 int로 있을꺼야? \n\n1.0\n\n\n\nTrue+True # +연산을 할건데 계속 True로 있을꺼야? \n\n2\n\n\n\n\n숙제\n아래 강의노트의 영상 1-3을 참고하여 주피터랩을 설치하고 설치성공한 화면을 스크린샷으로 LMS에 제출\nhttps://guebin.github.io/IP2022/2022/03/07/(1주차)-3월7일.html"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#선언",
    "href": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#선언",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "선언",
    "text": "선언\n- 리스트의 선언\n\na= [1,2,3,22] \n\n- 비어있는 리스트의 선언\n\na= []\na\n\n[]\n\n\n\na= list()\na\n\n[]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#연산",
    "href": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#연산",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "연산",
    "text": "연산\n- 더하기연산\n\n[1,2]+[-3,4,5]\n\n[1, 2, -3, 4, 5]\n\n\n\n우리의 예상과 다른 결과가 나옴 \\(\\to\\) 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있지 않음.\n\n- 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음.\n\n[1,2,3,4,5] + 1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n- 뺄셈은 정의되지 않음\n\na= [1,2,1,2]\na-[1,2]\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n- 곱하기는 정의가능\n\n[1,2]*3\n\n[1, 2, 1, 2, 1, 2]\n\n\n- 나눗셈은 정의되지 않음\n\n[1,2,1,2,1,2] /3\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n- 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄셈과 나눗셈이 원소의 삭제를 의미하는것은 아님\n- 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, * 를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까?\n(예제)\n\na=[1,2]\nb=[3,4]\n\na+b = [4,6] 이 되도록 하려면?\n(풀이1)\n\n[a[0]+b[0],a[1]+b[1]]\n\n[4, 6]\n\n\n풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1] 은 각각 인트형임. 인트형은 + 연산이 가능했음.\n(풀이2)\nnumpy 패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리)\n\n이러한 벡터연산은 누구나 필요로 하는 연산임.\n내가 아니더라도 누군가가 프로그램화 해놓았을 것임.\n그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음. (패키지를 배포한다고 표현)\n그 패키지를 우리는 가져와서 설치한뒤 사용하기만 하면된다.\n\n패키지를 설치하는 방법\n\n!pip install numpy # 최신버전을 설치함\n!conda install -c conda-forge numpy -y # 안전한 버전을 설치함\n\n설치된 패키지를 사용하는 방법\n\nimport numpy 한뒤에 numpy.??로 기능을 사용\nimport numpy as np 한뒤에 np.??로 기능을 사용\n\n\nimport numpy ## 설치한패키지를 쓰겠다고 선언함 \n\n\na=[1,2]\nb=[3,4]\n\n\naa = numpy.array(a)\nbb = numpy.array(b)\n\n\naa+bb\n\narray([4, 6])\n\n\n여러가지 연산 가능 (마치 R처럼 쓸 수 있음)\n\n2*aa\n\narray([2, 4])\n\n\n\n2*aa+1\n\narray([3, 5])\n\n\n\n2*aa+1+bb\n\narray([6, 9])\n\n\n(풀이3)\n\nimport numpy as np ## 설치한 numpy라는 패키지를 쓰겠음. 그런데 numpy말고 np라는 이름으로 쓰겠음\n\n\nnp.array(a)+np.array(b)\n\narray([4, 6])"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#인덱싱",
    "href": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#인덱싱",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "인덱싱",
    "text": "인덱싱\n- str형과 동일한 방식\n\na=[11,22,33,44,55] # 0 -4 -3 -2 -1\n\n\na[-2:] # 끝의 2개의 원소를 뽑음 \n\n[44, 55]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#콘테이너형-객체",
    "href": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#콘테이너형-객체",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "콘테이너형 객체",
    "text": "콘테이너형 객체\n- 리스트의 원소는 int, float 따위만 가능한 것이 아니다. (리스트는 컨테이너형 객체이므로)\n\nlst = [1,3.14,True,'a',[1,2], \n       (1,2),{'name':'iu','age':27},{1,2,3}]\n\n\nlst\n\n[1, 3.14, True, 'a', [1, 2], (1, 2), {'name': 'iu', 'age': 27}, {1, 2, 3}]\n\n\n각 원소의 타입을 알아보자.\n\ntype(lst[0])\n\nint\n\n\n\ntype(lst[1])\n\nfloat\n\n\n\ntype(lst[2])\n\nbool\n\n\n\ntype(lst[3])\n\nstr\n\n\n\ntype(lst[4])\n\nlist\n\n\n\ntype(lst[5])\n\ntuple\n\n\n\ntype(lst[6])\n\ndict\n\n\n\ntype(lst[7])\n\nset\n\n\n- str은 컨테이너형이 아니다.\n\n'abcd'[2]\n\n'c'\n\n\n\nstr의 모든 원소는 문자임"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#가변객체",
    "href": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#가변객체",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "가변객체",
    "text": "가변객체\n- 리스트는 원소를 수정할 수 있다. (리스트는 가변객체이므로)\n\na=[11,22,33]\na\n\n[11, 22, 33]\n\n\n\na[0]\n\n11\n\n\n\na[0]=111\n\n\na\n\n[111, 22, 33]\n\n\n- 원소수정은 당연한 기능같은데 이것이 불가능한 경우도 있다.\n(가능한경우)\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na[0]\n\n'g'\n\n\n\na[0]='G'\n\n\na\n\n['G', 'u', 'e', 'b', 'i', 'n']\n\n\n(불가능한경우)\n\na='guebin'\na\n\n'guebin'\n\n\n\na[0]\n\n'g'\n\n\n\na[0]='G'\n\nTypeError: 'str' object does not support item assignment"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#리스트의-원소-삭제",
    "href": "PP2023/posts/01_PythonBasic/2023-03-15-2wk-2.html#리스트의-원소-삭제",
    "title": "02wk-2: 파이썬의 자료형 (3)",
    "section": "리스트의 원소 삭제",
    "text": "리스트의 원소 삭제\n(예제1) del을 이용한 원소삭제\n아래와 같이 문자로 된 리스트를 선언하자.\n\na=['g','u','e','b','i','n']\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n사실 더 쉽게 선언할 수 있음\n\nlist('guebin')\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n첫번째 원소를 삭제하고 싶다면?\n\ndel a[0]\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n이 상태에서 다시 첫번째 원소를 삭제한다면?\n\ndel a[0]\na\n\n['e', 'b', 'i', 'n']\n\n\n(예제2) pop을 이용한 원소삭제\n\na=list('guebin')\na\n\n['g', 'u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'g'\n\n\n\na\n\n['u', 'e', 'b', 'i', 'n']\n\n\n\na.pop(0)\n\n'u'\n\n\n\na\n\n['e', 'b', 'i', 'n']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-1",
    "href": "PP2023/posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-1",
    "title": "03wk-2: 파이썬의 자료형 (5)",
    "section": "튜플을 왜 쓸까? (1)",
    "text": "튜플을 왜 쓸까? (1)\n- 책의 설명 (이 설명이 꼭 파이썬에 한정되는 것은 아님. 모든 언어에 존재하는 불변형 객체에 적용가능한 설명)\n\n실수방지\n빠르다, 다중작업에 유리하다, 여러사람과 작업하기에 유리하다, 깊은복사/얕은복사시 원하지않는 오류(side effect이라고 함)를 방지할 수 있다, 메모리관리에도 유리함…\n느낌: 불변형은 기능제한이 있는데 가볍고 빠른, 가변형은 기능은 풍부하지만 약간 느리고 무거운 느낌임 (불변형:라면사리, 가변형:라면)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-22-3wk-2.html#슬기로운-튜플사용-starstarstarstarstar",
    "href": "PP2023/posts/01_PythonBasic/2023-03-22-3wk-2.html#슬기로운-튜플사용-starstarstarstarstar",
    "title": "03wk-2: 파이썬의 자료형 (5)",
    "section": "슬기로운 튜플사용 (\\(\\star\\star\\star\\star\\star\\))",
    "text": "슬기로운 튜플사용 (\\(\\star\\star\\star\\star\\star\\))\n- 예제: 여러변수를 동시에 출력하고 싶을 경우 (다중출력?)\n변수를 아래와 같이 선언하였다고 하자.\n\na=1\nb=2\nc=3\n\n선언된 값을 확인하려면?\n\na\n\n1\n\n\n\nb\n\n2\n\n\n\nc\n\n3\n\n\n튜플을 이용하면?\n\na,b,c # 괄호하나 생략하는것이 이렇게 편하다..\n\n(1, 2, 3)\n\n\n- 예제: 다중할당1 (여러개의 변수를 동시에 선언하고 싶을 경우)\n\nname, age, sex, height, weight = 'Tom', 20, 'M', 180, 70 \n\n\nname, age, sex, height, weight\n\n('Tom', 20, 'M', 180, 70)\n\n\n\nheight\n\n180\n\n\n- 예제: 다중할당2, 위도와 경도\n\ncoor = (37,127) # 서울 \ncoor\n\n(37, 127)\n\n\n\nlat, long = coor\n\n\nlat \n\n37\n\n\n\nlong \n\n127\n\n\n- 잠깐만: 다중할당은 꼭 튜플에서만 가능한가?\n그건 아니다…\n\n[x,y,z] = [1,2,3] \nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\n[x,y] = 'hi'\nx,y \n\n('h', 'i')\n\n\n튜플과 같이 사용하면 가독성이 극대화 (그래서 다중할당은 거의 튜플과 세트로 사용함)\n\nx,y,z = 1,2,3\nx,y,z # 다중출력 \n\n(1, 2, 3)\n\n\n\nx,y = 'hi'\nx,y \n\n('h', 'i')\n\n\n- 예제: 임시변수 사용없이 두 변수의 값을 교환\n\na=10\nb=20\n\n\na,b = b,a \n\n\na\n\n20\n\n\n\nb\n\n10\n\n\n- 예제: for문과 튜플\n\nlst = [['guebin', 202112345, 'M'],\n       ['iu',202254321, 'F'],\n       ['hodong', 202011223, 'M']]\nlst\n\n[['guebin', 202112345, 'M'],\n ['iu', 202254321, 'F'],\n ['hodong', 202011223, 'M']]\n\n\n\nfor name,studentid,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n- 예제: for문과 튜플, dummy variable _\n\nfor name,studentid,sex in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,studentid,_ in lst: \n    print(studentid)\n\n202112345\n202254321\n202011223\n\n\n\nfor _,_,sex in lst: \n    print(sex)\n\nM\nF\nM\n\n\n\nfor name,_,sex in lst: \n    print(name,sex)\n\nguebin M\niu F\nhodong M\n\n\n\nfor name,_  in lst: \n    print(name)\n\nValueError: too many values to unpack (expected 2)\n\n\n\nfor name,*args  in lst: \n    print(name)\n\nguebin\niu\nhodong\n\n\n- 예제: 튜플과 언패킹연산자 *\n\nhead, body, *tail = range(1,11) \nhead, body, tail\n\n(1, 2, [3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\nhead1,head2, *body, tail1,tail2,tail3 = range(1,11) \nhead1,head2, body, tail1,tail2,tail3 \n\n(1, 2, [3, 4, 5, 6, 7], 8, 9, 10)\n\n\n\n*head, body, tail = range(1,11) \nhead, body, tail\n\n([1, 2, 3, 4, 5, 6, 7, 8], 9, 10)\n\n\n(관찰)\n그러고 보니까..\nhead1,head2, body, tail1,tail2,tail3  = (1, 2, [3,4,5,6,7], 8, 9, 10)\nhead1,head2, *body, tail1,tail2,tail3   = (1, 2, 3,4,5,6,7, 8, 9, 10)\n이렇다는 거잖아?\n*를 붙이면 1차원 자료구조가 풀린다..?\n\n*[1,2,3]\n\nSyntaxError: can't use starred expression here (&lt;ipython-input-37-63179bdb9a80&gt;, line 1)\n\n\n\nprint([1,2,3])\n\n[1, 2, 3]\n\n\n\nprint(*[1,2,3]) ## 이런 느낌이란 말이지..\n\n1 2 3"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-2",
    "href": "PP2023/posts/01_PythonBasic/2023-03-22-3wk-2.html#튜플을-왜-쓸까-2",
    "title": "03wk-2: 파이썬의 자료형 (5)",
    "section": "튜플을 왜 쓸까? (2)",
    "text": "튜플을 왜 쓸까? (2)\n- 책의 설명 (이 설명이 꼭 파이썬에 한정되는 것은 아님. 모든 언어에 존재하는 불변형 객체에 적용가능한 설명)\n\n실수방지\n빠르다, 다중작업에 유리하다, 여러사람과 작업하기에 유리하다, 깊은복사/얕은복사시 원하지않는 오류(side effect이라고 함)를 방지할 수 있다, 메모리관리에도 유리함…\n느낌: 불변형은 기능제한이 있는데 가볍고 빠른, 가변형은 기능은 풍부하지만 약간 느리고 무거운 느낌임 (불변형:라면사리, 가변형:라면)\n\n- 내 설명: 소괄화 생략할 수 있어서 쓰는거야\n\n튜플의 장점은 소괄호의 생략에 있음 (이것은 파이썬과 줄리아만 가능)\n소괄호생략 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성\n컴공과 사람들 의견: 튜플 + 언패킹 \\(\\Rightarrow\\) 엄청난 가독성 \\(\\Rightarrow\\) 충격 \\(\\Rightarrow\\) “파이썬 편하더라고요..”\n\n\ndef mycal(a,b):\n    return a+b, a-b, a*b, a/b  #여러개의 값을 리턴하는듯 보임. -&gt; 사실은 길이가 4인 튜플 1개를 리턴\n\n\nmycal(2,3)\n\n(5, -1, 6, 0.6666666666666666)\n\n\n\n_, _, mulrslt, _ = mycal(2,3) # 병렬할당 \n\n\nmulrslt\n\n6\n\n\n- 의문: 왜 튜플만 괄호를 생략할 수 있지?\n답이 없는 문제인데 답을 해보겠습니다.\n\n튜플을 먼저 만들고, 괄호를 생략하는 문법을 추가한것은 아닐것임\n원래 괄호없이 컴마만 대충찍어서 선언가능한 아주간단한 타입의 벡터형을 만들고 싶었을 것임.\n왜? 괄호없는 벡터를 만들고, 언패킹을 사용하면 여러가지 구문들이 엄청나게 간단해짐.\n컴마컴마로 선언하는 벡터는 한 두번 쓰고 버리는 경우가 많으며 대부분 이름도 필요없음 \\(\\to\\) 원소에 접근해서 sorting하여 순서를 바꾸고 싶다던가 원소를 추가할 이유가 없음 \\(\\to\\) 비싼 가변형으로 만들 이유가 없다는 것..\n우리가 필요한 것: 데이터가 벡터의 형태로 모여있기만 하면 된다!"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#key의-조건",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#key의-조건",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "key의 조건",
    "text": "key의 조건\n- 조건1: 키로 쓸 수 있는 자료형은 정해져 있다.\n\nint O, float O, bool O, str O, list X, tuple O, dict X, set X\n\n(예시1) dict의 키로 int를 사용\n\ndct = {0:[1,2,3], 1:[2,3,4]} \ndct[0] # 인덱싱 하는거 같네?\n\n[1, 2, 3]\n\n\n\ndct[-1] # 속았지?\n\nKeyError: -1\n\n\n(예시2) dict의 키로 float을 사용 &lt;– 이렇게 쓰는 사람 본적이 없어요\n\ndct = {3.14:'π', 2.178:'e'}\ndct[3.14]\n\n'π'\n\n\n(예시3) dict의 키로 bool을 사용\n\ndct = {True: '참이다', False: '거짓이다.'} \ndct\n\n{True: '참이다', False: '거짓이다.'}\n\n\n\ndct[1&lt;2]\n\n'참이다'\n\n\n(예시4) dict의 키로 str을 사용 (\\(\\star\\))\n\ndct = {'guebin':[10,20,30,30], 'hanni':[10,20,25,40]}\ndct['guebin']\n\n[10, 20, 30, 30]\n\n\n(예시5) dict의 키로 list를 사용 \\(\\Rightarrow\\) 불가능\n\ndct = {[10,20,30,40]: 'guebin', [10,20,25,40]: 'hanni'} \ndct\n\nTypeError: unhashable type: 'list'\n\n\n(예시6) dict의 키로 tuple 사용 (\\(\\star\\))\n\ndct = {(10,20,30,40): 'guebin', (10,20,25,40): 'hanni'} \ndct\n\n{(10, 20, 30, 40): 'guebin', (10, 20, 25, 40): 'hanni'}\n\n\n\ndct[(10,20,30,40)]\n\n'guebin'\n\n\n\ndct[10,20,30,40]\n\n'guebin'\n\n\n(예시7) dict의 키로 dict사용 \\(\\Rightarrow\\) 불가능\n\ndct = {{0:1}: 'guebin', {1:2}: 'hanni'} \ndct\n\nTypeError: unhashable type: 'dict'\n\n\n(예시8) dict의 키로 set사용 \\(\\Rightarrow\\) 불가능\n\ndct = {{'샌드위치','딸기우유'}:'점심', {'불고기','된장찌개','김','콩자반'}: '저녁'}\ndct\n\nTypeError: unhashable type: 'set'\n\n\n- 조건2: 키는 중복해서 쓸 수 없다.\n(예시1)\n\ndct = {0:[1,2,3], 1:[2,3,4], 0:[3,4,5]} # 이렇게 쓰지 마세요\ndct \n\n{0: [3, 4, 5], 1: [2, 3, 4]}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#value의-조건",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#value의-조건",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "value의 조건",
    "text": "value의 조건\n- 없다… \\(\\Rightarrow\\) dict는 컨테이너형!!"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#딕셔너리-컴프리헨션",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#딕셔너리-컴프리헨션",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "딕셔너리 컴프리헨션",
    "text": "딕셔너리 컴프리헨션\n- 예시1\n\nlst = [['딸기','사과'],['오토바이','자동차'],['컴퓨터','아이패드','마우스']]\nlst  \n\n[['딸기', '사과'], ['오토바이', '자동차'], ['컴퓨터', '아이패드', '마우스']]\n\n\n\n{i:lst[i] for i in range(3)}\n\n{0: ['딸기', '사과'], 1: ['오토바이', '자동차'], 2: ['컴퓨터', '아이패드', '마우스']}\n\n\n- 예시2: key, val을 서로 바꾸는 예시\n\ndct = {'a':(1,0,0,0), 'b':(0,1,0,0), 'c':(0,0,1,0), 'd':(0,0,0,1)}\ndct\n\n{'a': (1, 0, 0, 0), 'b': (0, 1, 0, 0), 'c': (0, 0, 1, 0), 'd': (0, 0, 0, 1)}\n\n\n\n{v:k for k,v in dct.items() }\n\n{(1, 0, 0, 0): 'a', (0, 1, 0, 0): 'b', (0, 0, 1, 0): 'c', (0, 0, 0, 1): 'd'}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#바꿔치기-3",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#바꿔치기-3",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "바꿔치기 (3)",
    "text": "바꿔치기 (3)\n- 예제1: 아래와 같은 리스트가 있다고 하자.\n\nlst = list('abcd'*2)\nlst\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n아래의 규칙에 의하여 lst의 각 원소의 값을 바꾸고 싶다고 하자.\n\n\n\n변환전\n변환후\n\n\n\n\n‘a’\n[1,0,0,0]\n\n\n‘b’\n[0,1,0,0]\n\n\n‘c’\n[0,0,1,0]\n\n\n‘d’\n[0,0,0,1]\n\n\n\n이를 구현하는 코드를 작성하고, 역변환하는 코드를 작성하라.\nhint: 아래의 dct를 이용할 것\n\ndct = {'a':[1,0,0,0], 'b':[0,1,0,0], 'c':[0,0,1,0], 'd':[0,0,0,1]}\ndct\n\n{'a': [1, 0, 0, 0], 'b': [0, 1, 0, 0], 'c': [0, 0, 1, 0], 'd': [0, 0, 0, 1]}\n\n\n(풀이)\n변환하는 코드를 구현하면\n\nlst2= [dct[l] for l in lst] \nlst2\n\n[[1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1],\n [1, 0, 0, 0],\n [0, 1, 0, 0],\n [0, 0, 1, 0],\n [0, 0, 0, 1]]\n\n\n역변환하는 코드를 구현하면\n(1단계)\n\ndct_inv = {tuple(v):k for k,v in dct.items()}\ndct_inv\n\n{(1, 0, 0, 0): 'a', (0, 1, 0, 0): 'b', (0, 0, 1, 0): 'c', (0, 0, 0, 1): 'd'}\n\n\n(2단계)\n\n[dct_inv[tuple(l)] for l in lst2]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n내생각\n위와 같은 코드는 경우에 따라서 아래와 같은 복잡합 코드를 피할 수 있는 장점이 있다.\n\n[x for l in lst2 for x,y in dct.items() if l==y]\n\n['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']\n\n\n- 예제2: 아래와 같은 리스트가 있다고 하자. – 강의를 재촬영 했습니다.\n\nlst = ['딸기', '사과', '바나나', '바나나', '오토바이', '자동차', '기차']\nlst\n\n['딸기', '사과', '바나나', '바나나', '오토바이', '자동차', '기차']\n\n\n아래와 같은 규칙에 따라서 바꾸고 싶다고 하자.\n\n\n\n변환전\n변환후\n\n\n\n\n딸기\n과일\n\n\n사과\n과일\n\n\n바나나\n과일\n\n\n오토바이\n탈것\n\n\n자동차\n탈것\n\n\n버스\n탈것\n\n\n기차\n탈것\n\n\n\n(풀이1)\n\ndct = {'딸기':'과일', '사과':'과일', '바나나':'과일', \n       '오토바이':'탈것', '자동차':'탈것', '버스':'탈것', '기차':'탈것'}\ndct\n\n{'딸기': '과일',\n '사과': '과일',\n '바나나': '과일',\n '오토바이': '탈것',\n '자동차': '탈것',\n '버스': '탈것',\n '기차': '탈것'}\n\n\n\n[dct[l] for l in lst]    \n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것']\n\n\n(풀이2) – 지난시간에 한 것\n\ndct = {'과일':['딸기','사과','바나나'], '탈것':['오토바이','자동차', '버스', '기차']} \ndct\n\n{'과일': ['딸기', '사과', '바나나'], '탈것': ['오토바이', '자동차', '버스', '기차']}\n\n\n\n[k for l in lst for k,v in dct.items() if l in v]\n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것']\n\n\n(풀이3)\n\n_dct = {l:k for k,v in dct.items() for l in v}\n_dct \n\n{'딸기': '과일',\n '사과': '과일',\n '바나나': '과일',\n '오토바이': '탈것',\n '자동차': '탈것',\n '버스': '탈것',\n '기차': '탈것'}\n\n\n\n[_dct[l] for l in lst]\n\n['과일', '과일', '과일', '과일', '탈것', '탈것', '탈것']"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#선언",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#선언",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "선언",
    "text": "선언\n\nwishlist={'notebook','desktop'}\nwishlist\n\n{'desktop', 'notebook'}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추출",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추출",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "원소추출",
    "text": "원소추출\n- 일단 인덱스로는 못합니다.\n\nwishlist={'notebook','desktop'}\nwishlist[0]\n\nTypeError: 'set' object is not subscriptable\n\n\n- 딱히 하는 방법이 없어요.. 그리고 이걸 하는 의미가 없어요.. (원소에 접근해서 뭐하려고??)"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추가",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#원소추가",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "원소추가",
    "text": "원소추가\n- 이건 의미가 있음\n\nwishlist={'notebook','desktop'} \nwishlist\n\n{'desktop', 'notebook'}\n\n\n\nwishlist.add('ipad')\nwishlist\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nwishlist.add('notebook') # 이미 원소로 있는건 추가되지 않음. \nwishlist\n\n{'desktop', 'ipad', 'notebook'}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#원소삭제",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#원소삭제",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "원소삭제",
    "text": "원소삭제\n\nwishlist={'desktop', 'ipad', 'notebook'}\nwishlist\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nwishlist.remove('notebook')\n\n\nwishlist\n\n{'desktop', 'ipad'}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#연산",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#연산",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "연산",
    "text": "연산\n- in 연산자\n\nwishlist={'desktop', 'ipad', 'notebook'}\nwishlist\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\n'notebook' in wishlist\n\nTrue\n\n\n\n참고로 in연산자는 집합에서만 쓰는것은 아님\n\n- 합집합, 교집합, 차집합\n\nday1 = {'notebook','desktop'}\nday2 = {'notebook','ipad'}\n\n\nday1 | day2 # 합집합\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nday1 & day2 # 교집합\n\n{'notebook'}\n\n\n\nday1 - day2 # 차집합 \n\n{'desktop'}\n\n\n\nday2 - day1 # 차집합\n\n{'ipad'}\n\n\n- 부분집합\n\nday1 = {'notebook', 'desktop'}\nday2 = day1 | {'ipad'} \n\n\nday1 &lt; day2  # day1는 day2의 부분집합인가? \n\nTrue\n\n\n\nday2 &lt; day1\n\nFalse"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#집합-특수기능",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#집합-특수기능",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "집합 특수기능",
    "text": "집합 특수기능\n- 합집합\n\nday1 = {'notebook', 'desktop'}\nday2 = {'notebook','ipad'}\n\n\nday1.union(day2)\n\n{'desktop', 'ipad', 'notebook'}\n\n\n- 나머지 메소드는 스스로 찾아보세요"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#for문과-set",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#for문과-set",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "for문과 set",
    "text": "for문과 set\n\nday1 = {'notebook', 'desktop'}\nday2 = {'notebook', 'ipad'}\n\n\nfor i in day1|day2: \n    print(i)\n\nnotebook\nipad\ndesktop"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#set-컴프리헨션",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#set-컴프리헨션",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "set 컴프리헨션",
    "text": "set 컴프리헨션\n- 예시1\n\nlst = [1,2,1,1,3,4,5]\n{l for l in lst}\n\n{1, 2, 3, 4, 5}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#유니크한-원소",
    "href": "PP2023/posts/01_PythonBasic/2023-03-29-4wk-2.html#유니크한-원소",
    "title": "04wk-2: 파이썬의 자료형 (7)",
    "section": "유니크한 원소",
    "text": "유니크한 원소\n- 예제1: 아래의 list는 모두 몇 종류의 문자로 이루어져 있는가?\n\nlst=list('asdfasssdfdsasdfasdfasdfasdf')\n\n(풀이)\n\nset(lst)\n\n{'a', 'd', 'f', 's'}\n\n\n\nlen(set(lst))\n\n4\n\n\n- 예제2: 아래의 txt에서 어떠한 종류의 문자가 각각 몇번씩 사용되었는지 빈도를 구하는 코드를 작성하라.\n\ntxt = 'asdkflkjahsdlkjfhlaksglkjdhflkgjhlskdfjhglkajhsdlkfjhalsdkf'\ntxt\n\n'asdkflkjahsdlkjfhlaksglkjdhflkgjhlskdfjhglkajhsdlkfjhalsdkf'\n\n\n(풀이)\n\n{k:list(txt).count(k) for k in set(txt)}\n\n{'s': 6, 'a': 5, 'g': 3, 'k': 10, 'j': 7, 'h': 7, 'd': 6, 'l': 9, 'f': 6}"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#해결1",
    "href": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#해결1",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "해결1",
    "text": "해결1\n- 자주 사용하는 함수를 myfuns.py에 저장한다.\n# myfuns.py\ndef vec2_add(a,b): \n    return [a[0]+b[0], a[1]+b[1]]\n- %run myfuns를 실행\n준비: “00” -&gt; 커널재시작\n\n%run myfuns \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#해결2",
    "href": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#해결2",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "해결2",
    "text": "해결2\n- 자주 사용하는 함수를 myfuns.py에 저장한다.\n# myfuns.py\ndef vec2_add(a,b): \n    return [a[0]+b[0], a[1]+b[1]]\n- import myfuns를 이용\n(준비) “00” -&gt; 커널재시작\n\nimport myfuns \n\n\na=[1,2]\nb=[3,4]\nmyfuns.vec2_add(a,b)\n\n[4, 6]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#사용방법",
    "href": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#사용방법",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "사용방법",
    "text": "사용방법\n- 사용방법1\n준비: “00” -&gt; 커널재시작\n\nimport myfuns \n\n\nmyfuns.vec2_add([1,2],[3,4]) \n\n[4, 6]\n\n\n\nmyfuns.vec2_add 의 의미: myfuns.py 라는 파일안에 vec2_add라는 함수가 있음. 그것을 실행하라.\n.의 의미: 상위.하위의 개념!\n\n(주의) 아래와 같이 사용불가능 하다.\n\nvec2_add([1,2],[3,4])\n\nNameError: name 'vec2_add' is not defined\n\n\n- 사용방법2\n준비: “00” -&gt; 커널재시작\n\nfrom myfuns import vec2_add \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n(주의) 이 경우는 오히려 아래가 불가능함\n\nmyfuns.vec2_add([1,2],[3,4]) # myfuns안의 vec2_add만 임포트했지 myfuns자체를 임포트 한것은 아님 \n\nNameError: name 'myfuns' is not defined\n\n\n- 사용방법3\n준비: “00” -&gt; 커널재시작\n\nimport myfuns\nfrom myfuns import vec2_add\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n- 사용방법4\n준비: “00” -&gt; 커널재시작\n\nfrom myfuns import vec2_add, vec2_sub \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n- 사용방법5\n준비: “00” -&gt; 커널재시작\n\nfrom myfuns import * #*는 all의 의미 \n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n- 사용방법6\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nmf.vec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n(오히려 아래는 실행불가능)\n\nmyfuns.vec2_add([1,2],[3,4])\n\nNameError: name 'myfuns' is not defined\n\n\n\nmyfuns.vec2_sub([1,2],[3,4])\n\nNameError: name 'myfuns' is not defined\n\n\n- 잘못된 사용방법1\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \nfrom mf import vec2_add \n\nModuleNotFoundError: No module named 'mf'\n\n\n- 사용방법7\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \nfrom myfuns import vec2_add \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n- 사용방법8\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \nfrom myfuns import vec2_add as add \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\nNameError: name 'vec2_add' is not defined\n\n\n\nadd([1,2],[3,4])\n\n[4, 6]"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#도움말-작성기능",
    "href": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#도움말-작성기능",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "도움말 작성기능",
    "text": "도움말 작성기능\n- mf란 무엇인가?\n준비: “00” -&gt; 커널재시작\n\nimport myfuns as mf \n\n\nmf\n\n&lt;module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'&gt;\n\n\n\nmf?\n\n\nType:        module\nString form: &lt;module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'&gt;\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py\nDocstring:   &lt;no docstring&gt;\n\n\n\n\n\ntype(mf)\n\nmodule\n\n\n\nmf의 타입은 모듈이라고 나옴, 현재 단계에서는 무엇인지 알기 어려움\n\n- Docstring의 내용을 채울 수 있을까?\n준비1: myfuns.py 파일을 아래와 같이 수정한다.\n준비2: “00” -&gt; 커널재시작\n\nimport myfuns as mf \n\n\nmf?\n\n\nType:        module\nString form: &lt;module 'myfuns' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py'&gt;\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/myfuns.py\nDocstring:   이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다."
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#주의점",
    "href": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#주의점",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "주의점",
    "text": "주의점\n- myfuns.py는 최초 한번만 import 된다.\n준비: “00” -&gt; 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\nmyfuns.py파일을 열고 함수를 아래와 같이 바꾸자.\n\"\"\"이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.\"\"\" \ndef vec2_add(a,b): \n    print(\"이것은 myfuns.py에 정의된 함수입니다\") \n    return [a[0]+b[0], a[1]+b[1]]\ndef vec2_sub(a,b): \n    return [a[0]-b[0], a[1]-b[1]]\n다시 myfuns를 로드하고 myfuns.vec2_add 를 실행하여 보자.\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n바뀐내용이 적용되지 않는다.\n커널을 다시 시작하고 임포트해보자.\n“00” -&gt; 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n이것은 myfuns.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n- myfuns.py는 주피터노트북파일과 같은 폴더에 존재해야 한다.\n준비1: “00” -&gt; 커널재시작\n준비2: myfuns.py을 복사하여 다른 폴더로 이동. 예를들면 IP0403 폴더를 만들고 그 폴더안에 myfuns.py파일을 복사해서 붙여넣은뒤에 파일이름을 myfuns2.py 로 변경.\n\nimport myfuns # 주피터노트북파일과 같은 폴더에 있는 myfuns는 잘 로드되지만 \n\n\nimport myfuns2 # 주피터노트북파일과 다른 폴더에 있는 myfuns2는 그렇지 않다. \n\nModuleNotFoundError: No module named 'myfuns2'\n\n\n- IP0403 폴더에 있는 myfuns2.py를 실행하기 위해서는 아래와 같이 할 수 있다.\n준비: “00” -&gt; 커널재시작\n\nfrom IP0403 import myfuns2\n\n\nmyfuns2.vec2_add([1,2],[3,4]) \n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n- 아래도 가능하다.\n준비: “00” -&gt; 커널재시작\n\nfrom IP0403.myfuns2 import vec2_add as add \n\n\nadd([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n참고로 아래는 모두 정의되지 않음\n\nIP0403.myfuns2.vec2_add([1,2],[3,4]) \n\nNameError: name 'IP0403' is not defined\n\n\n\nmyfuns2.vec2_add([1,2],[3,4]) \n\nNameError: name 'myfuns2' is not defined\n\n\n\nvec2_add([1,2],[3,4]) \n\nNameError: name 'vec2_add' is not defined"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#폴더와-함께-사용할시",
    "href": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#폴더와-함께-사용할시",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "폴더와 함께 사용할시",
    "text": "폴더와 함께 사용할시\n- 언뜻 생각하면 아래가 가능할 것 같다.\nimport IP0403 \nIP0403.myfuns2.vec2_add([1,2],[3,4]) \n- 하지만 불가능하다.\n준비: “00” -&gt; 커널재시작\n\nimport IP0403 \n\n\n되는거아냐?\n\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])\n\nAttributeError: module 'IP0403' has no attribute 'myfuns2'\n\n\n\n여기서 불가능하다.\n\n- (암기) IP0403 폴더안에 __init__.py라는 파일을 만들고 내용에 아래와 같이 쓰면 가능하다.\n# ./IP0403/__init__.py \nfrom . import myfuns2\n준비1: 위의 지침을 따른다.\n준비2: “00” -&gt; 커널재시작\n\nimport IP0403 \n\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다\n\n\n[4, 6]\n\n\n컴퓨터 상식 - .: 현재폴더를 의미 - ..: 상위폴더를 의미 - ./myfuns.py: 현재폴더안에 있는 myfuns.py를 의미 - ./IP0403/myfuns2.py: 현재폴더만에 IP0403폴더안의 myfuns2.py 파일을 의미 - ../myfuns.py: 현재폴더보다 한단계상위폴더에 있는 myfuns.py를 의미 - cd ./IP0403: 현재폴더안에 있는 IP0403폴더로 이동해라. (cd IP0403으로 줄여쓸 수 있음) - cd .. 현재폴더보다 한단계 상위폴더로 이동하라.\n따라서 from . import myfuns2는 현재폴더에서 myfuns2를 찾아서 임포트 하라는 의미로 해석가능\n- 의미상으로 보면 아래가 실행가능할듯 한데 불가능하다.\n\n#import myfuns\nfrom . import myfuns\n\nImportError: attempted relative import with no known parent package"
  },
  {
    "objectID": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#site-packages-실습금지",
    "href": "PP2023/posts/01_PythonBasic/2023-04-05-5wk-2.html#site-packages-실습금지",
    "title": "05wk-2: 모듈, 패키지, 라이브러리",
    "section": "site-packages (실습금지)",
    "text": "site-packages (실습금지)\n- 의문: 왜 현재폴더에 numpy.py라든가 numpy라는 이름의 폴더가 없는데도 import 가능한지?\n준비: “00” -&gt; 커널재시작\n\nimport numpy as np\n\n\nimport IP0403 as ip \n\n\nip?\n\n\nType:        module\nString form: &lt;module 'IP0403' from '/home/cgb3/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py'&gt;\nFile:        ~/Dropbox/07_lectures/IP2022/_notebooks/IP0403/__init__.py\nDocstring:   &lt;no docstring&gt;\n\n\n\n\n\nnp?\n\n\nType:        module\nString form: &lt;module 'numpy' from '/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py'&gt;\nFile:        ~/anaconda3/envs/py310/lib/python3.10/site-packages/numpy/__init__.py\nDocstring:  \nNumPy\n=====\nProvides\n  1. An array object of arbitrary homogeneous items\n  2. Fast mathematical operations over arrays\n  3. Linear Algebra, Fourier Transforms, Random Number Generation\nHow to use the documentation\n----------------------------\nDocumentation is available in two forms: docstrings provided\nwith the code, and a loose standing reference guide, available from\n`the NumPy homepage &lt;https://www.scipy.org&gt;`_.\nWe recommend exploring the docstrings using\n`IPython &lt;https://ipython.org&gt;`_, an advanced Python shell with\nTAB-completion and introspection capabilities.  See below for further\ninstructions.\nThe docstring examples assume that `numpy` has been imported as `np`::\n  &gt;&gt;&gt; import numpy as np\nCode snippets are indicated by three greater-than signs::\n  &gt;&gt;&gt; x = 42\n  &gt;&gt;&gt; x = x + 1\nUse the built-in ``help`` function to view a function's docstring::\n  &gt;&gt;&gt; help(np.sort)\n  ... # doctest: +SKIP\nFor some objects, ``np.info(obj)`` may provide additional help.  This is\nparticularly true if you see the line \"Help on ufunc object:\" at the top\nof the help() page.  Ufuncs are implemented in C, not Python, for speed.\nThe native Python help() does not know how to view their help, but our\nnp.info() function does.\nTo search for documents containing a keyword, do::\n  &gt;&gt;&gt; np.lookfor('keyword')\n  ... # doctest: +SKIP\nGeneral-purpose documents like a glossary and help on the basic concepts\nof numpy are available under the ``doc`` sub-module::\n  &gt;&gt;&gt; from numpy import doc\n  &gt;&gt;&gt; help(doc)\n  ... # doctest: +SKIP\nAvailable subpackages\n---------------------\ndoc\n    Topical documentation on broadcasting, indexing, etc.\nlib\n    Basic functions used by several sub-packages.\nrandom\n    Core Random Tools\nlinalg\n    Core Linear Algebra Tools\nfft\n    Core FFT routines\npolynomial\n    Polynomial tools\ntesting\n    NumPy testing tools\nf2py\n    Fortran to Python Interface Generator.\ndistutils\n    Enhancements to distutils with support for\n    Fortran compilers support and more.\nUtilities\n---------\ntest\n    Run numpy unittests\nshow_config\n    Show numpy build configuration\ndual\n    Overwrite certain functions with high-performance SciPy tools.\n    Note: `numpy.dual` is deprecated.  Use the functions from NumPy or Scipy\n    directly instead of importing them from `numpy.dual`.\nmatlib\n    Make everything matrices.\n__version__\n    NumPy version string\nViewing documentation using IPython\n-----------------------------------\nStart IPython with the NumPy profile (``ipython -p numpy``), which will\nimport `numpy` under the alias `np`.  Then, use the ``cpaste`` command to\npaste examples into the shell.  To see which functions are available in\n`numpy`, type ``np.&lt;TAB&gt;`` (where ``&lt;TAB&gt;`` refers to the TAB key), or use\n``np.*cos*?&lt;ENTER&gt;`` (where ``&lt;ENTER&gt;`` refers to the ENTER key) to narrow\ndown the list.  To view the docstring for a function, use\n``np.cos?&lt;ENTER&gt;`` (to view the docstring) and ``np.cos??&lt;ENTER&gt;`` (to view\nthe source code).\nCopies vs. in-place operation\n-----------------------------\nMost of the functions in `numpy` return a copy of the array argument\n(e.g., `np.sort`).  In-place versions of these functions are often\navailable as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.\nExceptions to this rule are documented.\n\n\n\n\n- 추측: ~/anaconda3/envs/py310/lib/python3.10/site-packages/를 찾아가보자. 그곳에 numpy폴더가 있을 것이다.\n\n!ls ~/anaconda3/envs/py310/lib/python3.10/site-packages | grep numpy\n\nnumpy\nnumpy-1.22.2.dist-info\n\n\n- 추측2: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에 내가 자주 쓰는 기능을 폴더로 만들어서 모아두면 어디서든지 import 할 수 있다.\n\n!mkdir ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin # guebin 폴더 생성 \n\n\n!cp ./myfuns.py ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin \n# 현폴더에 있는 myfuns.py를 아까만든 guebin 폴더로 복사 \n\n\nfrom guebin import myfuns\n\n\nmyfuns?\n\n\nType:        module\nString form: &lt;module 'guebin.myfuns' from '/home/cgb3/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py'&gt;\nFile:        ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin/myfuns.py\nDocstring:   이것은 길이가 2인 벡터의 합 혹은 차를 구하는 모듈입니다.\n\n\n\n\n\n!rm  ~/anaconda3/envs/py310/lib/python3.10/site-packages/guebin -rf # guebin 폴더삭제 \n\n- 추측3: guebin이 사라진 상태에서는 from guebin import myfuns 이 동작하지 않을 것이다.\n준비: “00” -&gt; 커널재시작\n\nfrom guebin import myfuns\n\nModuleNotFoundError: No module named 'guebin'\n\n\n- 추측4: ~/anaconda3/envs/py310/lib/python3.10/site-packages/에서 numpy를 지운다면 numpy를 import할 수 없다.\n준비: “00” -&gt; 커널재시작\n\nimport numpy as np\n\nModuleNotFoundError: No module named 'numpy'\n\n\n- 추측5: !pip install numpy를 하면 다시 폴더가 생길 것이다.\n\n!pip uninstall numpy -y \n\nFound existing installation: numpy 1.22.2\nUninstalling numpy-1.22.2:\n  Successfully uninstalled numpy-1.22.2\n\n\n\n!pip install numpy \n\nCollecting numpy\n  Downloading numpy-1.22.3-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (16.8 MB)\n     |████████████████████████████████| 16.8 MB 11.4 MB/s eta 0:00:01\nInstalling collected packages: numpy\nSuccessfully installed numpy-1.22.3"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#np.concatenate",
    "href": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#np.concatenate",
    "title": "06wk-2: Numpy (2)",
    "section": "np.concatenate",
    "text": "np.concatenate\n- 1차원: concat의 기본예제 (쓸모 없어보임)\n\na= np.array([1,2,3]) \nb= -a \n\n\nnp.concatenate([a,b])\n\narray([ 1,  2,  3, -1, -2, -3])\n\n\n\nnp.array(list(a)+list(b))\n\narray([ 1,  2,  3, -1, -2, -3])\n\n\n- 2차원: 이건 좀 의미가 있어보임\n\na = np.array([1,2,3,4]).reshape(2,2)\nb = -a \n\n\nnp.concatenate([a,b])\n\narray([[ 1,  2],\n       [ 3,  4],\n       [-1, -2],\n       [-3, -4]])\n\n\n만약에 a,b를 좌우로 붙이고 싶다면? axis=1이라고 옵션을 주면 된다.\n\nnp.concatenate([a,b],axis=1) \n\narray([[ 1,  2, -1, -2],\n       [ 3,  4, -3, -4]])\n\n\n\naxis=1의 의미는 무엇일까?\n\n- axis=1 의 의미를 파악하기 전에, axis=1만 가능한것인지 알아보자.\n(시도1)\n\nnp.concatenate([a,b],axis=0)\n# np.concatenate([a,b]) 와 같음 \n# np.concatenate([a,b])은 np.concatenate([a,b],axis=0)의 생략버전이라 유추가능\n\narray([[ 1,  2],\n       [ 3,  4],\n       [-1, -2],\n       [-3, -4]])\n\n\n\naxis=0 도 가능!!\n\n(시도2)\n\nnp.concatenate([a,b],axis=2)\n# 에러가 난다. \n\nAxisError: axis 2 is out of bounds for array of dimension 2\n\n\n\naxis=1은 불가능!!\n\n- axis의 의미를 알아보자.\n\na= np.array([1,2,3,4,5,6]).reshape(3,2)\nb= -a \n\n(예시1)\n\na.shape,b.shape, np.concatenate([a,b],axis=0).shape\n\n((3, 2), (3, 2), (6, 2))\n\n\n\n관찰: (3,2) concat (3,2) -&gt; (6,2) // 첫번째 숫자가 바뀜 &lt;== axis=0\n\n(예시2)\n\na.shape,b.shape, np.concatenate([a,b],axis=1).shape\n\n((3, 2), (3, 2), (3, 4))\n\n\n\n관찰: (3,2) concat (3,2) -&gt; (3,4) // 두번째 숫자가 바뀜 &lt;== axis=1\n\n(예시3)\n\na= np.arange(24).reshape(2,3,4) \nb= -a \n\n\na.shape,b.shape,np.concatenate([a,b],axis=0).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\n유추: (2,3,4) concat (2,3,4) -&gt; (4,3,4) // 첫번째 숫자가 바뀔 것 같았는데 실제로 그러함 &lt;== axis=0\n\n(예시4)\n\na.shape,b.shape,np.concatenate([a,b],axis=1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\n(2,3,4) concat (2,3,4) -&gt; (2,6,4) // 두번째 숫자가 바뀜 &lt;== axis=1\n\n(예시5)\n\na.shape,b.shape,np.concatenate([a,b],axis=2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n\n(2,3,4) concat (2,3,4) -&gt; (2,3,8) // 세번째 숫자가 바뀜 &lt;== axis=2\n\n(예시5)\n\na.shape,b.shape,np.concatenate([a,b],axis=-1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n\n(2,3,4) concat (2,3,4) -&gt; (2,3,8) // 마지막 숫자가 바뀜 &lt;== axis=-1\n\n(예시6)\n\na.shape,b.shape,np.concatenate([a,b],axis=-2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\n(2,3,4) concat (2,3,4) -&gt; (2,6,4) // 마지막에서 두번째 숫자가 바뀜 &lt;== axis=-2\n\n(예시7)\n\na.shape,b.shape,np.concatenate([a,b],axis=-3).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\n(2,3,4) concat (2,3,4) -&gt; (4,3,4) // 마지막에서 세번째 숫자가 바뀜 &lt;== axis=-3\n\n(예시8)\n\na.shape,b.shape,np.concatenate([a,b],axis=-4).shape\n\nAxisError: axis -4 is out of bounds for array of dimension 3\n\n\n\n(2,3,4) concat (2,3,4) -&gt; ??? // 마지막에서 네번째 숫자는 없어서 에러남 &lt;== axis=-4\n\n(예시9)\n\na.shape,b.shape,np.concatenate([a,b],axis=3).shape\n\nAxisError: axis 3 is out of bounds for array of dimension 3\n\n\n\n(2,3,4) concat (2,3,4) -&gt; ??? // 네번째 숫자는 없어서 에러남 &lt;== axis=3"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#np.stack",
    "href": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#np.stack",
    "title": "06wk-2: Numpy (2)",
    "section": "np.stack",
    "text": "np.stack\n- 아래의 자료를 관찰하자.\n\na = np.array([1,2,3])\nb = -a \n\n\na,b\n\n(array([1, 2, 3]), array([-1, -2, -3]))\n\n\n- 혹시 a,b를 위아래로 쌓아서 결과를 (2,3) 매트릭스로 만들 수 있을까?\n\nnp.concatenate([a,b]) # 실패1\n\narray([ 1,  2,  3, -1, -2, -3])\n\n\n\nnp.concatenate([a,b],axis=1) # 실패2\n\nAxisError: axis 1 is out of bounds for array of dimension 1\n\n\n- 실패이유를 분석: (3,) concat (3,) 으로 (2,3) 를 만들려고 해서 불가능했음.\n\n전략: reshape을 이용하여 (3,), (3,) =&gt; (1,3), (1,3) 으로 변경후 concat을 하면 가능할듯\n\n\nnp.concatenate([a.reshape(1,3),b.reshape(1,3)],axis=0) # 성공\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\n또 다른 방법!\n\nnp.stack([a,b],axis=0)\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\n- 이번에는 a,b를 좌우로 쌓아서 결과를 (3,2) 매트릭스로를 만들어 보자.\n\nnp.concatenate([a.reshape(3,1),b.reshape(3,1)],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n또 다른 방법!\n\nnp.stack([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n- 요약: stack은 axis= 위치에 축을 추가하고 concat을 한 것 이라 이해할 수 있다.\n강의에서는 하지 않은 예제\n\na=np.arange(3*4*5).reshape(3,4,5) \nb=-a\n\n\na.shape, b.shape\n\n((3, 4, 5), (3, 4, 5))\n\n\n\nnp.stack([a,b],axis=0).shape # (3,4,5) =&gt; (1,3,4,5) // 첫 위치에 축이 추가되고 스택 \n\n(2, 3, 4, 5)\n\n\n\nnp.stack([a,b],axis=1).shape # (3,4,5) =&gt; (3,1,4,5) // 두번째 위치에 축이 추가되고 스택 \n\n(3, 2, 4, 5)\n\n\n\nnp.stack([a,b],axis=2).shape # (3,4,5) =&gt; (3,4,1,5) // 세번째 위치에 축이 추가되고 스택 \n\n(3, 4, 2, 5)\n\n\n\nnp.stack([a,b],axis=3).shape # (3,4,5) =&gt; (3,4,5,1) // 네번째 위치에 축이 추가되고 스택 \n\n(3, 4, 5, 2)\n\n\n\nnp.stack([a,b],axis=-1).shape # axis=-1 &lt;=&gt; axis=3 \n\n(3, 4, 5, 2)\n\n\n\nnp.stack([a,b],axis=-2).shape # axis=-2 &lt;=&gt; axis=2\n\n(3, 4, 2, 5)\n\n\nnp.concatenate 는 축의 총 갯수를 유지하면서 결합, np.stack은 축의 갯수를 하나 증가시키면서 결합"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#sum",
    "href": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#sum",
    "title": "06wk-2: Numpy (2)",
    "section": "sum",
    "text": "sum\n- 1차원 array의 sum\n\na = np.array([1,2,3,4])\na\n\narray([1, 2, 3, 4])\n\n\n\na.sum()\n\n10\n\n\n\nnp.sum(a)\n\n10\n\n\n- 2차원 array일 경우\n\na= np.arange(4*3).reshape(4,3)\na\n\narray([[ 0,  1,  2],\n       [ 3,  4,  5],\n       [ 6,  7,  8],\n       [ 9, 10, 11]])\n\n\n\na.sum(axis=-1)\n\narray([ 3, 12, 21, 30])\n\n\n\n마지막 축이 삭제됨\n\n- 그렇다면?\n\na.sum(axis=(0,1))\n\n66\n\n\n\n첫번째 축과 두번째 축이 삭제됨\n\n- 연습 (강의에서 하지 않은 예제)\n\na=np.array(range(10)).reshape(5,2) \na\n\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n\n\n(문제1) 1열의 합, 2열의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) =&gt; (2,) 로 나와야 한다. (그럼 첫번째 축이 삭제되어야 하네?)\n\na.sum(axis=0)\n\narray([20, 25])\n\n\n(문제2) 1행의 합, 2행의 합, … , 5행의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) =&gt; (5,)로 나와야 한다. (그럼 두번째 축이 삭제되어야 하네?)\n\na.sum(axis=1)\n\narray([ 1,  5,  9, 13, 17])\n\n\n(문제3) a의 모든원소의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) =&gt; () 로 나와야 한다. (첫번째축, 두번째축이 모두 삭제되어야 하네?)\n\na.sum(axis=(0,1))\n\n45\n\n\n\na.sum() # 즉 a.sum(axis=(0,1))이 디폴트값임 \n\n45"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#mean-std-max-min-prod",
    "href": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#mean-std-max-min-prod",
    "title": "06wk-2: Numpy (2)",
    "section": "mean, std, max, min, prod",
    "text": "mean, std, max, min, prod\n- mean, std, max, min, prod 모두 sum과 유사한 논리임\n- 평균\n\na = np.arange(3*5*5).reshape(3,5,5)\na\n\narray([[[ 0,  1,  2,  3,  4],\n        [ 5,  6,  7,  8,  9],\n        [10, 11, 12, 13, 14],\n        [15, 16, 17, 18, 19],\n        [20, 21, 22, 23, 24]],\n\n       [[25, 26, 27, 28, 29],\n        [30, 31, 32, 33, 34],\n        [35, 36, 37, 38, 39],\n        [40, 41, 42, 43, 44],\n        [45, 46, 47, 48, 49]],\n\n       [[50, 51, 52, 53, 54],\n        [55, 56, 57, 58, 59],\n        [60, 61, 62, 63, 64],\n        [65, 66, 67, 68, 69],\n        [70, 71, 72, 73, 74]]])\n\n\n\na.mean(axis=0)\n\narray([[25., 26., 27., 28., 29.],\n       [30., 31., 32., 33., 34.],\n       [35., 36., 37., 38., 39.],\n       [40., 41., 42., 43., 44.],\n       [45., 46., 47., 48., 49.]])\n\n\n\n(3,5,5) =&gt; (5,5)\n\n\na.mean(axis=(1,2))\n\narray([12., 37., 62.])\n\n\n\n(3,5,5) =&gt; (3,)\n\n- std\n\na = np.array([1,2,3,4,5,6]).reshape(3,2)\na\n\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n\n\na.std(axis=1)\n\narray([0.5, 0.5, 0.5])\n\n\n참고: 분모를 \\(n\\)이 아니라 \\(n-1\\)로 나누고 싶다면 아래와 같이 사용하라.\n\na.std(axis=1,ddof=1)\n\narray([0.70710678, 0.70710678, 0.70710678])\n\n\n- max,min,prod\n\na = np.array([1,2,3,4,5,6]).reshape(3,2)\na\n\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n\n\na.max(axis=1)\n\narray([2, 4, 6])\n\n\n\na.min(axis=1)\n\narray([1, 3, 5])\n\n\n\na.prod(axis=1)\n\narray([ 2, 12, 30])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#argmax-argmin",
    "href": "PP2023/posts/02_DataScience/2023-04-12-6wk-2.html#argmax-argmin",
    "title": "06wk-2: Numpy (2)",
    "section": "argmax, argmin",
    "text": "argmax, argmin\n- 아래와 같은 행렬 a를 고려하자.\n\na = np.random.rand(15).reshape(5,3)\na = np.stack([np.array(l)/l.sum() for l in a]) # 리스트는 5개의 원소가 있으며 각 원소는 차원이 (3,) =&gt; stack을 이용해 첫 위치에 축을 추가하여 (5,3) 매트릭스를 만듬 \na\n\narray([[0.58989212, 0.30450216, 0.10560572],\n       [0.05347106, 0.83664056, 0.10988837],\n       [0.50986898, 0.27325369, 0.21687733],\n       [0.06361946, 0.33376979, 0.60261074],\n       [0.0593742 , 0.70953607, 0.23108973]])\n\n\n\n편의상 이 행렬의 each-row 는 어떠한 이미지가 ‘개,고양이,사과’ 일 확률을 의미한다고 상상하자.\n\n- 위의 a에서 최대값을 가지는 index를 리턴하는 함수 (=np.argmax)를 행별로 적용하려면?\n\nnp.argmax(a,axis=1)\n\narray([0, 1, 0, 2, 1])"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-19-7wk-2.html#범례추가",
    "href": "PP2023/posts/02_DataScience/2023-04-19-7wk-2.html#범례추가",
    "title": "07wk-2: Numpy 활용 (2)",
    "section": "범례추가",
    "text": "범례추가\n- 예시1\n\ny1= [1.0, 2.0, 3.0, 4.0]\ny2= [1.1, 2.2, 2.8, 0.0]\nplt.plot(y1,'--o',label='y1')\nplt.plot(y2,'--o',label='y2')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fd0c8ed6e80&gt;\n\n\n\n\n\n- 예시2\n\ny1= [1.0, 2.0, 3.0, 4.0]\ny2= [1.1, 2.2, 2.8, 0.0]\nplt.plot(y1,'--o',label=r'$y_1$')\nplt.plot(y2,'--o',label=r'$y_2$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fd0c8fcc2e0&gt;"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-19-7wk-2.html#변환을-의미하는-행렬",
    "href": "PP2023/posts/02_DataScience/2023-04-19-7wk-2.html#변환을-의미하는-행렬",
    "title": "07wk-2: Numpy 활용 (2)",
    "section": "변환을 의미하는 행렬",
    "text": "변환을 의미하는 행렬\n1-3. 아래는 우산모양의 scatter plot을 그릴 수 있는 \\((x_i,y_i)\\) 좌표값을 불러와서 시각화하는 코드이다.\n\n# 자료저장 \ndata_raw = np.array(pd.read_csv('https://raw.githubusercontent.com/guebin/2021IR/master/_notebooks/round2.csv')).T\ndata_raw\n\narray([[ 12,  12,  13, ..., 636, 636, 637],\n       [313, 314, 279, ..., 416, 417, 409]])\n\n\n\n# 저장된 자료를 x,y로 분해 \nx_raw,y_raw = data_raw\nx_raw,y_raw\n\n(array([ 12,  12,  13, ..., 636, 636, 637]),\n array([313, 314, 279, ..., 416, 417, 409]))\n\n\n\n# 시각화\nplt.figure(figsize=(6,6)) # 그림크기고정\nplt.plot(x_raw,y_raw,'o')\n\n\n\n\n1. x_raw와 y_raw를 각각 표준화하고 x, y에 저장하라. 결과를 시각화하라. 그리고 x, y를 바탕으로 data matrix를 다시 구성하라.\n(풀이)\n표준화\n\nx= (x_raw-np.mean(x_raw)) / np.std(x_raw,ddof=1)\ny= (y_raw-np.mean(y_raw)) / np.std(y_raw,ddof=1)\n\n시각화\n\nplt.figure(figsize=(6,6)) # 그림크기고정\nplt.plot(x,y,'o')\n\n\n\n\ndata matrix 재구성\n\ndata = np.array([x,y])\ndata\n\narray([[-1.79820085, -1.79820085, -1.79255336, ...,  1.72583347,\n         1.72583347,  1.73148096],\n       [-0.18390658, -0.17703046, -0.41769466, ...,  0.52433376,\n         0.53120988,  0.47620092]])\n\n\n2. 아래와 같은 규칙에 따라 \\((x_i,y_i)\\)를 \\((\\tilde{x}_i,\\tilde{y}_i\\))로 변환하라. 단 여기에서 \\(\\theta= \\frac{\\pi}{4}\\)로 가정한다.\n\n\\({\\tt xx}_i = \\tilde{x}_i = (\\cos\\theta) x_i - (\\sin\\theta) y_i\\)\n\\({\\tt yy}_i = \\tilde{y}_i = (\\sin\\theta) x_i + (\\cos\\theta) y_i\\)\n\n\\((x_i,y_i)\\)와 \\((\\tilde{x}_i, \\tilde{y}_i)\\)를 겹쳐서 시각화 하라. 이 변환이 의미하는 바는 무엇이라고 생각하는가?\n(풀이1)\n\ntheta = np.pi/4 \nxx = np.cos(theta)*x - np.sin(theta)*y\nyy = np.sin(theta)*x + np.cos(theta)*y\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'o', label=r'$(x,y)$') \nplt.plot(xx,yy,'o', label=r'$(xx,yy)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f79adb12490&gt;\n\n\n\n\n\n(풀이2)\n아래의 규칙을 다시 고려하자.\n\n\\({\\tt xx}_i = \\tilde{x}_i = (\\cos\\theta) x_i - (\\sin\\theta) y_i\\)\n\\({\\tt yy}_i = \\tilde{y}_i = (\\sin\\theta) x_i + (\\cos\\theta) y_i\\)\n\n이는 아래와 같이 재표현가능하다.\n\n\\(\\begin{cases} {\\tt xx}_1 = (\\cos\\theta)x_1 - (\\sin\\theta)y_1 \\\\ {\\tt yy}_1 = (\\sin\\theta)x_1 + (\\cos\\theta)y_1 \\end{cases}\\)\n\\(\\begin{cases} {\\tt xx}_2 = (\\cos\\theta)x_2 - (\\sin\\theta)y_2 \\\\ {\\tt yy}_2 = (\\sin\\theta)x_2 + (\\cos\\theta)y_2 \\end{cases}\\)\n\\(\\dots\\)\n\\(\\begin{cases} {\\tt xx}_n = (\\cos\\theta)x_n - (\\sin\\theta)y_1 \\\\ {\\tt yy}_n = (\\sin\\theta)x_n + (\\cos\\theta)y_n \\end{cases}\\)\n\n이는 다시 아래와 같이 재 표현가능하다.\n\n\\(\\begin{bmatrix} {\\tt xx}_1 \\\\ {\\tt yy}_1 \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ y_1 \\end{bmatrix}\\)\n\\(\\begin{bmatrix} {\\tt xx}_2 \\\\ {\\tt yy}_2 \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_2 \\\\ y_2 \\end{bmatrix}\\)\n\\(\\dots\\)\n\\(\\begin{bmatrix} {\\tt xx}_n \\\\ {\\tt yy}_n \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_n \\\\ y_n \\end{bmatrix}\\)\n\n이는 다시 아래와 같이 재 표현가능하다. (이게 처음엔 생각하기 어려워요!! \\(\\star\\star\\star\\))\n\n\\(\\begin{bmatrix} {\\tt xx}_1 & {\\tt xx}_2 & \\dots & {\\tt xx}_n \\\\ {\\tt yy}_1 & {\\tt yy}_2 & \\dots & {\\tt yy}_n \\end{bmatrix} = \\begin{bmatrix} \\cos\\theta & - \\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix} \\begin{bmatrix} x_1 & x_2 & \\dots & x_n \\\\ y_1 & y_2 & \\dots & y_n \\end{bmatrix}\\)\n\n위의 수식에 맞추어 변환을 진행하면\n\ntheta = np.pi/4 \nR = np.array([[np.cos(theta), -np.sin(theta)],[np.sin(theta),np.cos(theta)]])\nR \n\narray([[ 0.70710678, -0.70710678],\n       [ 0.70710678,  0.70710678]])\n\n\n\nR @ data\n\narray([[-1.14147842, -1.14634057, -0.97217191, ...,  0.8495886 ,\n         0.84472644,  0.88761703],\n       [-1.40156161, -1.39669946, -1.56288136, ...,  1.59110851,\n         1.59597066,  1.56106683]])\n\n\n\nxx,yy = R @ data \n\n\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'o', label=r'$(x,y)$') \nplt.plot(xx,yy,'o', label=r'$(xx,yy)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f79b231b940&gt;\n\n\n\n\n\n3. 2번과 같은 변환을 8번 연속진행한 결과를 시각화하라.\n(풀이)\n\nplt.figure(figsize=(6,6))\nxx,yy=np.linalg.matrix_power(R,8) @ data\nplt.plot(x,y,'o',label=r'$data=(x,y)$') \nplt.plot(xx,yy,'o',label=r'$R^8@data=(xx,yy)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f79b2198220&gt;\n\n\n\n\n\n4. 2번의 변환을 역변환하는 코드를 구현하라. 원본, 변환, 역변환한 자료를 순서대로 시각화 하라. 결과를 아래와 같이 저장하라.\n\n원본: \\({\\tt x}, {\\tt y}\\)\n2번변환: \\({\\tt xx}, {\\tt yy}\\)\n2번의역변환 \\({\\tt xxx}, {\\tt yyy}\\)\n\n(풀이)\n\nxx,yy = R@data \nxxx,yyy = np.linalg.inv(R)@data\n\n\nplt.figure(figsize=(6,6))\nplt.plot(x,y,'.', label=r'$data = (x,y)$') \nplt.plot(xx,yy,'.', label=r'$R@data = (xx,yy)$')\nplt.plot(xxx,yyy,'.', label=r'$R^{-1}@data = (xxx,yyy)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f79b208d3d0&gt;\n\n\n\n\n\n5-8. 시계열 자료와 이동평균\n5. 아래의 수식에 따르는 수열 \\(x_t\\)를 생성하라. 단, \\(T=1000\\) 으로 설정하고 랜덤시드는 np.random.seed(2)와 같이 설정한다.\n\n\\(x_1=\\epsilon_1\\)\n\\(x_2=\\epsilon_1+\\epsilon_2\\)\n\\(x_3=\\epsilon_1+\\epsilon_2+\\epsilon_3\\)\n\\(\\dots\\)\n\\(x_T=\\sum_{t=1}^{T} \\epsilon_t\\)\n\n생성결과를 시각화하라.\nhint 아래의 코드를 활용하면 쉽다.\n\nnp.cumsum([1,2,3,4])\n\narray([ 1,  3,  6, 10])\n\n\n(풀이)\n\nT = 1000\nnp.random.seed(2)\nepsilon = np.random.randn(1000)\nx = epsilon.cumsum()\nplt.plot(x)\n\n\n\n\n6. 아래와 같은 변환을 수행하고 결과를 시각화 하라.\n\n\\({\\tt xx}_1= \\frac{1}{3}(x_1+x_2)\\)\n\\({\\tt xx}_2= \\frac{1}{3}(x_1+x_2+x_3)\\)\n\\({\\tt xx}_3= \\frac{1}{3}(x_2+x_3+x_4)\\)\n\\(\\dots\\)\n\\({\\tt xx}_{T-1}= \\frac{1}{3}(x_{T-1}+x_{T-1}+x_T)\\)\n\\({\\tt xx}_{T}= \\frac{1}{3}(x_{T-1}+x_T)\\)\n\nhint 아래의 수식을 이용하라.\n\n\\(\\begin{bmatrix} {\\tt xx}_1 \\\\ {\\tt xx}_2 \\\\ {\\tt xx}_3 \\\\ \\dots \\\\ {\\tt xx}_{T-1} \\\\ {\\tt xx}_T \\end{bmatrix}= \\begin{bmatrix} 1/3 & 1/3 & 0 & 0 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ 1/3 & 1/3 & 1/3 & 0 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ 0 & 1/3 & 1/3 & 1/3 & 0 & \\dots & 0 & 0 & 0 & 0 \\\\ \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots & \\dots \\\\ 0 & 0 & 0 & 0 & 0 & \\dots & 0 & 1/3 & 1/3 & 1/3 \\\\ 0 & 0 & 0 & 0 & 0 & \\dots & 0 & 0 & 1/3 & 1/3 \\\\ \\end{bmatrix}\\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_3 \\\\ \\dots \\\\ x_{T-1} \\\\ x_T \\end{bmatrix}\\)\n\n(풀이)\n\nM = np.array([[abs(i-j)&lt;2 for i in range(T)] for j in range(T)])*1/3\nM\n\narray([[0.33333333, 0.33333333, 0.        , ..., 0.        , 0.        ,\n        0.        ],\n       [0.33333333, 0.33333333, 0.33333333, ..., 0.        , 0.        ,\n        0.        ],\n       [0.        , 0.33333333, 0.33333333, ..., 0.        , 0.        ,\n        0.        ],\n       ...,\n       [0.        , 0.        , 0.        , ..., 0.33333333, 0.33333333,\n        0.        ],\n       [0.        , 0.        , 0.        , ..., 0.33333333, 0.33333333,\n        0.33333333],\n       [0.        , 0.        , 0.        , ..., 0.        , 0.33333333,\n        0.33333333]])\n\n\n\nplt.plot(x,label=r'$x$')\nplt.plot(M@x,'--',label=r'$M@x$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fd9917e2670&gt;\n\n\n\n\n\n\n끝이 올라간 이유? 마지막에 \\(\\frac{1}{3}(x_{T-1}+x_T+x_{T+1})\\) 대신에 \\(\\frac{1}{3}(x_{T-1}+x_T+0)\\) 을 이용하였기 때문\n\n7. 아래와 같은 변환을 수행하고 결과를 시각화하라.\n\n\\({\\tt xx}_1= \\frac{1}{3}(x_1+x_1+x_2)\\)\n\\({\\tt xx}_2= \\frac{1}{3}(x_1+x_2+x_3)\\)\n\\({\\tt xx}_3= \\frac{1}{3}(x_2+x_3+x_4)\\)\n\\(\\dots\\)\n\\({\\tt xx}_{T-1}= \\frac{1}{3}(x_{T-1}+x_{T-1}+x_T)\\)\n\\({\\tt xx}_{T}= \\frac{1}{3}(x_{T-1}+x_T+x_T)\\)\n\n(풀이)\n\nM[0,0] = 2/3 \nM[-1,-1] = 2/3 \nplt.plot(x,label=r'$x$')\nplt.plot(M@x,label=r'$M@x$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fd96893a190&gt;\n\n\n\n\n\n8. 7번의 변환을 100번 반복하고 시각화하라.\n(풀이)\n\nplt.plot(x,label=r'$x$')\nplt.plot(np.linalg.matrix_power(M,100)@x,label=r'$M^{100}@x$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fd9687943d0&gt;\n\n\n\n\n\n9. 7번의 변환을 1000번 반복하고 시각화하라.\n\nplt.plot(x,label=r'$x$')\nplt.plot(np.linalg.matrix_power(M,1000)@x,label=r'$M^{1000}@x$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7fd96862aac0&gt;"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#전치",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#전치",
    "title": "08wk-2: Pandas (2)",
    "section": "전치",
    "text": "전치\n\narr = np.arange(2*3).reshape(2,3)\ndf = pd.DataFrame(arr)\ndf\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n\ndf.T\n\n\n\n\n\n\n\n\n0\n1\n\n\n\n\n0\n0\n3\n\n\n1\n1\n4\n\n\n2\n2\n5"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#합",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#합",
    "title": "08wk-2: Pandas (2)",
    "section": "합",
    "text": "합\n\ndf\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n\ndf.sum(axis=0)\n\n0    3\n1    5\n2    7\ndtype: int64\n\n\n\ndf.sum(axis=1)\n\n0     3\n1    12\ndtype: int64"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#cumsum",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#cumsum",
    "title": "08wk-2: Pandas (2)",
    "section": "cumsum",
    "text": "cumsum\n\ndf\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n\ndf.cumsum(axis=1) \n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n3\n\n\n1\n3\n7\n12"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#형태변환",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#형태변환",
    "title": "08wk-2: Pandas (2)",
    "section": "형태변환",
    "text": "형태변환\n\ndf\n\n\n\n\n\n\n\n\n0\n1\n2\n\n\n\n\n0\n0\n1\n2\n\n\n1\n3\n4\n5\n\n\n\n\n\n\n\n\ndf.to_dict()\n\n{0: {0: 0, 1: 3}, 1: {0: 1, 1: 4}, 2: {0: 2, 1: 5}}\n\n\n\ndf.to_numpy()\n\narray([[0, 1, 2],\n       [3, 4, 5]])\n\n\n\ndf.to_numpy().tolist()\n\n[[0, 1, 2], [3, 4, 5]]"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#기타메소드..-생략",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#기타메소드..-생략",
    "title": "08wk-2: Pandas (2)",
    "section": "기타메소드.. 생략…",
    "text": "기타메소드.. 생략…"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#query-star",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#query-star",
    "title": "08wk-2: Pandas (2)",
    "section": "query (\\(\\star\\))",
    "text": "query (\\(\\star\\))\n- 예제1: att==90 and fin&gt;30\n\ndf.query('att ==90 and fin &gt;30')\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12354\n90\n90\n80\n90\n\n\n\n\n\n\n\n- 예제2: att&lt;rep and mid&lt;fin\n\ndf.query('att&lt;rep and mid&lt;fin')\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12458\n50\n55\n15\n85\n\n\n\n\n\n\n\n- 예제3: att &lt; rep &lt; 80\n\ndf.query('att&lt;rep&lt;80')\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12318\n55\n75\n35\n25\n\n\n2022-12458\n50\n55\n15\n85\n\n\n\n\n\n\n\n- 예제4: 50 &lt; att &lt;= 90 and mid &lt; fin\n\ndf.query('50&lt;att&lt;=90 and mid&lt;fin')\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n2022-12463\n65\n45\n45\n90\n\n\n2022-12452\n65\n55\n15\n45\n\n\n2022-12354\n90\n90\n80\n90\n\n\n\n\n\n\n\n- 예제5: (mid+fin)/2 &gt;=60\n\ndf.query('(mid+fin)/2&gt;=60')\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n2022-12463\n65\n45\n45\n90\n\n\n2022-12396\n95\n30\n30\n95\n\n\n2022-12354\n90\n90\n80\n90\n\n\n\n\n\n\n\n- 예제6: att &gt; mean(att)\n\n_mean = df['att'].mean() \n_mean \n\n73.0\n\n\n\ndf.query('att&gt; @_mean')\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n2022-12377\n75\n40\n100\n15\n\n\n2022-12400\n95\n65\n20\n10\n\n\n2022-12469\n90\n80\n80\n20\n\n\n2022-12432\n95\n95\n45\n0\n\n\n2022-12443\n95\n55\n15\n35\n\n\n2022-12396\n95\n30\n30\n95\n\n\n2022-12354\n90\n90\n80\n90"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#시계열자료",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#시계열자료",
    "title": "08wk-2: Pandas (2)",
    "section": "시계열자료",
    "text": "시계열자료\n- 시계열자료\n\npd.date_range('20211226',periods=10)\n\nDatetimeIndex(['2021-12-26', '2021-12-27', '2021-12-28', '2021-12-29',\n               '2021-12-30', '2021-12-31', '2022-01-01', '2022-01-02',\n               '2022-01-03', '2022-01-04'],\n              dtype='datetime64[ns]', freq='D')\n\n\n\ndf=pd.DataFrame(np.random.normal(size=(10,4)),columns=list('ABCD'),index=pd.date_range('20211226',periods=10))\ndf\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n2021-12-26\n0.638090\n-0.706648\n0.214164\n1.683409\n\n\n2021-12-27\n-0.922290\n0.614785\n0.405039\n0.034917\n\n\n2021-12-28\n0.402721\n-0.066538\n1.015060\n-2.030076\n\n\n2021-12-29\n0.117482\n-0.241408\n-0.178216\n-0.594159\n\n\n2021-12-30\n-1.178254\n0.334073\n0.108820\n-1.038094\n\n\n2021-12-31\n0.903143\n0.390493\n0.793207\n-0.855129\n\n\n2022-01-01\n-0.146165\n0.109616\n-0.811606\n-0.224088\n\n\n2022-01-02\n0.318889\n-0.817596\n1.300542\n0.576502\n\n\n2022-01-03\n-0.252256\n-1.078405\n-0.569968\n-1.664744\n\n\n2022-01-04\n-0.252979\n0.334156\n-0.756330\n-0.367841\n\n\n\n\n\n\n\n- 예제1: 시계열자료에서의 인덱싱\n\ndf.loc['2021-12-28':'2022-01-02',:]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n2021-12-28\n0.402721\n-0.066538\n1.015060\n-2.030076\n\n\n2021-12-29\n0.117482\n-0.241408\n-0.178216\n-0.594159\n\n\n2021-12-30\n-1.178254\n0.334073\n0.108820\n-1.038094\n\n\n2021-12-31\n0.903143\n0.390493\n0.793207\n-0.855129\n\n\n2022-01-01\n-0.146165\n0.109616\n-0.811606\n-0.224088\n\n\n2022-01-02\n0.318889\n-0.817596\n1.300542\n0.576502\n\n\n\n\n\n\n\n- 예제3: 스트라이딩 (샘플링)\n\ndf.loc[::3,:]\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n2021-12-26\n0.638090\n-0.706648\n0.214164\n1.683409\n\n\n2021-12-29\n0.117482\n-0.241408\n-0.178216\n-0.594159\n\n\n2022-01-01\n-0.146165\n0.109616\n-0.811606\n-0.224088\n\n\n2022-01-04\n-0.252979\n0.334156\n-0.756330\n-0.367841\n\n\n\n\n\n\n\n- 예제4: query를 이용한 인덱싱\n\ndf.query(\"index &lt;= '2021-12-30' or index=='2022-01-02'\")\n\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\n2021-12-26\n0.638090\n-0.706648\n0.214164\n1.683409\n\n\n2021-12-27\n-0.922290\n0.614785\n0.405039\n0.034917\n\n\n2021-12-28\n0.402721\n-0.066538\n1.015060\n-2.030076\n\n\n2021-12-29\n0.117482\n-0.241408\n-0.178216\n-0.594159\n\n\n2021-12-30\n-1.178254\n0.334073\n0.108820\n-1.038094\n\n\n2022-01-02\n0.318889\n-0.817596\n1.300542\n0.576502"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#더러운-자료-1",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#더러운-자료-1",
    "title": "08wk-2: Pandas (2)",
    "section": "더러운 자료 (1)",
    "text": "더러운 자료 (1)\n예비학습: 하나의 col을 선택하는 가장 좋은 방법\n\nnp.random.seed(43052)\natt = np.random.choice(np.arange(10,21)*5,20)\nrep = np.random.choice(np.arange(5,21)*5,20)\nmid = np.random.choice(np.arange(0,21)*5,20)\nfin = np.random.choice(np.arange(0,21)*5,20)\nkey = ['2022-12'+str(s) for s in np.random.choice(np.arange(300,501),20,replace=False)]\ndf = pd.DataFrame({'att':att,'rep':rep,'mid':mid,'fin':fin},index=key)\ndf.head()\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n\n\n\n\n\n- att 선택\n\ndf.att\n\n2022-12380    65\n2022-12370    95\n2022-12363    65\n2022-12488    55\n2022-12312    80\n2022-12377    75\n2022-12463    65\n2022-12471    60\n2022-12400    95\n2022-12469    90\n2022-12318    55\n2022-12432    95\n2022-12443    95\n2022-12367    50\n2022-12458    50\n2022-12396    95\n2022-12482    50\n2022-12452    65\n2022-12387    70\n2022-12354    90\nName: att, dtype: int64\n\n\n- 단점: 칼럼이름에 스페이스가 있으면 쓸 수 없음.\n예비학습끝\n\n- 누가 자료를 아래와 같이 주었다고 하자. (엑셀특)\n\ndf.columns = pd.Index(['att score', 'rep score', 'mid score', 'fin score'])\ndf.head()\n\n\n\n\n\n\n\n\natt score\nrep score\nmid score\nfin score\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n\n\n\n\n\n- 출석점수를 뽑고 싶다면?\n\ndf['att score']\n# df.att score # 이코드는 실행불가능\n\n2022-12380    65\n2022-12370    95\n2022-12363    65\n2022-12488    55\n2022-12312    80\n2022-12377    75\n2022-12463    65\n2022-12471    60\n2022-12400    95\n2022-12469    90\n2022-12318    55\n2022-12432    95\n2022-12443    95\n2022-12367    50\n2022-12458    50\n2022-12396    95\n2022-12482    50\n2022-12452    65\n2022-12387    70\n2022-12354    90\nName: att score, dtype: int64\n\n\n- 출석점수가 90보다 작은 학생을 뽑고 싶다면?\n\ndf.loc[df['att score'] &lt; 90, :] \n# df.query('att score &lt; 90')\n\n\n\n\n\n\n\n\natt score\nrep score\nmid score\nfin score\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n2022-12377\n75\n40\n100\n15\n\n\n2022-12463\n65\n45\n45\n90\n\n\n2022-12471\n60\n60\n25\n0\n\n\n2022-12318\n55\n75\n35\n25\n\n\n2022-12367\n50\n80\n40\n30\n\n\n2022-12458\n50\n55\n15\n85\n\n\n2022-12482\n50\n50\n45\n10\n\n\n2022-12452\n65\n55\n15\n45\n\n\n2022-12387\n70\n70\n40\n35\n\n\n\n\n\n\n\n- 그냥 컬럼이름을 바꾸고 하는것도 방법임\n\ndf.columns = pd.Index([l.replace(' ','_') for l in list(df.columns)])\ndf.head()\n\n\n\n\n\n\n\n\natt_score\nrep_score\nmid_score\nfin_score\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n\n\n\n\n\n\ndf.query('att_score&lt;90')\ndf.att_score\n\n2022-12380    65\n2022-12370    95\n2022-12363    65\n2022-12488    55\n2022-12312    80\n2022-12377    75\n2022-12463    65\n2022-12471    60\n2022-12400    95\n2022-12469    90\n2022-12318    55\n2022-12432    95\n2022-12443    95\n2022-12367    50\n2022-12458    50\n2022-12396    95\n2022-12482    50\n2022-12452    65\n2022-12387    70\n2022-12354    90\nName: att_score, dtype: int64\n\n\n- 그렇지만 col이름을 바꾸는게 항상 만능은 아니다."
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#개인습관",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#개인습관",
    "title": "08wk-2: Pandas (2)",
    "section": "개인습관",
    "text": "개인습관\n- row의 이름은 없는게 낫다고 생각함 // 시계열자료는 예외\n\nnp.random.seed(43052)\natt = np.random.choice(np.arange(10,21)*5,20)\nrep = np.random.choice(np.arange(5,21)*5,20)\nmid = np.random.choice(np.arange(0,21)*5,20)\nfin = np.random.choice(np.arange(0,21)*5,20)\nkey = ['2022-12'+str(s) for s in np.random.choice(np.arange(300,501),20,replace=False)]\ndf = pd.DataFrame({'att':att,'rep':rep,'mid':mid,'fin':fin},index=key)\ndf.head()\n\n\n\n\n\n\n\n\natt\nrep\nmid\nfin\n\n\n\n\n2022-12380\n65\n55\n50\n40\n\n\n2022-12370\n95\n100\n50\n80\n\n\n2022-12363\n65\n90\n60\n30\n\n\n2022-12488\n55\n80\n75\n80\n\n\n2022-12312\n80\n30\n30\n100\n\n\n\n\n\n\n\n\ndf2 = df.reset_index().rename(columns={'index':'student_id'})\ndf2.head()\n\n\n\n\n\n\n\n\nstudent_id\natt\nrep\nmid\nfin\n\n\n\n\n0\n2022-12380\n65\n55\n50\n40\n\n\n1\n2022-12370\n95\n100\n50\n80\n\n\n2\n2022-12363\n65\n90\n60\n30\n\n\n3\n2022-12488\n55\n80\n75\n80\n\n\n4\n2022-12312\n80\n30\n30\n100\n\n\n\n\n\n\n\n- 편해\n\n#df2.loc[0,'student_id':'rep'] \n#df2.loc[[0],'student_id':'rep'] \n#df2.loc[[0,4,5],'student_id':'rep'] \n#df2.loc[range(5),'student_id':'rep'] \n#df2.loc[5::2,'student_id':'rep'] \n\n\n\n\n\n\n\n\nstudent_id\natt\nrep\n\n\n\n\n0\n2022-12380\n65\n55\n\n\n1\n2022-12370\n95\n100\n\n\n2\n2022-12363\n65\n90\n\n\n3\n2022-12488\n55\n80\n\n\n4\n2022-12312\n80\n30"
  },
  {
    "objectID": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#새로운-열의-추가-starstarstar",
    "href": "PP2023/posts/02_DataScience/2023-04-26-8wk-2.html#새로운-열의-추가-starstarstar",
    "title": "08wk-2: Pandas (2)",
    "section": "새로운 열의 추가 (\\(\\star\\star\\star\\))",
    "text": "새로운 열의 추가 (\\(\\star\\star\\star\\))\n- 자료\n\nnp.random.seed(43052)\natt = np.random.choice(np.arange(10,21)*5,20)\nrep = np.random.choice(np.arange(5,21)*5,20)\nmid = np.random.choice(np.arange(0,21)*5,20)\nfin = np.random.choice(np.arange(0,21)*5,20)\nstudent_id = [ '2023-12362', '2022-12471', '2023-12333', '2022-12400', '2022-12377',\n               '2022-12469', '2023-12314', '2022-12363', '2023-12445', '2023-12336',\n               '2023-12426', '2022-12380', '2023-12422', '2022-12488', '2022-12370',\n               '2023-12443', '2022-12463', '2023-12491', '2023-12340', '2022-12312' ]\ndf = pd.DataFrame({'student_id':student_id,'att':att,'rep':rep,'mid':mid,'fin':fin})\ndf\n\n\n\n\n\n\n\n\nstudent_id\natt\nrep\nmid\nfin\n\n\n\n\n0\n2023-12362\n65\n55\n50\n40\n\n\n1\n2022-12471\n95\n100\n50\n80\n\n\n2\n2023-12333\n65\n90\n60\n30\n\n\n3\n2022-12400\n55\n80\n75\n80\n\n\n4\n2022-12377\n80\n30\n30\n100\n\n\n5\n2022-12469\n75\n40\n100\n15\n\n\n6\n2023-12314\n65\n45\n45\n90\n\n\n7\n2022-12363\n60\n60\n25\n0\n\n\n8\n2023-12445\n95\n65\n20\n10\n\n\n9\n2023-12336\n90\n80\n80\n20\n\n\n10\n2023-12426\n55\n75\n35\n25\n\n\n11\n2022-12380\n95\n95\n45\n0\n\n\n12\n2023-12422\n95\n55\n15\n35\n\n\n13\n2022-12488\n50\n80\n40\n30\n\n\n14\n2022-12370\n50\n55\n15\n85\n\n\n15\n2023-12443\n95\n30\n30\n95\n\n\n16\n2022-12463\n50\n50\n45\n10\n\n\n17\n2023-12491\n65\n55\n15\n45\n\n\n18\n2023-12340\n70\n70\n40\n35\n\n\n19\n2022-12312\n90\n90\n80\n90\n\n\n\n\n\n\n\n- 방법1: assign을 이용한 추가\n\ndf.assign(total = df.att*0.1 + df.rep*0.2 + df.mid*0.3 + df.fin*0.4) \n\n\n\n\n\n\n\n\nstudent_id\natt\nrep\nmid\nfin\ntotal\n\n\n\n\n0\n2023-12362\n65\n55\n50\n40\n48.5\n\n\n1\n2022-12471\n95\n100\n50\n80\n76.5\n\n\n2\n2023-12333\n65\n90\n60\n30\n54.5\n\n\n3\n2022-12400\n55\n80\n75\n80\n76.0\n\n\n4\n2022-12377\n80\n30\n30\n100\n63.0\n\n\n5\n2022-12469\n75\n40\n100\n15\n51.5\n\n\n6\n2023-12314\n65\n45\n45\n90\n65.0\n\n\n7\n2022-12363\n60\n60\n25\n0\n25.5\n\n\n8\n2023-12445\n95\n65\n20\n10\n32.5\n\n\n9\n2023-12336\n90\n80\n80\n20\n57.0\n\n\n10\n2023-12426\n55\n75\n35\n25\n41.0\n\n\n11\n2022-12380\n95\n95\n45\n0\n42.0\n\n\n12\n2023-12422\n95\n55\n15\n35\n39.0\n\n\n13\n2022-12488\n50\n80\n40\n30\n45.0\n\n\n14\n2022-12370\n50\n55\n15\n85\n54.5\n\n\n15\n2023-12443\n95\n30\n30\n95\n62.5\n\n\n16\n2022-12463\n50\n50\n45\n10\n32.5\n\n\n17\n2023-12491\n65\n55\n15\n45\n40.0\n\n\n18\n2023-12340\n70\n70\n40\n35\n47.0\n\n\n19\n2022-12312\n90\n90\n80\n90\n87.0\n\n\n\n\n\n\n\n- 방법2: eval을 이용한 추가\n\ndf.eval('total = att*0.1 + rep*0.2 + mid*0.3 + fin*0.4') \n\n\n\n\n\n\n\n\nstudent_id\natt\nrep\nmid\nfin\ntotal\n\n\n\n\n0\n2023-12362\n65\n55\n50\n40\n48.5\n\n\n1\n2022-12471\n95\n100\n50\n80\n76.5\n\n\n2\n2023-12333\n65\n90\n60\n30\n54.5\n\n\n3\n2022-12400\n55\n80\n75\n80\n76.0\n\n\n4\n2022-12377\n80\n30\n30\n100\n63.0\n\n\n5\n2022-12469\n75\n40\n100\n15\n51.5\n\n\n6\n2023-12314\n65\n45\n45\n90\n65.0\n\n\n7\n2022-12363\n60\n60\n25\n0\n25.5\n\n\n8\n2023-12445\n95\n65\n20\n10\n32.5\n\n\n9\n2023-12336\n90\n80\n80\n20\n57.0\n\n\n10\n2023-12426\n55\n75\n35\n25\n41.0\n\n\n11\n2022-12380\n95\n95\n45\n0\n42.0\n\n\n12\n2023-12422\n95\n55\n15\n35\n39.0\n\n\n13\n2022-12488\n50\n80\n40\n30\n45.0\n\n\n14\n2022-12370\n50\n55\n15\n85\n54.5\n\n\n15\n2023-12443\n95\n30\n30\n95\n62.5\n\n\n16\n2022-12463\n50\n50\n45\n10\n32.5\n\n\n17\n2023-12491\n65\n55\n15\n45\n40.0\n\n\n18\n2023-12340\n70\n70\n40\n35\n47.0\n\n\n19\n2022-12312\n90\n90\n80\n90\n87.0\n\n\n\n\n\n\n\n- 방법3: df['total'] 을 이용한 할당 // 추천X\n\ndf['total'] = df.att*0.1 + df.rep*0.2 + df.mid*0.3 + df.fin*0.4\ndf\n\n\n\n\n\n\n\n\nstudent_id\natt\nrep\nmid\nfin\ntotal\n\n\n\n\n0\n2023-12362\n65\n55\n50\n40\n48.5\n\n\n1\n2022-12471\n95\n100\n50\n80\n76.5\n\n\n2\n2023-12333\n65\n90\n60\n30\n54.5\n\n\n3\n2022-12400\n55\n80\n75\n80\n76.0\n\n\n4\n2022-12377\n80\n30\n30\n100\n63.0\n\n\n5\n2022-12469\n75\n40\n100\n15\n51.5\n\n\n6\n2023-12314\n65\n45\n45\n90\n65.0\n\n\n7\n2022-12363\n60\n60\n25\n0\n25.5\n\n\n8\n2023-12445\n95\n65\n20\n10\n32.5\n\n\n9\n2023-12336\n90\n80\n80\n20\n57.0\n\n\n10\n2023-12426\n55\n75\n35\n25\n41.0\n\n\n11\n2022-12380\n95\n95\n45\n0\n42.0\n\n\n12\n2023-12422\n95\n55\n15\n35\n39.0\n\n\n13\n2022-12488\n50\n80\n40\n30\n45.0\n\n\n14\n2022-12370\n50\n55\n15\n85\n54.5\n\n\n15\n2023-12443\n95\n30\n30\n95\n62.5\n\n\n16\n2022-12463\n50\n50\n45\n10\n32.5\n\n\n17\n2023-12491\n65\n55\n15\n45\n40.0\n\n\n18\n2023-12340\n70\n70\n40\n35\n47.0\n\n\n19\n2022-12312\n90\n90\n80\n90\n87.0\n\n\n\n\n\n\n\n- 아래의 자료에서 입학년도를 추가하고 싶다면?\n\nnp.random.seed(43052)\natt = np.random.choice(np.arange(10,21)*5,20)\nrep = np.random.choice(np.arange(5,21)*5,20)\nmid = np.random.choice(np.arange(0,21)*5,20)\nfin = np.random.choice(np.arange(0,21)*5,20)\nstudent_id = [ '2023-12362', '2022-12471', '2023-12333', '2022-12400', '2022-12377',\n               '2022-12469', '2023-12314', '2022-12363', '2023-12445', '2023-12336',\n               '2023-12426', '2022-12380', '2023-12422', '2022-12488', '2022-12370',\n               '2023-12443', '2022-12463', '2023-12491', '2023-12340', '2022-12312' ]\ndf = pd.DataFrame({'student_id':student_id,'att':att,'rep':rep,'mid':mid,'fin':fin})\n\n\ndf.assign(year=[l.split('-')[0] for l in list(df.student_id)]).query('year==\"2022\"')\n\n\n\n\n\n\n\n\nstudent_id\natt\nrep\nmid\nfin\nyear\n\n\n\n\n1\n2022-12471\n95\n100\n50\n80\n2022\n\n\n3\n2022-12400\n55\n80\n75\n80\n2022\n\n\n4\n2022-12377\n80\n30\n30\n100\n2022\n\n\n5\n2022-12469\n75\n40\n100\n15\n2022\n\n\n7\n2022-12363\n60\n60\n25\n0\n2022\n\n\n11\n2022-12380\n95\n95\n45\n0\n2022\n\n\n13\n2022-12488\n50\n80\n40\n30\n2022\n\n\n14\n2022-12370\n50\n55\n15\n85\n2022\n\n\n16\n2022-12463\n50\n50\n45\n10\n2022\n\n\n19\n2022-12312\n90\n90\n80\n90\n2022"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#학점",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#학점",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "학점",
    "text": "학점\n- Linear Input & Linear Output\n\n이상: 노력과 점수는 비례 & 점수와 학점이 비례\n현실: 노력과 점수는 비례X & 점수와 학점은??\n\n- [300, 300, 100, 90, 41, 40, 40, 30, 20] 인 학생들의 학점을 나누는 방법?"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#chatgpt",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#chatgpt",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "ChatGPT",
    "text": "ChatGPT\n- 잘 쓰는 방법 (일반적)\n\n질문을 잘해야.. + 많이 쓰는 언어를 질문 해야.. +\n프롬프트 엔지니어: https://www.hani.co.kr/arti/economy/it/1084265.html\n\n- 잘 쓰는 방법 (제 생각)\n\n기계가 이해할 수 있는 subgoal을 잘 만들어야 함.\n결국 “모호한 하나의 문제 \\(\\Rightarrow\\) 모호하지 않은 여러개의 문제” 로 바꾸는 능력이 필요.\n\n\n\n\n그림1: ChatGPT의 잘못된 사용예시"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#학생들에게-하고-싶은-말-1",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#학생들에게-하고-싶은-말-1",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "학생들에게 하고 싶은 말 (1)",
    "text": "학생들에게 하고 싶은 말 (1)\n- 성장과 분배\n- 본인의 역량을 분배하는 방식에 대해서도 생각해 보세요"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#학생들에게-하고-싶은-말-2",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#학생들에게-하고-싶은-말-2",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "학생들에게 하고 싶은 말 (2)",
    "text": "학생들에게 하고 싶은 말 (2)\n- 중요한 것은 꺾이지 않는 마음\n- 기말 잘보면 됩니다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#중꺾마의-시작",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#중꺾마의-시작",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "중꺾마의 시작",
    "text": "중꺾마의 시작\n\nref: 나무위키\n\n- 중꺾마? “중요한 것은 꺾이지 않는 마음”의 줄임\n- 유래\n\n\n\n그림2: DEFT의 인터뷰\n\n\n2022년 월드 챔피언십 그룹 스테이지 1라운드 로그전에서 패배 후, 쿠키뉴스와의 인터뷰에서 데프트는 패배에 대한 감상을 질문 받자\n“오늘 지긴 했지만… 저희끼리만 안 무너지면 충분히 이길 수 있을 것 같아요”\n라고 답변했는데, 이 인터뷰를 했던 쿠키뉴스의 문대찬 기자가 해당 인터뷰 영상의 제목을 다음과 같이 지었다.\n\nDRX 데프트 “로그전 패배 괜찮아, 중요한 건 꺾이지 않는 마음”"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#중꺾마의-확산",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#중꺾마의-확산",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "중꺾마의 확산",
    "text": "중꺾마의 확산\n- 예시1: 스포츠 능력시험\n\nhttps://www.fmkorea.com/best/5223837966\n\n- 예시2: 한국 vs 포르투갈 (카타르 월드컵)\n\n\n\n그림3: 태극기에 쓰여진 중꺽마\n\n\n- 예시3: 중꺾마의 파급력 정리\n\nref: https://www.fmkorea.com/5212914486"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#중꺾마의-변형-및-확산",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#중꺾마의-변형-및-확산",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "중꺾마의 변형 및 확산",
    "text": "중꺾마의 변형 및 확산\n- 예시1: 중요한 것은 꺾이지 않는 할인\n\n\n\n그림4: 중꺽마의 변형\n\n\n- 예시2: 중요한건 꺾이지 않는 자기주도력\n\n\n\n그림5: 중꺽마의 변형\n\n\n- 예시3: 중요한 것은 꺾이지 않는 G-KPOP (강남구청 이벤트)\n\n\n\n그림6: 중꺽마의 변형\n\n\n- 예시4: 기타변형\n\n중요한 것은 다 꺾어버리는 마음: 같은 DRX 소속 게이머이자 철권 E스포츠계의 레전드로 불리는 무릎은 ’중요한 것은 다 꺾어버리는 마음’이라고 변형\n중요한 건: 포르투갈전을 본 데프트 김혁규 선수 본인도 인스타그램 스토리에 이 유행어를 일부 인용했다. 전체를 말한 것은 아니고 ’중요한 건…’이라고만 적었지만 의도한 바는 누가봐도 중꺾마.\n중요한 것은 꺾였는데도 그냥 하는 마음: 박명수"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#밈과-인터넷밈",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#밈과-인터넷밈",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "밈과 인터넷밈",
    "text": "밈과 인터넷밈\n- 밈이란? (유전자처럼) 복제가능한 something\n\n이기적 유전자에서 제시한 개념\n유전자는 (1) 복제 (2) 변형되면서 전파되는 속성이 있다는 사실을 관찰\n종교, 사상, 이념도 유전자처럼 (1) 복제 (2) 변형되면서 전파되더라..\n밈 = 유전자의 일반화된 개념 = 복제가능한 something\n\n- 인터넷 밈이란?\n\n밈의 한 형태\n인터넷을 통하여 (1)복제 (2)변형되면서 전파되는 something\n\n- 중꺾마의 확산예제들을 통해 살펴본 밈의 의미\n\n딱히 정형화 하기 어렵지만 위의 예제들은 복제가 되는 어떠한 원형이 있다. 이것을 밈(=유전자)이라고 부른다!!\n많은 사람들에게 그 복제내용이 확산되어 재생산된다. 이것을 밈화라고 한다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#클래스란-다른교재",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#클래스란-다른교재",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "클래스란? (다른교재)",
    "text": "클래스란? (다른교재)\n- 클래스의 정의\n\n많은 교재에서 정의를 회피한다.\n대신에 비유적으로 설명하거나 다른 대상을 가져와서 설명한다.\n\n- 클래스에 대한 비유적 설명 (implicit definition)\n\n점프투파이썬: 클래스는 과자틀과 비슷하다. 클래스란 똑같은 무엇인가를 계속 만들어 낼 수도 있는 설계도면이고 객체란 클래스로 만든 피조물을 뜻한다.\n위키피디아: In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods). // 객체 지향 프로그래밍에서 클래스는 상태(멤버 변수) 및 동작 구현(멤버 함수 또는 메서드)에 대한 초기 값을 제공하는 객체 생성을 위한 확장 가능한 프로그램 코드 템플릿입니다.\nTCP스쿨: 클래스(class)란 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용\n티스토리 블로그: 학생 클래스..?\n기타 서적들.. (진짜 무슨 한 챕터씩 설명하고 있음)"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#클래스란-제-생각",
    "href": "PP2023/posts/03_Class/2023-05-10-10wk-2.html#클래스란-제-생각",
    "title": "10wk-2: 밈과 클래스 (1)",
    "section": "클래스란? (제 생각)",
    "text": "클래스란? (제 생각)\n- 클래스에 대한 명시적 정의 (책에 나온것 아니고 제 생각입니다!!) - 클래스는 복제, 변형, 재생산을 용이하게 하기 위해 만들어진 확장가능한 프로그램의 코드의 단위(extensible program-code-template)이다. 즉 밈이다.\n- 클래스도 결국 밈이다. 생각해보면 클래스를 만들고 사용하는 과정이 인터넷에서 밈을 만들고 노는것과 닮아 있다.\n\n\n\n\n\n\n\n\n\n단계\n인터넷밈\n클래스\n레포트표지\n\n\n\n\n1단계: 구상\n\\(\\bullet\\) 이거 재미있다.  \\(\\bullet\\) 밈화하자.\n\\(\\bullet\\) 이 코드 반복해서 자주 쓸 것 같다.  \\(\\bullet\\) 이 코드를 쉽게 찍어내는 (복사할 수 있는) 클래스를 만들자\n\\(\\bullet\\) 레포트 표지를 자주 만들 것 같음  \\(\\bullet\\) 양식파일을 만들까?\n\n\n2단계: 틀생성\n\\(\\bullet\\) “밈틀”: 복사하고 싶은 속성을 추려 밈을 생산하기에 유리한 틀을 만듬\n\\(\\bullet\\) 클래스의 선언\n\\(\\bullet\\) REPORT_2023_최규빈.hwp 양식파일을 생성\n\n\n3단계: 틀 \\(\\to\\) 복제\n\\(\\bullet\\) 밈화: “밈틀”에서 다양한 밈을 만들고 놈\n\\(\\bullet\\) 인스턴스화: 클래스에서 인스턴스를 생산\n\\(\\bullet\\) 레포트 양식표지에서 다양한 레포트를 냄\n\n\n4단계: 틀 \\(\\to\\) 틀변경 \\(\\to\\) 복제\n\\(\\bullet\\) 생각해보니까 초기 밈틀은 시시함.  \\(\\bullet\\) 초기 밈틀을 수정해 새로운 밈틀을 만들고 더 재미있는 밈을 만들고 놈\n\\(\\bullet\\) 초기클래스와 비슷한 클래스를 선언할 일이 생김  \\(\\bullet\\) 상속,오버라이딩: 초기클래스를 상속받아 클래스를 새롭게 정의하고 인스턴스를 재 생산\n\\(\\bullet\\) 공모전에 참가하여 결과보고서를 작성할 일이 생김.  \\(\\bullet\\) REPORT_2023_최규빈.hwp 를 적당히 변형하여 수정된 틀을 만들고 결과보고서 생산."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-17-11wk-2.html#메소드-star",
    "href": "PP2023/posts/03_Class/2023-05-17-11wk-2.html#메소드-star",
    "title": "11wk-2: 클래스공부 1단계 – 메소드",
    "section": "메소드 (\\(\\star\\))",
    "text": "메소드 (\\(\\star\\))\n- 직관:\n\nshow라는 함수는 pp2023, burger 외부에 독립적으로 존재하는 함수.\nshow라는 함수를 과 같이pp2023.title과 pp2023 혹은 burger 안에 종속시키고 싶다.\n\n\n어차피 show는 pp2023, burger와 같이 JungKKuckMa의 인스턴스를 입력으로 받을 예정이므로 pp2023과 burger와 관련이 있다. 그래서 같이 묶는게 깔끔하다는 생각이 든다.\n\n- 시도1: 결국 pp2023.show와 같은 것을 만들고 싶은것이므로 pp2023.title 을 설정하듯이 해보자. \\(\\to\\) 실패\n\nclass JungKKuckMa:\n    pass\n\npp2023 = JungKKuckMa()\n\n\npp2023.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\npp2023.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\npp2023.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\npp2023.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\npp2023.highlight = '마음'\npp2023.html_str =\\\n'''\n&lt;style&gt;\n    .title {{\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }}\n    .text {{\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }}\n    .highlight {{\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }}\n&lt;/style&gt;\n&lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n&lt;img src={url} width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n&lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n'''\n\n\n# 원래코드 \n# def show(pp2023):\n#     _str = pp2023.html_str.format(\n#         ttl = pp2023.title,\n#         url = pp2023.imgurl,\n#         Q = pp2023.ques,\n#         A = pp2023.ans,\n#         hl = pp2023.highlight\n#     )\n#     display(HTML(_str))\n# 수정한코드 \ndef pp2023.show(pp2023):\n    _str = pp2023.html_str.format(\n        ttl = pp2023.title,\n        url = pp2023.imgurl,\n        Q = pp2023.ques,\n        A = pp2023.ans,\n        hl = pp2023.highlight\n    )\n    display(HTML(_str))\n\nSyntaxError: invalid syntax (&lt;ipython-input-12-7e81d9b4ed5c&gt;, line 12)\n\n\n실패했다..\n- 시도2: 성공\n\nclass JungKKuckMa:\n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str))\n# show함수를 그대로 넣고 pp2023을 self로 바꿈 \n\n\npp2023 = JungKKuckMa()\n\n(참고) 이 시점에 pp2023. + tab을 누르면 show 함수가 자동완성 된다.\n\npp2023.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\npp2023.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\npp2023.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\npp2023.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\npp2023.highlight = '마음'\npp2023.html_str =\\\n'''\n&lt;style&gt;\n    .title {{\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }}\n    .text {{\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }}\n    .highlight {{\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }}\n&lt;/style&gt;\n&lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n&lt;img src={url} width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n&lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n'''\n\n(참고) 이 시점에서 pp2023. + tab 을 하면 아래와 같이 보인다. (pp2023 내부에는 ans,highlight, html_str 등과 함께 show도 포함되어있음)\n\n\npp2023.show() \n\n# pp2023.show의 입력을 생략해도, pp2023 자체는 자동으로 입력대상으로 고려 \n\n\n\n파이썬 프로그래밍 중간고사 패배는 괜찮다.\n\n \n \nQ: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\nA: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\n중요한 것은 꺾이지 않는 마음\n\n\n- 암기\n\n선언하는 방법: 외부에 선언한 show의 코드를 그대로 복붙하여 Class안으로 가져온다. \\(\\to\\) pp2023이라고 되었던 부분을 모두 self로 바꾼다!\n사용하는 방법: pp2023의 내부에 소속된 함수 (ex: pp2023.show) 를 사용할때는, 함수의 사용에 pp2023의 정보를 쓰더라도 (ex: pp2023.title 등), 입력으로 pp2023을 생략한다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-17-11wk-2.html#self의-의미-star",
    "href": "PP2023/posts/03_Class/2023-05-17-11wk-2.html#self의-의미-star",
    "title": "11wk-2: 클래스공부 1단계 – 메소드",
    "section": "self의 의미 (\\(\\star\\))",
    "text": "self의 의미 (\\(\\star\\))\n- 아래의 코드를 다시 관찰하자.\n\nclass JungKKuckMa:\n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str))\n# show함수를 그대로 넣고 pp2023을 self로 바꿈 \n\n\npp2023 = JungKKuckMa()\n\n- 관찰\n\nself는 pp2023 혹은 burger 에 대응한다.\n즉 self는 JungKKuckMa 클래스에서 생성할 인스턴스의 이름에 대응한다.\n비유하면 self는 JungKKuckMa 에서 태어날 아기의 이름을 대신한다.\n\n- 우리가 하고 싶은 것: 클래스가 설계되는 시점에서, 클래스가 설계완료되고 그 후에 태어날 인스턴스의 이름을 이용해 show 함수의 동작을 define 하는 것\n- 즉 아래의 코드에서\n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str))\ndef show 이후에 서술된 모든 내용은 시점상 ???? = JungKKuckMa() 가 선언된 이후의 행동을 “미리” 정의하는 코드이며, 이때 self는 ????의 자리를 대신한다.\n- self의 의미: ???? = JungKKuckMa() 에 의해서 의하여 태어날 인스턴스 “태명”\n\n우리는 클래스가 설계되는 시점에서 인스턴스가 태어난 이후에 하게 될 일련의 동작을 정의하고 싶음.\n그런데 클래스가 설계하는 시점에서는 인스턴스의 이름이 정해지지 않았으므로 (아직 태어나지도 않음) 1번의 작업이 불편하다.\n그래서 앞으로는 1번의 작업이 원활하게 진행되도록, 앞으로 태어날 인스턴스의 이름은 모두 self라는 가칭으로 부른다.\n\n- 시점이 꼬일시 발생하는 오류\n\nclass JungKKuckMa:\n    def show(self):\n        _str = self.html_str.format(\n            ttl = self.title,\n            url = self.imgurl,\n            Q = self.ques,\n            A = self.ans,\n            hl = self.highlight\n        )\n        display(HTML(_str))\n\n\npp2023 = JungKKuckMa()\n\n\npp2023.title = '파이썬 프로그래밍 중간고사 패배는 괜찮다.'\n# pp2023.imgurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/PP2023mid.jpg?raw=true?'\n# pp2023.ques = \"Q: 파이썬 프로그래밍 기말고사, 어떤 점에 유의해야 할까?\"\n# pp2023.ans = \"A: 최규빈 교수 문제 스타일에 대해서 더 분석할 건 없는 것 같고, 내가 내 코드를 잘 구현하는 게 제일 중요한 것 같고 중간고사는 망하긴 했지만 제 스스로 안 무너지면 충분히 기말고사는 잘 볼 수 있을 것 같아요.\"\n# pp2023.highlight = '마음'\npp2023.html_str =\\\n'''\n&lt;style&gt;\n    .title {{\n        font-family: \"Times New Roman\", serif;\n        font-size: 30px;\n        font-weight: 900;\n    }}\n    .text {{\n        font-family: \"Arial\", sans-serif;\n        font-size: 20px;\n        font-style: italic;\n    }}\n    .highlight {{\n        font-family: \"Montserrat\", monospace;\n        font-size: 35px;\n        font-weight: 900;\n        text-decoration: underline;\n        font-style: normal;\n        color: darkblue;\n        background-color: #FFFF00;\n    }}\n&lt;/style&gt;\n&lt;p class=\"title\"&gt;{ttl}&lt;/p&gt;\n&lt;img src={url} width=\"600\"&gt;\n&lt;p&gt; \\n &lt;/p&gt;\n&lt;p class=\"text\"&gt;{Q}&lt;/p&gt;\n&lt;p class=\"text\"&gt;{A}&lt;/p&gt;\n&lt;p class=\"title\"&gt;중요한 것은 꺾이지 않는 &lt;span class=\"highlight\"&gt;{hl}&lt;/span&gt;&lt;/p&gt;\n'''\n\n\npp2023.show()\n\nAttributeError: 'JungKKuckMa' object has no attribute 'imgurl'"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-24-12wk-2.html#암기사항",
    "href": "PP2023/posts/03_Class/2023-05-24-12wk-2.html#암기사항",
    "title": "12wk-2: 클래스공부 3단계 – 문제연습",
    "section": "암기사항",
    "text": "암기사항\n외우세요 (논리적으로 생각하지 말고)\n#1 클래스의 선언: 클래스의 선언은 아래와 같이 하며 클래스의 이름은 대문자로 한다.\n# 예시1: 좋은사례\nclass JungKKuckMa:\n    pass \n# 예시2: 나쁜사례 -- 클래스 이름은 대문자로 시작해야해\nclass jungkkuckma:\n    pass \n\n딴지: 1. 사실 저거 말고도 선언하는 방법 있는데.. 2. 대문자가 아니어도 에러는 안나는데..\n\n#2 클래스의 내용: 클래스의 내용은 메소드만을 정의하는데에만 사용한다.\n# 예시1: 클래스의 내용을 메소드로만 작성한예시 \nclass JungKKuckMa:\n    def method1(self): \n        blabla\n    def method2(self): \n        blabla\n    def method3(self): \n        blabla\n    def method4(self): \n        blabla\n    def method5(self): \n        blabla    \n# 예시2: 나쁜사례\nclass JungKKuckMa:\n    a=1 \n    b=1 \n\n딴지: 꼭 메소드만 클래스의 내용으로 쓰라는 법은 없음\n\n#3 메소드의 첫번째 입력은 항상 self 로 사용한다.\n\n딴지: 이것도 꼭 그런건 아님\n\n#4 __init__ 메소드는 “클래스 \\(\\to\\) 인스턴스” 시점에 자동으로 실행되는 특수한 메소드이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-05-24-12wk-2.html#문제풀이",
    "href": "PP2023/posts/03_Class/2023-05-24-12wk-2.html#문제풀이",
    "title": "12wk-2: 클래스공부 3단계 – 문제연습",
    "section": "문제풀이",
    "text": "문제풀이\n각 예제의 조건에 맞는 클래스를 구현하라\n- 예제1 – self는 항상 써야 해\n아래의 조건에 맞는 클래스를 구현하라.\n\n클래스에는 hello()라는 메소드가 정의되어 있으며, hello()의 기능은 “안녕하세요”를 출력하는 것이다.\n\n(풀이)\n\nclass Klass: \n    def hello(self):\n        print(\"안녕하세요\")\n\n\nins = Klass()\n\n\nins.hello()\n\n안녕하세요\n\n\n- 예제2– __init__의 사용방법\n아래의 조건에 맞는 클래스를 구현하라.\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 a가 True 로 초기설정된다.\n클래스에는 show()라는 메소드가 정의되어 있으며, show()의 기능은 a의 값을 print 하는 기능을 한다.\n\n(풀이)\n\nclass Klass: \n    def __init__(self):\n        self.a = True\n    def show(self):\n        print(self.a)\n\n\nins = Klass()\n\n\nins.show()\n\nTrue\n\n\n- 예제3– method의 정의 및 사용\n아래의 조건에 맞는 클래스를 구현하라.\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 a가 True 로 초기설정된다.\n클래스에는 toggle() 이라는 메소드가 정의되어 있다. 이 기능은 변수 a의 값이 True 이면 False 로, False 이면 True 로 바꾸는 역할을 한다.\n클래스에는 show()라는 메소드가 정의되어 있다. 이 기능은 a의 값을 print 하는 기능을 한다.\n\n(풀이)\n\nclass Klass: \n    def __init__(self):\n        self.a = True\n    def toggle(self):\n        self.a = not self.a\n    def show(self):\n        print(self.a)\n\n\nins = Klass()\n\n\nins.a\n\nTrue\n\n\n\nins.toggle()\n\n\nins.show()\n\nFalse\n\n\n\nins.toggle()\nins.toggle()\nins.show()\n\nFalse\n\n\n\nins.toggle()\nins.toggle()\nins.toggle()\nins.show()\n\nTrue\n\n\n- 예제4 – method의 정의 및 사용\n아래의 조건에 맞는 클래스를 구현하라.\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 a가 0으로 초기설정된다.\n클래스에는 up()라는 메소드가 정의되어 있다. up()의 기능은 a의 값을 1증가시키는 기능을 한다.\n클래스에는 show()라는 메소드가 정의되어 있다. show()의 기능은 a의 값을 print 하는 가능을 한다.\n\n(풀이)\n\nclass Klass:\n    def __init__(self):\n        self.a = 0 \n    def up(self):\n        self.a = self.a + 1\n    def show(self):\n        print(self.a) \n\n\nins = Klass() \n\n\nins.show()\n\n0\n\n\n\nins.up()\nins.up()\nins.show()\n\n2\n\n\n- 예제5 – 외부입력을 사용하는 __init__\n아래의 조건에 맞는 클래스를 구현하라.\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 a의 값이 사용자가 입력한 값으로 초기설정된다.\n클래스에는 show()라는 메소드가 정의되어 있다. show()의 기능은 a의 값을 print 하는 가능을 한다.\n\n(풀이)\n\nclass Klass:\n    def __init__(self,value):\n        self.a = value\n    def show(self):\n        print(self.a) \n\n\nins = Klass(397)\n\n\nins.show()\n\n397\n\n\n- 예제6 – 외부입력을 사용하는 method\n아래의 조건에 맞는 클래스를 구현하라.\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 a가 0으로 초기설정된다.\n클래스에는 up()라는 메소드가 정의되어 있다. up()의 기능은 a의 값을 1증가시키는 기능을 한다.\n클래스에는 jump()라는 메소드가 정의되어 있다. jump()는 jump_size 를 입력으로 받으며 a의 값을 jump_size 만큼 증가시키는 기능을 한다.\n클래스에는 show()라는 메소드가 정의되어 있다. show()의 기능은 a의 값을 print 하는 기능을 한다.\n\n(풀이)\n\nclass Klass:\n    def __init__(self):\n        self.a = 0\n    def up(self):\n        self.a = self.a + 1  \n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n    def show(self):\n        print('a={}'.format(self.a))\n\n\nins = Klass()\n\n\nins.show()\n\na=0\n\n\n\nins.up()\nins.show()\n\na=1\n\n\n\nins.up()\nins.jump(100)\nins.show()\n\na=102\n\n\n- 예제7 – 메소드에서 메소드 사용하기\n아래의 조건에 맞는 클래스를 구현하라.\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 a가 0으로 초기설정된다.\n클래스에는 up()라는 메소드가 정의되어 있다. up()의 기능은 a의 값을 1증가시키는 기능을 한다.\n클래스에는 jump()라는 메소드가 정의되어 있다. jump()는 jump_size 를 입력으로 받으며 a의 값을 jump_size 만큼 증가시키는 기능을 한다.\n클래스에는 reset()이라는 메소드가 정의되어 있다. reset()는 a의 값을 0으로 초기화하는 역할을 한다.\n클래스에는 show()라는 메소드가 정의되어 있다. show()의 기능은 a의 값을 print 하는 기능을 한다.\n\n\nclass Klass:\n    def __init__(self):\n        self.a = 0\n    def up(self):\n        self.a = self.a + 1  \n    def jump(self,jump_size):\n        self.a = self.a + jump_size      \n    def show(self):\n        print('a={}'.format(self.a))\n    def reset(self):\n        self.__init__()\n\n\nins = Klass()\n\n\nins.show()\n\na=0\n\n\n\nins.up()\nins.jump(3)\nins.up()\nins.up()\nins.jump(5)\n\n\nins.show()\n\na=11\n\n\n\nins.reset()\nins.show()\n\na=0\n\n\n- 예제8: – 이미지출력\n아래의 코드를 관찰\n\nurl = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/burgerking.png?raw=true'\nhtml_str = '&lt;img src={url} width=\"600\"&gt;'.format(url=url)\ndisplay(HTML(html_str))\n\n\n\n\n아래의 조건에 맞는 클래스를 구현하라.\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 url이 위에서 제시된 값으로 초기화된다.\n클래스에는 show()라는 함수가 있어서 url에 해당하는 이미지를 출력해주는 기능을 가진다.\n\n(풀이)\n\nclass Klass:\n    def __init__(self):\n        self.url = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/burgerking.png?raw=true'\n    def show(self):\n        html_str = '&lt;img src={url} width=\"600\"&gt;'.format(url=self.url)\n        display(HTML(html_str))\n\n\nins = Klass()\n\n\nins.show()\n\n\n\n\n- 예제9– 이미지 출력 + 횟수 기록\n\n“클래스 \\(\\to\\) 인스턴스”의 과정에서 변수 url이 위에서 제시된 값으로 초기화된다.\n클래스에는 show()라는 함수가 있어서 (1) url에 해당하는 이미지를 출력하고 (2) “당신은 이 그림을 \\(n\\)번 보았습니다” 를 출력하는 기능을 한다. 여기에서 \\(n\\)은 그림을 본 횟수\n\n\nclass Klass:\n    def __init__(self):\n        self.n = 0\n        self.url = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/burgerking.png?raw=true'\n    def show(self):\n        self.n = self.n + 1 \n        html_str = '&lt;img src={url} width=\"600\"&gt;'.format(url=self.url)\n        display(HTML(html_str))\n        print(\"당신은 이 그림을 {}번 보았습니다.\".format(self.n))\n\n\nins = Klass()\n\n\nins.show()\n\n\n\n\n당신은 이 그림을 1번 보았습니다.\n\n\n- 예제10 – 여러 인스턴스 동시관리\n예제9에서 만든 클래스를 이용하여 아래의 url에 해당하는 이미지를 출력하라.\n\nhttps://github.com/guebin/PP2023/blob/main/posts/03_Class/JungGGuckMa.jpg?raw=true\n\n.show()를 이용해 두 이미지를 번갈아 가며 관찰하고 횟수가 올바르게 카운트되는지 확인하라.\n\nins1 = Klass()\nins2 = Klass()\n\n\nins2.url = 'https://github.com/guebin/PP2023/blob/main/posts/03_Class/JungGGuckMa.jpg?raw=true'\n\n\nins1.show()\n\n\n\n\n당신은 이 그림을 1번 보았습니다.\n\n\n\nins2.show()\n\n\n\n\n당신은 이 그림을 1번 보았습니다.\n\n\n\nins2.show()\n\n\n\n\n당신은 이 그림을 3번 보았습니다.\n\n\n\nins1.show()\n\n\n\n\n당신은 이 그림을 2번 보았습니다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#모티브-클래스를-수정은-불편해",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#모티브-클래스를-수정은-불편해",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "모티브: 클래스를 수정은 불편해",
    "text": "모티브: 클래스를 수정은 불편해\n- 예시1: UpJump ver1\n\nclass UpJump:\n    def __init__(self):\n        self.value = 0\n    def up(self):\n        self.value = self.value + 1  \n    def __repr__(self):\n        return str(self.value)\n\n\na = UpJump()\na.up()\n\n\na\n\n1\n\n\n\na.jump(2)\n\nAttributeError: 'UpJump' object has no attribute 'jump'\n\n\n\n점프는 아직 구현하지 않음.\n\n- 예시2: UpJump ver2\n\nclass UpJump_Ver2:\n    def __init__(self):\n        self.value = 0\n    def up(self):\n        self.value = self.value + 1  \n    def jump(self,jump_size):\n        self.value = self.value + jump_size\n    def __repr__(self):\n        return str(self.value)        \n\n\na = UpJump_Ver2()\n\n\na.up()\n\n\na.jump(2)\n\n\na\n\n3\n\n\n- 예시3: UpJump ver2의 다른 구현\n\nclass UpJump_Ver2(UpJump):\n    def jump(self,jump_size):\n        self.value = self.value + jump_size    \n\n\na = UpJump_Ver2()\n\n\na.up()\n\n\na.jump(2)\n\n\na\n\n3"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#꿀팁",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#꿀팁",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "꿀팁",
    "text": "꿀팁\n- 클래스를 조금 수정하고 싶을때, 아래와 같은 문법을 이용하면 편리하다.\nclass 새로운_클래스_이름(수정할_클래스_이름): \n    def 수정_및_추가할_함수이름(self,...):\n        ...\n- 사용예시\n\nclass UpJump_Ver3(UpJump_Ver2):\n    def __repr__(self):\n        return '현재의 이 인스턴스의 value는 {}입니다.'.format(self.value)\n\n\na=UpJump_Ver3()\n\n\na\n\n현재의 이 인스턴스의 value는 0입니다.\n\n\n\na.jump(50)\n\n\na\n\n현재의 이 인스턴스의 value는 50입니다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀6-__add__",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀6-__add__",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "비밀6: __add__",
    "text": "비밀6: __add__\n\nmotive\n- 모티브: 아래의 연산구조를 관찰하자.\n\na=1\nb=2 \na+b\n\n3\n\n\n\na라는 인스턴스와 b라는 인스턴스를 +라는 기호가 연결하고 있다.\n\n- 이번에는 아래의 연산구조를 관찰하자.\n\na=[1,2]\nb=[3,4]\na+b\n\n[1, 2, 3, 4]\n\n\n\na라는 인스턴스와 b라는 인스턴스를 +라는 기호가 연결하고 있다.\n\n- 동작이 다른 이유?\n\n클래스를 배우기 이전: int자료형의 +는 “정수의 덧셈”을 의미하고 list자료형의 +는 “자료의 추가”를 의미한다.\n클래스를 배운 이후: 아마 클래스는 +라는 연산을 정의하는 숨겨진 메소드가 있을것이다. (print가 그랬듯이) 그리고 int클래스에서는 그 메소드를 “정수의 덧셈”이 되도록 정의하였고 list클래스에서는 그 메소드를 “자료의 추가”를 의미하도록 정의하였다.\n\n- 아래의 결과를 관찰\n\na=1\nb=2\n\n\na.__add__(b)\n\n3\n\n\n\nb.__add__(a)\n\n3\n\n\n\na=[1,2]\nb=[3,4]\n\n\na.__add__(b) # a+b \n\n[1, 2, 3, 4]\n\n\n\nb.__add__(a) # b+a \n\n[3, 4, 1, 2]\n\n\n- 확인: a+b는 사실 내부적으로 a.__add__(b)의 축약구문이다.\n- 추측: 따라서 만약 a.__add__(b)의 기능을 바꾸면 (재정의하면) a+b의 기능도 바뀔 것이다.\n\n\nStudent_Ver2: __add__의 사용\n- Student 클래스 선언\n\nclass Student:\n    def __init__(self, age=20.0, semester=0): \n        self.age = age\n        self.semester = semester\n        print(\"입학을 축하합니다. 당신의 나이는 {}이고 현재 학기는 {}학기 입니다.\".format(self.age,self.semester))\n    def __add__(self,registration_status): \n        if registration_status=='휴학': \n            self.age=self.age+0.5\n        elif registration_status=='등록':\n            self.age=self.age+0.5 \n            self.semester= self.semester+1 \n    def _repr_html_(self):\n        html_str = \"\"\"\n        나이: {} &lt;br/&gt;\n        학기: {} &lt;br/&gt;\n        \"\"\"\n        return html_str.format(self.age,self.semester)\n\n- 사용\n\nboram = Student()\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram\n\n\n        나이: 20.0 \n        학기: 0 \n        \n\n\n\nboram + '등록'\nboram\n\n\n        나이: 20.5 \n        학기: 1 \n        \n\n\n\nboram + '휴학'\nboram\n\n\n        나이: 21.0 \n        학기: 1 \n        \n\n\n- 잘못된 사용\n\nboram = Student()\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록'+ '휴학' + '등록' + '휴학'\n\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'str'\n\n\n\n에러가?\n\n- 올바른 코드\n\nclass Student_Ver2:\n    def __init__(self, age=20.0, semester=0): \n        self.age = age\n        self.semester = semester\n        print(\"입학을 축하합니다. 당신의 나이는 {}이고 현재 학기는 {}학기 입니다.\".format(self.age,self.semester))\n    def __add__(self,registration_status): \n        if registration_status=='휴학': \n            self.age = self.age+0.5\n        elif registration_status=='등록':\n            self.age = self.age+0.5 \n            self.semester = self.semester+1 \n        return self \n    def _repr_html_(self):\n        html_str = \"\"\"\n        나이: {} &lt;br/&gt;\n        학기: {} &lt;br/&gt;\n        \"\"\"\n        return html_str.format(self.age,self.semester)\n\n\nboram = Student_Ver2()\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram + \"등록\"\n\n\n        나이: 23.5 \n        학기: 5 \n        \n\n\n\n\nStudent_Ver2의 다른구현1\n\nclass Student_Ver2(Student):\n    def __add__(self,registration_status): \n        if registration_status=='휴학': \n            self.age = self.age+0.5\n        elif registration_status=='등록':\n            self.age = self.age+0.5 \n            self.semester = self.semester+1 \n        return self\n\n\nboram = Student_Ver2()\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록'+ '휴학' + '등록' + '휴학'\n\n\n        나이: 22.0 \n        학기: 2 \n        \n\n\n\n\nStudent_Ver2의 다른구현2\n\n요거까지는 지금 몰라도 됩니다\n\n\nclass Student_Ver2(Student):\n    def __add__(self,registration_status): \n        super().__add__(registration_status)\n        return self\n\n\nboram = Student_Ver2()\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록' + '휴학' + '등록' + '휴학'\n\n\n        나이: 22.0 \n        학기: 2 \n        \n\n\n\n파이썬의 비밀6: a+b는 사실 a.__add__(b)의 축약형이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀7-__getitem__",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀7-__getitem__",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "비밀7: __getitem__",
    "text": "비밀7: __getitem__\n\nmotive\n\na=[11,22,32]\n\n\na[0]\n\n11\n\n\n\n이거 좋아보인다?\n\n\na.__getitem__(0) # a[0]\n\n11\n\n\n\n이런거였어?\n\n\n\nRPS_Ver2: __getitem__의 사용\n\nclass RPS:\n    def __init__(self,candidate):\n        self.candidate = candidate\n        self.actions = list() \n    def pick(self):\n        self.actions.append(np.random.choice(self.candidate))        \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} &lt;br/&gt;\n        기록: {}\n        \"\"\"        \n        return html_str.format(self.candidate,self.actions)\n\n\na = RPS(['가위','바위','보'])\n\n\na.pick()\na.pick()\n\n\na.actions\n\n['바위', '바위']\n\n\n\na[0], a[1]\n\nTypeError: 'RPS' object is not subscriptable\n\n\n\n결과가 ‘가위’, ’바위’로 나오면 좋겠다.. 물론 지금은 불가능해\n\n\nclass RPS_Ver2(RPS):\n    def __getitem__(self,item):\n        return self.actions[item]\n\n\na = RPS_Ver2(['가위','바위','보'])\n\n\na.pick()\na.pick()\na.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['가위', '가위', '바위']\n        \n\n\n\na[0]\n\n'가위'\n\n\n\na[:2]\n\n['가위', '가위']\n\n\n\n파이썬의 비밀7: a[0]는 a.__getitem__(0)의 축약형이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀8-__setitem__",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀8-__setitem__",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "비밀8: __setitem__",
    "text": "비밀8: __setitem__\n\nmotive\n\na = RPS_Ver2(['가위','바위'])\na\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: []\n        \n\n\n\na.pick()\na.pick()\na\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: ['가위', '바위']\n        \n\n\n\na[0]\n\n'가위'\n\n\n\na[0] = '보' \n\nTypeError: 'RPS_Ver2' object does not support item assignment\n\n\n\n경우에 따라서는 이런 문법이 필요하기도 하다.\n\n\n\nRPS_Ver3: __setitem__ 사용\n- 관찰\n\nlst = [1,2,3]\n\n\nlst.__setitem__(0,11)\n\n\nlst\n\n[11, 2, 3]\n\n\n- RPS예제\n\nclass RPS_Ver3(RPS_Ver2):\n    def __setitem__(self,index,val):\n        self.actions[index] = val\n\n\na=RPS_Ver3(['가위','바위','보'])\n\n\na.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['보']\n        \n\n\n\na[0]='가위'\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['가위']\n        \n\n\n\n파이썬의 비밀8: a[0]=11는 a.__setitem__(0,11)의 축약형이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀9-__len__",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀9-__len__",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "비밀9: __len__",
    "text": "비밀9: __len__\n\nmotive\n\na= RPS_Ver3(['가위','바위','보'])\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: []\n        \n\n\n\na.pick()\na.pick()\na.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['보', '가위', '바위']\n        \n\n\n\na[0],a[1],a[2]\n\n('보', '가위', '바위')\n\n\n\nlen(a)\n\nTypeError: object of type 'RPS_Ver3' has no len()\n\n\n\n\nRPS_Ver4: __len__ 의 사용\n\nclass RPS_Ver4(RPS_Ver2):\n    def __len__(self):\n        return len(self.actions)\n\n\na = RPS_Ver4(['가위','바위','보'])\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: []\n        \n\n\n\na.pick()\na.pick()\na.pick()\na.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['가위', '가위', '보', '바위']\n        \n\n\n\na.__len__() # len(a.actions)\n\n4\n\n\n\nlen(a) # a.__len__()\n\n4\n\n\n\n파이썬의 비밀9: a.__len__()는 len(a)의 축약형이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀10-비교연산자",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀10-비교연산자",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "비밀10: 비교연산자",
    "text": "비밀10: 비교연산자\n\nmotive1\n\na = RPS_Ver4(['가위'])\nb = RPS_Ver4(['가위'])\n\n\na.pick()\nb.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위'] \n        기록: ['가위']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위'] \n        기록: ['가위']\n        \n\n\n\na == b\n\nFalse\n\n\n\n가위 == 가위 이면 True가 나오면 좋겠구만..\n\n\na[-1] == b[-1] \n\nTrue\n\n\n\n이렇게 하면 되긴하지..\n\n\n\nRPS_Ver5: __eq__ 의 사용\n- 관찰\n\na = 1\n\n\na.__eq__(1) # a == 1\n\nTrue\n\n\n\na.__eq__(2) # a == 2 \n\nFalse\n\n\n- 구현\n\nclass RPS_Ver5(RPS_Ver4):\n    def __eq__(self,other):\n        return self[-1] == other[-1]\n\n\na = RPS_Ver5(['가위','바위'])\nb = RPS_Ver5(['가위','바위'])\n\n- 1회 대결\n\na.pick()\nb.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: ['바위']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: ['바위']\n        \n\n\n\na == b\n\nTrue\n\n\n- 2회 대결\n\na.pick()\nb.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: ['바위', '가위']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: ['바위', '가위']\n        \n\n\n\na == b\n\nTrue\n\n\n- 3회 대결\n\na.pick()\nb.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: ['바위', '가위', '가위']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '바위'] \n        기록: ['바위', '가위', '바위']\n        \n\n\n\na == b\n\nFalse\n\n\n\n\nmotive2\n\na[-1], b[-1]\n\n('바위', '바위')\n\n\n\na &gt; b\n\nTypeError: '&gt;' not supported between instances of 'RPS_Ver5' and 'RPS_Ver5'\n\n\n\nFalse 가 나오면 좋겟구만..\n\n\n\nRPS_Ver6: __gt__ 의 사용\n- 관찰\n\na = 1\n\n\na.__gt__(1) # a&gt;1\n\nFalse\n\n\n\na.__gt__(0) # a&gt;0 \n\nTrue\n\n\n- 예비학습\n\n[a[-1],b[-1]]\n\n['가위', '바위']\n\n\n\n[a[-1],b[-1]] in [['가위','보'],['바위','가위'],['보','바위']]\n\nFalse\n\n\n- 구현\n\nclass RPS_Ver6(RPS_Ver5):\n    def __gt__(self,other):\n        return [self[-1],other[-1]] in [['가위','보'],['바위','가위'],['보','바위']]\n\n\na = RPS_Ver6(['가위','바위','보'])\nb = RPS_Ver6(['가위','바위','보'])\n\n- 1회대결\n\na.pick() \nb.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['바위']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['바위']\n        \n\n\n\na&gt;b, a==b\n\n(False, True)\n\n\n- 2회대결\n\na.pick() \nb.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['바위', '보']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['바위', '바위']\n        \n\n\n\na&gt;b, a==b\n\n(True, False)\n\n\n\n\nmotive3\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['바위', '보']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['바위', '바위']\n        \n\n\n\na&gt;=b\n\nTypeError: '&gt;=' not supported between instances of 'RPS_Ver6' and 'RPS_Ver6'\n\n\n\nTrue로 나오면 좋겠구만..\n\n\na &lt; b\n\nFalse\n\n\n\n이것도 정의 새로 해야겠는걸?\n\n\n\nRPS_Ver7: __ge__, __lt__, __le__ 의 사용\n- 관찰: 생략\n- 비교연산자 정리\n\n\n\n특수메소드\n의미\n\n\n\n\n__eq__\nself == other\n\n\n__gt__\nself &gt; other\n\n\n__lt__\nself &lt; other\n\n\n__ge__\nself &gt;= other\n\n\n__le__\nself &lt;= other\n\n\n\n- 구현\n\nclass RPS_Ver7(RPS_Ver6):\n    def __ge__(self,other):\n        return (self == other) or (self &gt; other)\n    def __lt__(self,other):\n        return not (self &gt;= other)\n    def __le__(self,other):\n        return (self == other) or (self &lt; other)\n\n\na = RPS_Ver7(['가위','바위','보'])\nb = RPS_Ver7(['가위','바위','보'])\n\n\na.pick()\nb.pick()\n\n\na\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['보']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['가위', '바위', '보'] \n        기록: ['가위']\n        \n\n\n\na==b, a&gt;b, a&lt;b, a&gt;=b, a&lt;=b \n\n(False, False, True, False, True)\n\n\n\n파이썬의 비밀10: __eq__, __gt__, __lt__, __ge__, __le__는 각각 ==, &gt;, &lt;, &gt;=, &lt;= 를 재정의한다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀11-__call__-starstarstar",
    "href": "PP2023/posts/03_Class/2023-06-05-14wk-1.html#비밀11-__call__-starstarstar",
    "title": "14wk-1: 클래스공부 4단계 – 파이썬의 비밀 (2)",
    "section": "비밀11: __call__ \\((\\star\\star\\star)\\)",
    "text": "비밀11: __call__ \\((\\star\\star\\star)\\)\n\n함수공부\n- 다시 함수를 공부해봅시다.\n\ndef f(x):\n    return x+1 \n\n\nf(3)\n\n4\n\n\n- 함수의 사용방법?\n\n입력으로 변수 x를 받음 = 입력으로 인스턴스 x를 받음.\n출력으로 변수 x+1을 리턴 = 출력으로 인스턴스 x+1을 리턴.\n\n- 사실1: 파이썬에서 함수는 인스턴스를 입력으로 받고 인스턴스를 출력한다.\n- 함수의 자료형?\n\n?f\n\n\nSignature: f(x)\nDocstring: &lt;no docstring&gt;\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-264-76b767537386&gt;\nType:      function\n\n\n\n\ntype이 function이다.\nf는 function class의 instance이다.\n결국 f 역시 하나의 오브젝트에 불과하다.\n\n- 사실2: 함수도 결국 인스턴스이다. -&gt; 함수의 입력으로 함수를 쓸 수도 있고 함수의 출력으로 함수가 나올 수도 있다.\n\n“파이썬의 모든 것은 오브젝트이다.” &lt;– 명언처럼 외우세여\n\n\n\n함수도 인스턴스다\n(예제1) 숫자입력, 함수출력\n\ndef f(a):\n    def _f(x):\n        return (x-a)**2 \n    return _f\n\n\ng=f(10) # g(x)=(x-10)**2 \n\n\ng(2) # (2-10)**2 = 64\n\n64\n\n\n\n해석: \\(f(a)\\)는 \\(a\\)를 입력으로 받고 \\(g(x)=(x-a)^2\\)라는 함수를 리턴해주는 함수\n\n(예제1)의 다른표현: 익명함수 lambda\n\ndef f(x):\n    return x+1\n\n\nf= lambda x: x+1\n\n표현1\n\ndef f(a):\n    _f = lambda x: (x-a)**2 ### lambda x: (x-a)**2 가 실행되는 순간 함수오브젝트가 만들어지고 그것이 _f 로 저장됨 \n    return _f\n\n\ng=f(10) # g(x)=(x-10)**2 \n\n\ng(3) # (3-10)**2 = 49\n\n49\n\n\n표현2\n\ndef f(a):\n    return lambda x: (x-a)**2 \n\n\ng=f(10) # g(x)=(x-10)**2 \n\n\ng(3) # (3-10)**2 = 49\n\n49\n\n\n\nlambda x: (x-a)**2 는 \\(\\text{lambda}(x) = (x-a)^2\\)의 느낌으로 기억하면 외우기 쉽다.\nlambda x: (x-a)**2 는 “아직 이름이 없는 함수오브젝트를 (가칭 lambda 라고 하자) 만들고 기능은 x를 입력으로 하고 (x-a)**2를 출력하도록 하자” 라는 뜻으로 해석하면 된다.\n\n(예제2) 함수입력, 숫자출력\n\ndef d(f,x): # 함수를 입력을 받는 함수를 정의 \n    h=0.000000000001\n    return (f(x+h)-f(x))/h \n\n\nd(f,4) # f'(4) = 2*4 = 8\n\n8.000711204658728\n\n\n(예제3) 함수입력, 함수출력\n\ndef f(x): \n    return x**2 \n\n\ndef derivate(f): \n    # step1: 함수오브젝트 f는 입력으로 받은상태 \n    # step2: 함수오브젝트 f를 이용하여 df라는 함수를 정의 \n    def df(x): \n        h=0.000000000001\n        return (f(x+h)-f(x))/h \n    # step3: 정의된 df를 리턴\n    return df\n\n\nff = derivate(f)\n\n\nff(7) # f의 도함수\n\n14.004797321831575\n\n\n원래함수 시각화\n\nx = np.linspace(-1,1,100)\nplt.plot(x,f(x))\n\n\n\n\n도함수 시각화\n\nx = np.linspace(-1,1,100)\nplt.plot(x,f(x),label=r'$f(x)=x^2$')\nplt.plot(x,ff(x),label=r'$ff(x)=2x$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f4c15ef3d00&gt;\n\n\n\n\n\n(예제3)의 다른표현\n\ndef f(x): \n    return x**2 \n\n\ndef derivate(f): \n    h=0.000000000001\n    return lambda x: (f(x+h)-f(x))/h \n\n\nff = derivate(f)\n\n\nff(10)\n\n20.00888343900442\n\n\n\nx = np.linspace(-1,1,100)\nplt.plot(x,f(x),label=r'$f(x)=x^2$')\nplt.plot(x,ff(x),label=r'$ff(x)=2x$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f4c1686aa90&gt;\n\n\n\n\n\n(예제4) 함수들의 리스트\n\nflst = [lambda x: x, lambda x: x**2, lambda x: x**3] \nflst\n\n[&lt;function __main__.&lt;lambda&gt;(x)&gt;,\n &lt;function __main__.&lt;lambda&gt;(x)&gt;,\n &lt;function __main__.&lt;lambda&gt;(x)&gt;]\n\n\n\nfor f in flst:\n    print(f(2))\n\n2\n4\n8\n\n\n\nfor f in flst: \n    plt.plot(x,f(x),'--')\n\n\n\n\n위의코드는 아래와 같음\n\nplt.plot(x,(lambda x: x)(x),'--')\nplt.plot(x,(lambda x: x**2)(x),'--')\nplt.plot(x,(lambda x: x**3)(x),'--')\n\n\n\n\n\n\n정리\n- 지금까지 개념\n\n함수: 변수를 입력으로 받아서 변수를 출력하는 개념\n변수: 어떠한 값을 저장하는 용도로 쓰거나 함수의 입력 혹은 출력으로 사용함\n\n- R과 구별되는 파이썬의 독특한 테크닉 (부제: 파이썬에서 함수를 잘 쓰려면?)\n\n변수든 함수이든 둘다 인스턴스임. (즉 어떠한 클래스에서 찍힌 똑같은 오브젝트라는 의미)\n변수를 함수처럼: 메소드 lst.append(1)은 마치 append(lst,1)와 같은 함수로 쓸 수 있음\n함수를 변수처럼(\\(\\star\\)): 함수자체를 함수의 입력으로 혹은 출력으로 쓸 수도 있음. 함수를 특정 값처럼 생각해서 함수들의 list를 만들 수도 있다.\n\n\n\ncallable object\n- 함수 오브젝트의 비밀?\n\nf = lambda x: x+1 \n\n\na=11\n\n\nset(dir(f)) & {'__call__'}\n\n{'__call__'}\n\n\n\n함수 오브젝트에는 숨겨진 기능 __call__이 있다.\n\n\nf.__call__(3) # f(3)\n\n4\n\n\n\nf.__call__(4) # f(4)\n\n5\n\n\n\n여기에 우리가 정의한 내용이 있다.\n\n- 함수처럼 쓸 수 없는 인스턴스는 단지 call이 없는 것일 뿐이다.\n\nclass Klass: \n    def __init__(self):\n        self.name='guebin'\n\n\na=Klass()\n\n\na()\n\nTypeError: 'Klass' object is not callable\n\n\n\na는 callable이 아니라고 한다.\n\n\nclass Klass2(Klass): \n    def __call__(self):\n        print(self.name)\n\n\nb=Klass2()\n\n\nb()\n\nguebin\n\n\n\nb는 callable object! 즉 숨겨진 메서드로 __call__를 가진 오브젝트!\nKlass는 callable object를 만들지 못하지만 Klass2는 callable object를 만든다.\n\n- 클래스로 함수를 만들기 (=함수인스턴스를 찍어내는 클래스 설계)\n\nclass AddConstant: \n    def __init__(self,const):\n        self.const = const \n    def __call__(self,x):\n        return x + self.const\n\n\nf = AddConstant(3) # callable object생성, f.const에는 3이 저장되어있음. \n\n\nf(5) # f.const 와 5를 더하는 기능을 수행, # 즉 f(x) = x+3 을 수행함\n\n8\n\n\n\nf(10) \n\n13\n\n\n- 클래스도 그러고 보니까 오브젝트 아니었나?\n\nStudent_Ver2?\n\n\nInit signature: Student_Ver2(age=20.0, semester=0)\nDocstring:      &lt;no docstring&gt;\nType:           type\nSubclasses:     \n\n\n\n\n이것도 type 이라는 또 다른 클래스에서 (클래스를 찍는 클래스) 찍힌 오브젝트이구나..\n\n- 클래스 “오브젝트”도 함수 “오브젝트”처럼 Student_Ver2()와 같이 사용하면 인스턴스를 만들었음. -&gt; Student_Ver2.__call__() 은 Student_Ver2()와 같은 역할을 할 것이다.\n일반적인 구현에서 “클래스 \\(\\to\\) 인스턴스” 과정\n\nboram = Student_Ver2(age=20.0,semester=0)\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록' + '휴학' + '휴학'\n\n\n        나이: 21.5 \n        학기: 1 \n        \n\n\n공부를 위해 call을 이용해본 “클래스 \\(\\to\\) 인스턴스” 과정\n\nboram = Student_Ver2.__call__(age=20.0,semester=0) #\n# boram = Student_Ver2(age=20.0,semester=0)\n\n입학을 축하합니다. 당신의 나이는 20.0이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록' + '휴학' + '휴학'\n\n\n        나이: 21.5 \n        학기: 1 \n        \n\n\n\n파이썬의 비밀11: f()와 같이 쓸 수 있는 오브젝트는 단지 __call__ 이 정의되어있는 오브젝트일 뿐이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#상속의-사용방법",
    "href": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#상속의-사용방법",
    "title": "15wk-1: 클래스공부 5단계 – 상속",
    "section": "상속의 사용방법",
    "text": "상속의 사용방법\n- 클래스를 조금 수정하고 싶을때, 아래와 같은 문법을 이용하면 편리하다.\nclass 새로운_클래스_이름(수정할_클래스_이름): \n    def 수정_및_추가할_함수이름(self,...):\n        ..."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#간단한-사용예시",
    "href": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#간단한-사용예시",
    "title": "15wk-1: 클래스공부 5단계 – 상속",
    "section": "간단한 사용예시",
    "text": "간단한 사용예시\n\nclass Init:\n    def __init__(self,value):\n        ## 여기는 Init 클래스야 \n        print(\"Init클래스에서 정의된 __init__메소드를 실행합니다\")        \n        self.value = value\n\n\nclass Show(Init):\n    def show(self):\n        ## 여기는 Show 클래스야\n        print(\"Show클래스에서 정의된 show메소드를 실행합니다\")\n        print('value={}'.format(self.value))\n\n\na = Show(5)\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n\na.show()\n\nShow클래스에서 정의된 show메소드를 실행합니다\nvalue=5\n\n\n\na.show??\n\n\nSignature: a.show()\nDocstring: &lt;no docstring&gt;\nSource:   \n    def show(self):\n        ## 여기는 Show 클래스야\n        print(\"Show클래스에서 정의된 show메소드를 실행합니다\")\n        print('value={}'.format(self.value))\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-342-5ac798f79ec3&gt;\nType:      method\n\n\n\n\na.__init__??\n\n\nSignature: a.__init__(value)\nDocstring: Initialize self.  See help(type(self)) for accurate signature.\nSource:   \n    def __init__(self,value):\n        ## 여기는 Init 클래스야 \n        print(\"Init클래스에서 정의된 __init__메소드를 실행합니다\")        \n        self.value = value\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-341-3a7b8109daf8&gt;\nType:      method"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#슈퍼클래스-메소드-재활용",
    "href": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#슈퍼클래스-메소드-재활용",
    "title": "15wk-1: 클래스공부 5단계 – 상속",
    "section": "슈퍼클래스 메소드 재활용",
    "text": "슈퍼클래스 메소드 재활용\n- 방법1: 직접 슈퍼클래스 명시\n\nclass Deco(Show):\n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        Show.__init__(self,value)\n        print(\"짠짠~!!\")\n\n\na=Deco(5)\n\n짜라란~~\nInit클래스에서 정의된 __init__메소드를 실행합니다\n짠짠~!!\n\n\n\na.show??\n\n\nSignature: a.show()\nDocstring: &lt;no docstring&gt;\nSource:   \n    def show(self):\n        ## 여기는 Show 클래스야\n        print(\"Show클래스에서 정의된 show메소드를 실행합니다\")\n        print('value={}'.format(self.value))\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-342-5ac798f79ec3&gt;\nType:      method\n\n\n\n\na.__init__??\n\n\nSignature: a.__init__(value)\nDocstring: Initialize self.  See help(type(self)) for accurate signature.\nSource:   \n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        Show.__init__(self,value)\n        print(\"짠짠~!!\")\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-348-8837bbd4ea3b&gt;\nType:      method\n\n\n\n- 방법2: super() 이용 (생략안한버전)\n\nclass Deco(Show):\n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        super(Deco,self).__init__(value)\n        print(\"짠짠~!!\")\n\n\na=Deco(5)\n\n짜라란~~\nInit클래스에서 정의된 __init__메소드를 실행합니다\n짠짠~!!\n\n\n\na.show??\n\n\nSignature: a.show()\nDocstring: &lt;no docstring&gt;\nSource:   \n    def show(self):\n        ## 여기는 Show 클래스야\n        print(\"Show클래스에서 정의된 show메소드를 실행합니다\")\n        print('value={}'.format(self.value))\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-342-5ac798f79ec3&gt;\nType:      method\n\n\n\n\na.__init__??\n\n\nSignature: a.__init__(value)\nDocstring: Initialize self.  See help(type(self)) for accurate signature.\nSource:   \n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        super(Deco,self).__init__(value)\n        print(\"짠짠~!!\")\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-361-5ba5667ac964&gt;\nType:      method\n\n\n\n- 방법3: super() 이용 (생략한버젼) &lt;– 이렇게 쓰세요!\n\nclass Deco(Show):\n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        super().__init__(value)\n        print(\"짠짠~!!\")\n\n\na=Deco(5)\n\n짜라란~~\nInit클래스에서 정의된 __init__메소드를 실행합니다\n짠짠~!!\n\n\n\na.show??\n\n\nSignature: a.show()\nDocstring: &lt;no docstring&gt;\nSource:   \n    def show(self):\n        ## 여기는 Show 클래스야\n        print(\"Show클래스에서 정의된 show메소드를 실행합니다\")\n        print('value={}'.format(self.value))\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-342-5ac798f79ec3&gt;\nType:      method\n\n\n\n\na.__init__??\n\n\nSignature: a.__init__(value)\nDocstring: Initialize self.  See help(type(self)) for accurate signature.\nSource:   \n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        super().__init__(value)\n        print(\"짠짠~!!\")\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-365-9c3108795053&gt;\nType:      method\n\n\n\n- 방법4: super() 이용, 방법3을 이해하기 위한 코드\n\nclass Deco(Show):\n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        super(__class__,self).__init__(value)\n        print(\"짠짠~!!\")\n\n\na=Deco(5)\n\n짜라란~~\nInit클래스에서 정의된 __init__메소드를 실행합니다\n짠짠~!!\n\n\n\na.show??\n\n\nSignature: a.show()\nDocstring: &lt;no docstring&gt;\nSource:   \n    def show(self):\n        ## 여기는 Show 클래스야\n        print(\"Show클래스에서 정의된 show메소드를 실행합니다\")\n        print('value={}'.format(self.value))\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-342-5ac798f79ec3&gt;\nType:      method\n\n\n\n\na.__init__??\n\n\nSignature: a.__init__(value)\nDocstring: Initialize self.  See help(type(self)) for accurate signature.\nSource:   \n    def __init__(self,value):\n        ## 여기는 Deco클래스야~\n        print(\"짜라란~~\")\n        super(__class__,self).__init__(value)\n        print(\"짠짠~!!\")\nFile:      ~/Dropbox/07_lectures/PP2023/posts/03_Class/&lt;ipython-input-375-4e2b30e113c0&gt;\nType:      method\n\n\n\n- 이때 방법2-4는 완전히 동일한 코드이다, 방법1-4는 이 예제에서 같은효과이다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#다중상속",
    "href": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#다중상속",
    "title": "15wk-1: 클래스공부 5단계 – 상속",
    "section": "다중상속",
    "text": "다중상속\n\n일반적인 다중상속\n- Add 클래스선언\n\nclass Add:\n    def __init__(self,value):\n        self.value = value \n    def __add__(self,value2):\n        return self.value + value2\n\n\na=Add(2)\n\n\na+5\n\n7\n\n\n\na*2 # 곱하기는 정의한적없음\n\nTypeError: unsupported operand type(s) for *: 'Add' and 'int'\n\n\n- Mul 클래스선언\n\nclass Mul:\n    def __init__(self,value):\n        self.value = value \n    def __mul__(self,value2):\n        return self.value * value2\n\n\na = Mul(5)\na.value\n\n5\n\n\n\na+2 #정의한적 없음\n\nTypeError: unsupported operand type(s) for +: 'Mul' and 'int'\n\n\n\na*2 \n\n10\n\n\n- AddMul 클래스를 선언 (기존의 Add, Mul 상속받아서 이용)\n\nclass AddMul(Add,Mul):\n    pass \n\n\na = AddMul(5)\na.value\n\n5\n\n\n\na+2\n\n7\n\n\n\na*5\n\n25\n\n\n\n\n다중상속 우선순위 (__init__이 겹치는뎅?)\n\nclass Add:\n    def __init__(self,value):\n        print(\"Add클래스에서 정의된 __init__ 메소드가 실행됩니다\")\n        self.value = value \n    def __add__(self,value2):\n        return self.value + value2\n              \nclass Mul:\n    def __init__(self,value):\n        print(\"Mul클래스에서 정의된 __init__ 메소드가 실행됩니다\")        \n        self.value = value \n    def __mul__(self,value2):\n        return self.value * value2        \n    \nclass AddMul(Add,Mul):\n    pass     \n\n\na = AddMul(5)\n\nAdd클래스에서 정의된 __init__ 메소드가 실행됩니다\n\n\n\n\n믹스인 클래스 (\\(\\star\\star\\star\\))\n\nclass Init:\n    def __init__(self,value):\n        ## 여기는 Init 클래스야 \n        print(\"Init클래스에서 정의된 __init__메소드를 실행합니다\")        \n        self.value = value\n\nclass Add(Init):\n    def __add__(self,value2):\n        return self.value + value2\n              \nclass Mul(Init):\n    def __mul__(self,value2):\n        return self.value * value2        \n    \nclass AddMul(Add,Mul):\n    pass     \n\n\na = AddMul(5)\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n\na+2\n\n7\n\n\n\na*5\n\n25"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#다중상속시-super의-활용",
    "href": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#다중상속시-super의-활용",
    "title": "15wk-1: 클래스공부 5단계 – 상속",
    "section": "다중상속시 super()의 활용",
    "text": "다중상속시 super()의 활용\n\nsuper()를 쓰지 않은 나쁜사용예시\n- 초기값을 설정하는 클래스 만듬\n\nclass Init:\n    def __init__(self,value):\n        ## 여기는 Init 클래스야 \n        print(\"Init클래스에서 정의된 __init__메소드를 실행합니다\")        \n        self.value = value\n\n- init을 상속받아서\n\n“\\({\\tt 초기값}= {\\tt 초기값} \\times 2\\)”\n“\\({\\tt 초기값}= {\\tt 초기값} + 5\\)”\n\n를 인스턴스 생성과 동시에 수행하는 클래스를 각각 만듦\n\nclass Times2(Init):\n    def __init__(self,value):\n        Init.__init__(self,value)\n        self.value = self.value * 2\n\n\na=Times2(5)\na.value\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n10\n\n\n\nclass Plus5(Init):\n    def __init__(self,value):\n        Init.__init__(self,value)\n        self.value = self.value + 5\n\n\na=Plus5(5)\na.value\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n10\n\n\n- 지나고 보니까 “\\({\\tt 초기값} = {\\tt 초기값} \\times 2 + 5\\)” 를 인스턴스 생성과 동시에 수행해주는 클래스를 만들고 싶음.\n\nclass Times2Plus5(Times2,Plus5):\n    def __init__(self,value):\n        Times2.__init__(self,value)\n        Plus5.__init__(self,self.value)\n\n\na = Times2Plus5(5)\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n\na.value \n\n15\n\n\n- 싫은이유1: 코드가 지저분하다.\n- 싫은이유2: 진정한 의미의 상속이 아닌것 같다.\n\nclass Times2Plus5():\n    def __init__(self,value):\n        Times2.__init__(self,value)\n        Plus5.__init__(self,self.value)\n\n\na = Times2Plus5(5)\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n\na.value \n\n15\n\n\n\n\nsuper()를 활용한 좋은사용예시\n- 아키텍처를 아래와 같이 바꾸자\n\nclass Init(object):\n    def __init__(self,value):\n        ## 여기는 Init 클래스야 \n        print(\"Init클래스에서 정의된 __init__메소드를 실행합니다\")        \n        self.value = value\n        \nclass Times2(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value * 2\n        \nclass Plus5(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value + 5\n        \nclass Times2Plus5(Plus5,Times2):\n    def __init__(self,value):\n        super().__init__(value)\n\n- 써보자\n\na=Times2Plus5(5)\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n\na.value\n\n15\n\n\n\n(5*2)+5\n\n15\n\n\n- 이것이 왜 가능?\n\n원리: mro상으로 상위에 있는 순서대로 타고 올라간 뒤, mro순서대로 한번씩만 __init__을 실행함!!\n\n- 소감: 코드가 깔끔하긴해 + 진정한 상속의 느낌도 있어 (그렇지만 사용하고 싶지는 않음)"
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#super의-사용방법",
    "href": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#super의-사용방법",
    "title": "15wk-1: 클래스공부 5단계 – 상속",
    "section": "super()의 사용방법",
    "text": "super()의 사용방법\n- 이제 “\\(({\\tt 초기값} \\times 2 + 5)\\times 2\\)” 를 수행해주는 클래스를 만들고 싶음.\n\nclass Init(object):\n    def __init__(self,value):\n        ## 여기는 Init 클래스야 \n        print(\"Init클래스에서 정의된 __init__메소드를 실행합니다\")        \n        self.value = value\n        \nclass Times2(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value * 2\n        \nclass Plus5(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value + 5\n        \nclass Times2Plus5Times2(Plus5,Times2):\n    def __init__(self,value):\n        super().__init__(value)\n        super(Plus5,self).__init__(self.value)\n\n\na=Times2Plus5Times2(5)\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n\na.value\n\n30\n\n\n\nTimes2Plus5Times2.mro()\n\n[__main__.Times2Plus5Times2,\n __main__.Plus5,\n __main__.Times2,\n __main__.Init,\n object]\n\n\n- 코드해석\n\nsuper().__init__(value) 은 Times2Plus5Times2의 MRO순서로 상위인 클래스 Init,Times2,Plus 의 __init__을 순서대로 실행하되 중복실행은 하지 않음.\nsuper(Plus5,self).__init__(self.value) 은 Plus5보다 MRO순서로 상위인 클래스 Init,Times2 의 __init__을 순서대로 실행하되 중복실행은 하지 않음.\n\n- 그냥 이게 낫지 않나?\n\nclass Init(object):\n    def __init__(self,value):\n        ## 여기는 Init 클래스야 \n        print(\"Init클래스에서 정의된 __init__메소드를 실행합니다\")        \n        self.value = value\n        \nclass Times2(Init):\n    def times2(self):\n        self.value = self.value * 2\n        \nclass Plus5(Init):\n    def plus5(self):\n        self.value = self.value + 5\n        \nclass Times2Plus5Times2(Plus5,Times2):\n    def times2plus5times2(self):\n        self.times2()\n        self.plus5()\n        self.times2()\n\n\na = Times2Plus5Times2(5)\n\nInit클래스에서 정의된 __init__메소드를 실행합니다\n\n\n\na.times2plus5times2()\n\n\na.value\n\n30\n\n\n- 그래도 이 문법을 알아야 한다. 왜??\n\n\n\n\n\n\n\n\n\n단계\n인터넷밈\n클래스\n레포트표지\n\n\n\n\n1단계: 구상\n\\(\\bullet\\) 이거 재미있다.  \\(\\bullet\\) 밈화하자.\n\\(\\bullet\\) 이 코드 반복해서 자주 쓸 것 같다.  \\(\\bullet\\) 이 코드를 쉽게 찍어내는 (복사할 수 있는) 클래스를 만들자\n\\(\\bullet\\) 레포트 표지를 자주 만들 것 같음  \\(\\bullet\\) 양식파일을 만들까?\n\n\n2단계: 틀생성\n\\(\\bullet\\) “밈틀”: 복사하고 싶은 속성을 추려 밈을 생산하기에 유리한 틀을 만듬\n\\(\\bullet\\) 클래스의 선언\n\\(\\bullet\\) REPORT_2023_최규빈.hwp 양식파일을 생성\n\n\n3단계: 틀 \\(\\to\\) 복제\n\\(\\bullet\\) 밈화: “밈틀”에서 다양한 밈을 만들고 놈\n\\(\\bullet\\) 인스턴스화: 클래스에서 인스턴스를 생산\n\\(\\bullet\\) 레포트 양식표지에서 다양한 레포트를 냄\n\n\n4단계: 틀 \\(\\to\\) 틀변경 \\(\\to\\) 복제\n\\(\\bullet\\) 생각해보니까 초기 밈틀은 시시함.  \\(\\bullet\\) 초기 밈틀을 수정해 새로운 밈틀을 만들고 더 재미있는 밈을 만들고 놈\n\\(\\bullet\\) 초기클래스와 비슷한 클래스를 선언할 일이 생김  \\(\\bullet\\) 상속,오버라이딩: 초기클래스를 상속받아 클래스를 새롭게 정의하고 인스턴스를 재 생산\n\\(\\bullet\\) 공모전에 참가하여 결과보고서를 작성할 일이 생김.  \\(\\bullet\\) REPORT_2023_최규빈.hwp 를 적당히 변형하여 수정된 틀을 만들고 결과보고서 생산.\n\n\n\n\n상속은 위의 표에서 4단계에 해당한다. 즉 어떠한 클래스를 상속받을때는 “내가 만든 클래스”가 아닐 경우가 대부분이다. 따라서 “애초부터 메소드가 겹치지 않게 클래스들을 깔끔하게 디자인을 하는것” 은 불가능한 경우가 많다."
  },
  {
    "objectID": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#리스트의-상속",
    "href": "PP2023/posts/03_Class/2023-06-12-15wk-1.html#리스트의-상속",
    "title": "15wk-1: 클래스공부 5단계 – 상속",
    "section": "리스트의 상속",
    "text": "리스트의 상속\n- list와 비슷한데 멤버들의 빈도가 계산되는 메소드를 포함하는 새로운 나만의 list를 만들고 싶다.\n\nlst = list('asdfasssdfa')\nlst \n\n['a', 's', 'd', 'f', 'a', 's', 's', 's', 'd', 'f', 'a']\n\n\n- 각 원소들의 빈도를 구해보면 아래와 같다.\n\n{s:lst.count(s) for s in set(lst)}\n\n{'d': 2, 'a': 3, 's': 4, 'f': 2}\n\n\n\nlst.freq() # 이렇게 실행하면 위의결과가 나왔으면 좋겠다.\n\nAttributeError: 'list' object has no attribute 'freq'\n\n\n- 이것을 내가 정의하는 새로운 list의 메소드로 넣고 싶다.\n\nclass List(list):\n    def freq(self):\n        return {s:self.count(s) for s in set(self)}\n\n\nlst2 = List('asdfasssdfa')\n\n\nlst2\n\n['a', 's', 'd', 'f', 'a', 's', 's', 's', 'd', 'f', 'a']\n\n\n\nlst\n\n['a', 's', 'd', 'f', 'a', 's', 's', 's', 'd', 'f', 'a']\n\n\n\n#lst2+lst ## 거의 lst2는 일반적인 lst와 같은역할\n\n- 기존리스트에서 추가로 frequency() 메소드가 존재함.\n\nlst2.freq()\n\n{'d': 2, 'a': 3, 's': 4, 'f': 2}"
  },
  {
    "objectID": "PP2023/posts/2023-05-08-10wk-1-mid.html",
    "href": "PP2023/posts/2023-05-08-10wk-1-mid.html",
    "title": "10wk-1: 중간고사",
    "section": "",
    "text": "제출은 *.ipynb, *.html, *.pdf 파일로 제출할 것"
  },
  {
    "objectID": "PP2023/posts/2023-05-08-10wk-1-mid.html#fifa23",
    "href": "PP2023/posts/2023-05-08-10wk-1-mid.html#fifa23",
    "title": "10wk-1: 중간고사",
    "section": "FIFA23",
    "text": "FIFA23\n(1)--(3) 아래는 FIFA23 자료를 불러오는 코드이다.\n\ndf=pd.read_csv('https://raw.githubusercontent.com/guebin/DV2022/master/posts/FIFA23_official_data.csv').drop(columns=['Loaned From', 'Best Overall Rating']).dropna().reset_index(drop=True)\ndf.head()\n\n\n\n\n\n\n\n\nID\nName\nAge\nPhoto\nNationality\nFlag\nOverall\nPotential\nClub\nClub Logo\n...\nWork Rate\nBody Type\nReal Face\nPosition\nJoined\nContract Valid Until\nHeight\nWeight\nRelease Clause\nKit Number\n\n\n\n\n0\n209658\nL. Goretzka\n27\nhttps://cdn.sofifa.net/players/209/658/23_60.png\nGermany\nhttps://cdn.sofifa.net/flags/de.png\n87\n88\nFC Bayern München\nhttps://cdn.sofifa.net/teams/21/30.png\n...\nHigh/ Medium\nUnique\nYes\n&lt;span class=\"pos pos28\"&gt;SUB\nJul 1, 2018\n2026\n189cm\n82kg\n€157M\n8.0\n\n\n1\n212198\nBruno Fernandes\n27\nhttps://cdn.sofifa.net/players/212/198/23_60.png\nPortugal\nhttps://cdn.sofifa.net/flags/pt.png\n86\n87\nManchester United\nhttps://cdn.sofifa.net/teams/11/30.png\n...\nHigh/ High\nUnique\nYes\n&lt;span class=\"pos pos15\"&gt;LCM\nJan 30, 2020\n2026\n179cm\n69kg\n€155M\n8.0\n\n\n2\n224334\nM. Acuña\n30\nhttps://cdn.sofifa.net/players/224/334/23_60.png\nArgentina\nhttps://cdn.sofifa.net/flags/ar.png\n85\n85\nSevilla FC\nhttps://cdn.sofifa.net/teams/481/30.png\n...\nHigh/ High\nStocky (170-185)\nNo\n&lt;span class=\"pos pos7\"&gt;LB\nSep 14, 2020\n2024\n172cm\n69kg\n€97.7M\n19.0\n\n\n3\n192985\nK. De Bruyne\n31\nhttps://cdn.sofifa.net/players/192/985/23_60.png\nBelgium\nhttps://cdn.sofifa.net/flags/be.png\n91\n91\nManchester City\nhttps://cdn.sofifa.net/teams/10/30.png\n...\nHigh/ High\nUnique\nYes\n&lt;span class=\"pos pos13\"&gt;RCM\nAug 30, 2015\n2025\n181cm\n70kg\n€198.9M\n17.0\n\n\n4\n224232\nN. Barella\n25\nhttps://cdn.sofifa.net/players/224/232/23_60.png\nItaly\nhttps://cdn.sofifa.net/flags/it.png\n86\n89\nInter\nhttps://cdn.sofifa.net/teams/44/30.png\n...\nHigh/ High\nNormal (170-)\nYes\n&lt;span class=\"pos pos13\"&gt;RCM\nSep 1, 2020\n2026\n172cm\n68kg\n€154.4M\n23.0\n\n\n\n\n5 rows × 27 columns\n\n\n\n(1) 공백이 포함된 column이름이 총 몇개인지 count하는 코드를 작성하라.\nhint 모두 11개의 column name에 공백이 포함되어있음\n(풀이)\n\nsum([' ' in name for name in df.columns])\n\n11\n\n\n(2) column name에 공백이 포함된 열을 출력하라.\n(풀이)\n\ndf.loc[:,[' ' in name for name in df.columns]]\n\n\n\n\n\n\n\n\nClub Logo\nPreferred Foot\nInternational Reputation\nWeak Foot\nSkill Moves\nWork Rate\nBody Type\nReal Face\nContract Valid Until\nRelease Clause\nKit Number\n\n\n\n\n0\nhttps://cdn.sofifa.net/teams/21/30.png\nRight\n4.0\n4.0\n3.0\nHigh/ Medium\nUnique\nYes\n2026\n€157M\n8.0\n\n\n1\nhttps://cdn.sofifa.net/teams/11/30.png\nRight\n3.0\n3.0\n4.0\nHigh/ High\nUnique\nYes\n2026\n€155M\n8.0\n\n\n2\nhttps://cdn.sofifa.net/teams/481/30.png\nLeft\n2.0\n3.0\n3.0\nHigh/ High\nStocky (170-185)\nNo\n2024\n€97.7M\n19.0\n\n\n3\nhttps://cdn.sofifa.net/teams/10/30.png\nRight\n4.0\n5.0\n4.0\nHigh/ High\nUnique\nYes\n2025\n€198.9M\n17.0\n\n\n4\nhttps://cdn.sofifa.net/teams/44/30.png\nRight\n3.0\n3.0\n3.0\nHigh/ High\nNormal (170-)\nYes\n2026\n€154.4M\n23.0\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n16359\nhttps://cdn.sofifa.net/teams/114628/30.png\nRight\n1.0\n3.0\n1.0\nMedium/ Medium\nNormal (185+)\nNo\n2027\n€218K\n35.0\n\n\n16360\nhttps://cdn.sofifa.net/teams/1478/30.png\nRight\n1.0\n2.0\n1.0\nMedium/ Medium\nLean (185+)\nNo\n2026\n€188K\n21.0\n\n\n16361\nhttps://cdn.sofifa.net/teams/113796/30.png\nRight\n1.0\n2.0\n1.0\nMedium/ Medium\nLean (185+)\nNo\n2023\n€142K\n12.0\n\n\n16362\nhttps://cdn.sofifa.net/teams/112260/30.png\nRight\n1.0\n2.0\n1.0\nMedium/ Medium\nNormal (185+)\nNo\n2021\n€214K\n40.0\n\n\n16363\nhttps://cdn.sofifa.net/teams/702/30.png\nLeft\n1.0\n2.0\n1.0\nMedium/ Medium\nNormal (185+)\nNo\n2021\n€131K\n30.0\n\n\n\n\n16364 rows × 11 columns\n\n\n\n(3) 데이터프레임을 올바르게 해석한 사람을 모두 고르시오 (모두 맞출경우만 정답으로 인정)\n\n세민: 데이터프레임에는 모두 27개의 열이 있다.\n성재: 한국선수(Nationality==Korea Republic)와 일본선수(Nationality==Japan)의 Overall의 평균값은 일본이 더 높다.\n민정: 총 159개의 나라선수들이 포함되어 있다.\n슬기: 선수들의 연령이 25세이상(&gt;=)인 선수들은 그렇지 않은 선수들보다 평균적으로 키(Height)가크다.\n\n(풀이)\n세민: 데이터프레임에는 모두 27개의 열이 있다 -&gt; True\n\nlen(df.columns) == 27\n\nTrue\n\n\n성재: 한국선수(Nationality==Korea Republic)와 일본선수(Nationality==Japan)의 Overall의 평균값은 일본이 더 높다. -&gt; True\n\ndf.query('Nationality == \"Korea Republic\"').Overall.mean() &lt; df.query('Nationality == \"Japan\"').Overall.mean()\n\nTrue\n\n\n민정: 총 159개의 나라선수들이 포함되어 있다. -&gt; True\n\nlen(set(df.Nationality))==159\n\nTrue\n\n\n슬기: 선수들의 연령이 25세이상(&gt;=)인 선수들은 그렇지 않은 선수들보다 평균적으로 키(Height)가크다. -&gt; True\n\n_old = np.mean([int(height[:3]) for height in df.query('Age&gt;=25').Height.tolist()]) \n_young =  np.mean([int(height[:3]) for height in df.query('Age&lt;25').Height.tolist()]) \n_old &gt; _young\n\nTrue"
  },
  {
    "objectID": "PP2023/posts/2023-05-08-10wk-1-mid.html#삼성전자의-주가",
    "href": "PP2023/posts/2023-05-08-10wk-1-mid.html#삼성전자의-주가",
    "title": "10wk-1: 중간고사",
    "section": "삼성전자의 주가",
    "text": "삼성전자의 주가\n(4)--(5) 다음은 삼성전자의 주가를 크롤링하는 코드이다.\n\nstart_date = \"2023-01-01\"\nend_date = \"2023-05-02\"\ny = yf.download(\"005930.KS\", start=start_date, end=end_date)['Adj Close'].to_numpy()\n\n[*********************100%***********************]  1 of 1 completed\n\n\n삼성전자의 주가 \\({\\boldsymbol y}\\)를 시각화하면 아래와 같다.\n\nplt.plot(y)\n\n\n\n\n(4) 아래와 같은 변환을 이용하여 \\({\\boldsymbol y}\\)를 \\(\\tilde {\\boldsymbol y}\\)로 변환하고 결과를 시각화하라.\n\n\\(\\tilde{y}_1= \\frac{1}{4}(3y_1 + y_2)\\)\n\\(\\tilde{y}_i= \\frac{1}{4}(y_{i-1}+2y_i+y_{i+1})\\), for \\(i=2,3,\\dots,n-1\\)\n\\(\\tilde{y}_n= \\frac{1}{4}(y_{n-1}+3y_{n})\\)\n\nhint: 아래의 코드를 관찰\n\nnp.eye(4) + np.array([abs(i-j)&lt;2 for i in range(4) for j in range(4)]).reshape(4,4) \n\narray([[2., 1., 0., 0.],\n       [1., 2., 1., 0.],\n       [0., 1., 2., 1.],\n       [0., 0., 1., 2.]])\n\n\n(풀이)\n\nT = len(y)\nM = (np.eye(T) + np.array([abs(i-j)&lt;2 for i in range(T) for j in range(T)]).reshape(T,T))/4\nM[0,0] = 3/4; M[-1,-1]= 3/4 \nplt.plot(y,label=r'$y$')\nplt.plot(M@y,'--',label=r'$M@y$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f6efc12bb80&gt;\n\n\n\n\n\n(5) (4)의 변환을 50회 반복적용하고 결과를 시각화하라.\n\nplt.plot(y,label=r'$y$')\nplt.plot(np.linalg.matrix_power(M,50)@y,'--',label=r'$M^{50}@y$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7f6efc6694f0&gt;"
  },
  {
    "objectID": "PP2023/posts/2023-05-08-10wk-1-mid.html#회귀모형",
    "href": "PP2023/posts/2023-05-08-10wk-1-mid.html#회귀모형",
    "title": "10wk-1: 중간고사",
    "section": "회귀모형",
    "text": "회귀모형\n(6)--(7) \\((x_i,y_i)\\)가 아래와 같이 주어졌다고 가정하자.\n\nx =  np.array([0.00983, 0.01098, 0.02951, 0.0384 , 0.03973, 0.04178, 0.0533 ,\n               0.058  , 0.09454, 0.1103 , 0.1328 , 0.1412 , 0.1497 , 0.1664 ,\n               0.1906 , 0.1923 , 0.198  , 0.2141 , 0.2393 , 0.2433 , 0.3157 ,\n               0.3228 , 0.3418 , 0.3552 , 0.3918 , 0.3962 , 0.4    , 0.4482 ,\n               0.496  , 0.507  , 0.53   , 0.5654 , 0.582  , 0.5854 , 0.5854 ,\n               0.6606 , 0.7007 , 0.723  , 0.7305 , 0.7383 , 0.7656 , 0.7725 ,\n               0.831  , 0.8896 , 0.9053 , 0.914  , 0.949  , 0.952  , 0.9727 ,\n               0.982  ])\ny =  np.array([0.7381, 0.7043, 0.3937, 0.1365, 0.3784, 0.3028, 0.1037, 0.3846,\n               0.706 , 0.7572, 0.2421, 0.232 , 0.9855, 1.162 , 0.4653, 0.6791,\n               0.6905, 0.6865, 0.9757, 0.7665, 0.9522, 0.4641, 0.5498, 1.1509,\n               0.5288, 1.1195, 1.1659, 1.4341, 1.2779, 1.1648, 1.4002, 0.7472,\n               0.9142, 0.9658, 1.0707, 1.4501, 1.6758, 0.8778, 1.3384, 0.7476,\n               1.3086, 1.7537, 1.5559, 1.2928, 1.3832, 1.3115, 1.3382, 1.536 ,           \n               1.9177, 1.2069])\n\n\nplt.plot(x,y,'o')\n\n\n\n\n6. 아래의 수식을 이용하여 적절한 추세선 \\(\\hat{y}_i= \\hat{\\beta}_0 +\\hat{\\beta}_1 x_i\\)를 구하고 시각화하라.\n\\[\\begin{bmatrix} \\hat{\\beta}_0 \\\\ \\hat{\\beta}_1 \\end{bmatrix} = ({\\bf X}^T {\\bf X})^{-1}{\\bf X}^T {\\boldsymbol y}, \\quad {\\bf X}=\\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\dots \\\\ 1 & x_n \\end{bmatrix}\\]\n(풀이)\n\nn = len(x)\nX = np.stack([np.ones(n),x],axis=1)\nb,a = np.linalg.inv(X.T@X)@X.T@y \nyhat = b+a*x \nplt.plot(x,y,'o')\nplt.plot(x,yhat,'--')\n\n\n\n\n7. \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\hat{y}_i)^2\\)을 계산하라.\n(풀이)\n\nnp.mean((y-yhat)**2)\n\n0.07602899763337416"
  },
  {
    "objectID": "PP2023/posts/2023-06-20-15wk-2-finsol.html",
    "href": "PP2023/posts/2023-06-20-15wk-2-finsol.html",
    "title": "15wk-2: 기말고사 풀이",
    "section": "",
    "text": "제출은 *.ipynb, *.html, *.pdf 파일로 제출할 것\n\nipynb 파일형태제출을 권장함.\n\n\nimports\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport datetime\n\n\n\n1. 묵찌빠 (150점)\n\n\n\n\n\n\n묵찌빠\n\n\n\nref: https://namu.wiki/w/묵찌빠\n묵찌빠는 가위바위보의 변형 놀이이다. 보통 가위바위보의 게임과 연이어 진행되는데, 가위바위보 승부 이후 이긴 사람이 공격권을 가지고, 묵(바위)/찌(가위)/빠(보자기) 가운데 하나를 외치는 동시에 말한 것과 일치하도록 손 모양을 바꾼다. 공격권을 가진 사람의 손 모양이 상대(수비권을 가진 사람)의 손 모양과 일치하면 공격권을 가진 사람의 승리한다. 승부가 갈리지 않았을 경우에는 다시 가위바위보를 하는 것이 아니라, 현 상태에서 가위바위보 규칙 상 이긴 사람이 공격권을 가져가게 된다.\n\n\n(1) 아래는 RPS_BASE 클래스의 구현예시이다.\n\nclass RPS_BASE:\n    def __init__(self,candidate):\n        self.candidate = candidate\n        self.actions = list() \n    def __setitem__(self,index,val):\n        self.actions[index] = val\n    def __getitem__(self,item):\n        return self.actions[item]        \n    def __len__(self):\n        return len(self.actions)\n    def __eq__(self,other):\n        return self[-1] == other[-1]\n    def __gt__(self,other):\n        return [self[-1],other[-1]] in [['묵','찌'],['찌','빠'],['빠','묵']]\n    def __ge__(self,other):\n        return (self == other) or (self &gt; other)\n    def __lt__(self,other):\n        return not (self &gt;= other)\n    def __le__(self,other):\n        return (self == other) or (self &lt; other)    \n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} &lt;br/&gt;\n        기록: {}\n        \"\"\"        \n        return html_str.format(self.candidate,self.actions)       \n    def pick(self):\n        self.actions.append(np.random.choice(self.candidate))        \n\n이 클래스에서 아래와 같은 2명의 플레이어 인스턴스를 생성하라.\n\na: [‘묵’,‘찌’] 중에 하나를 랜덤으로 선택\nb: [‘찌’,‘빠’] 중에 하나를 랜덤으로 선택\n\n두 인스턴스를 100회 랜덤대결하고 결과를 기록하라. 어떠한 플레이어가 더 유리한가?\n\n답안은 100회중 a몇회 승리, b몇회 승리와 같은 숫자형식으로만 나오면 인정한다. (코드를 정리하거나 별도의 클래스를 만드는 것을 요구하지 않음)\n\n(풀이)\n\na = RPS_BASE(['묵','찌'])\nb = RPS_BASE(['찌','빠'])\n\n\nrslt = []\nfor _ in range(100):\n    a.pick()\n    b.pick()\n    if a&gt;b: \n        rslt.append('a')\n    elif a==b: \n        rslt.append('-')\n    else: \n        rslt.append('b')\n\n\n{'a의승리':rslt.count('a'),'무승부':rslt.count('-'),'b의승리':rslt.count('b')}\n\n{'a의승리': 53, '무승부': 21, 'b의승리': 26}\n\n\n\n(2) RPS_BASE에서 아래와 같은 두명의 플레이어 인스턴스를 생성하라.\n\na: [‘묵’,‘찌’,‘빠’] 중 하나를 랜덤으로 선택\nb: [‘찌’,‘빠’] 중 하나를 랜덤으로 선택\n\n아래와 같은 a,b의 attribute을 변경하라.\n\na.modes = [None]\na.actions = [None] \nb.modes = [None]\nb.actions = [None]\n\n플레이어 a,b를 이용하여 반복적으로 가위바위보 대결을 수행하고 아래와 같이 대결결과에 따라 공격권을 결정하는 함수 mul을 만들어라.\n경우1: 플레이어 a가 승리할 경우\n\na가 공격모드, b가 수비모드가 된다.\na.modes에는 ‘Attack’ 이 b.modes에는 Defence가 추가된다.\na.actions와 b.actions는 각각의 플레이어가 선택한 패(묵,찌,빠)가 기록된다.\n\n경우2: 플레이어 b가 승리할 경우\n\nb가 공격모드, a가 수비모드가 된다.\nb.modes에는 ‘Attack’ 이 a.modes에는 Defence가 추가된다.\na.actions와 b.actions는 각각의 플레이어가 선택한 패(묵,찌,빠)가 기록된다.\n\n경우3: 비길경우\n\n공격권의 변화는 없다.\na.modes,b.modes는 각각 이전의 값이 추가된다.\na.actions와 b.actions는 각각의 플레이어가 선택한 패(묵,찌,빠)가 기록된다.\n\n아래는 함수 mul을 사용한 예시이다.\n시점1: 둘다 찌를 내어 공격권을 아무도 획득하지못함\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌']\n        \n\n\n\na.modes\n\n[None, None]\n\n\n\nb.modes\n\n[None, None]\n\n\n시점2: 이번에도 둘다 찌를 내어 아무도 공격권을 획득하지 못함\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '찌']\n        \n\n\n\na.modes\n\n[None, None, None]\n\n\n\nb.modes\n\n[None, None, None]\n\n\n시점3: 이번에는 a가 공격권을 획득 (묵&gt;찌)\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '묵']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '찌', '찌']\n        \n\n\n\na.modes\n\n[None, None, None, 'Attack']\n\n\n\nb.modes\n\n[None, None, None, 'Defence']\n\n\n시점4: 이번에는 b가 공격권을 획득 (찌&gt;빠)\n\nmul(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '묵', '빠']\n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '찌', '찌', '찌']\n        \n\n\n\na.modes\n\n[None, None, None, 'Attack', 'Defence']\n\n\n\nb.modes\n\n[None, None, None, 'Defence', 'Attack']\n\n\n(풀이) – 생략, (3)번 풀이로 대체\n\n(3) RPS_BASE를 상속받아 MookjjibbaPlayer라는 새로운 클래스를 정의하라. MookjjibbaPlayer 클래스에서 아래의 메소드를 새롭게 정의 혹은 재정의하여\n\n__init__\n_repr_html_\n__mul__\nreset\n\n인스턴스가 아래와 같은 동작을 하도록 설계하라.\n시점0: 생성예시 (__init__)\n\na=MookjjibbaPlayer(['묵','찌','빠'])\nb=MookjjibbaPlayer(['묵','찌','빠'])\n\n\na.actions\n\n[None]\n\n\n\na.modes\n\n[None]\n\n\n\n\n\n\n\n\n__init__ 의 동작\n\n\n\n\n슈퍼클래스(RPS_BASE)의 __init__을 동작시킴\nMookjjibbaPlayer의 인스턴가 가지는 actions, modes 값을 [None] 으로 초기화\n\n\n\n시점0: 출력예시(_repr_html_)\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\n\n\n\n\n\n_repr_html_ 의 동작\n\n\n\n위와 같이 “낼 수 있는 패”, “기록”, “모드” 가 함께 출력되도록 설계할 것\n\n\n시점1: 대결 및 결과출력 (__mul__, _repr_html_)\n\na*b\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵'] \n        모드: [None, None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵'] \n        모드: [None, None] \n        \n\n\n\n\n\n\n\n\n__mul__ 의 동작\n\n\n\n\n두 플레이어의 대결을 진행\n결과를 보고 modes 의 값을 update\n\n위의 상황은 두 플레이어 모두 “묵”을 내어 어느쪽도 공격권을 가지지 못한 상태를 의미\n\n\n시점2: 대결 및 결과출력 (__mul__, _repr_html_)\n\na*b\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵', '묵'] \n        모드: [None, None, 'Defence'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵', '빠'] \n        모드: [None, None, 'Attack'] \n        \n\n\n\n\n\n\n\n\n__mul__ 의 동작\n\n\n\n\n두 플레이어의 대결을 진행\n결과를 보고 modes 의 값을 update\n\n위의 상황은 a가 묵, b가 빠를 내어 b가 공격권을 획득한 상황을 의미\n\n\n시점3: 대결결과의 초기화 (reset)\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵', '묵'] \n        모드: [None, None, 'Defence'] \n        \n\n\n\na.reset()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\n\n\n\n\n\nreset 의 동작\n\n\n\n\n플레이어의 기록을 초기화\n플레이어의 모드를 초기화\n\n\n\n(풀이)\n\nclass MookjjibbaPlayer(RPS_BASE):\n    def __init__(self,candidate):\n        super().__init__(candidate)\n        self.modes = [None]\n        self.actions = [None]\n    def __mul__(self,other):\n        self.pick()\n        other.pick()\n        if self &gt; other:\n            self.modes.append('Attack')\n            other.modes.append('Defence')\n        elif self &lt; other:\n            self.modes.append('Defence')\n            other.modes.append('Attack')\n        else: \n            self.modes.append(self.modes[-1]) \n            other.modes.append(other.modes[-1])\n    def _repr_html_(self):\n        html_str = \"\"\"\n        낼 수 있는 패: {} &lt;br/&gt;\n        기록: {} &lt;br/&gt;\n        모드: {} &lt;br/&gt;\n        \"\"\"        \n        return html_str.format(self.candidate,self.actions,self.modes)\n    def reset(self):\n        self.__init__(self.candidate)\n\n__init__, _repr_html_ 체크\n\na=MookjjibbaPlayer(['묵','찌','빠'])\nb=MookjjibbaPlayer(['묵','찌','빠'])\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n__mul__, _repr_html_, reset 체크\n\nfor _ in range(3):\n    a*b\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '묵', '찌', '찌'] \n        모드: [None, 'Attack', 'Attack', 'Defence'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '묵'] \n        모드: [None, 'Defence', 'Defence', 'Attack'] \n        \n\n\n\na.reset()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\n(4) (3) 에서 생성된 MookjjibbaPlayer의 두 개의 인스턴스 a,b를 입력으로 받고 최초공격권을 결정하는 함수 jumpball을 설계하라.\n아래는 jumpball함수의 사용예시이다.\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\njumpball(a,b)\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '찌'] \n        모드: [None, None, None, 'Defence'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['묵', '찌', '빠'] \n        기록: [None, '찌', '찌', '묵'] \n        모드: [None, None, None, 'Attack'] \n        \n\n\n\n처음 2번의 가위,바위,보는 비겼으나 이후에 b가 승리하여 초기공격권을 b가 획득하였음.\n\n(풀이) – 생략, (5)번풀이 참고\n\n(5) 지금까지 코드를 바탕으로\n\na: [‘묵’,‘찌’] 중 하나를 랜덤으로 고르는 플레이어\nb: [‘찌’,‘빠’] 중 하나를 랜덤으로 고르는 플레이어\n\n를 설정하여 100회 가상대결을 진행하라. 100회 가상대결결과를 제시하라.\n(참고) – 아래는 제가 구현한 예시입니다. 참고용일 뿐이며 이와 같은 방식으로 구현할 필요는 없습니다.\n1. a,b 두명의 플레이어 생성\n\na=MookjjibbaPlayer(['묵','찌'])\nb=MookjjibbaPlayer(['찌','빠'])\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\na,b 플레이어가 초기화\n\n2. a,b 두명의 플레이어를 입력으로 하여 게임1을 생성후 1회 게임진행\n\ngame = PlayMookjjibba(a,b)\n\n\ngame.play()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None, '찌', '묵', '묵', '찌'] \n        모드: [None, 'Attack', 'Defence', 'Defence', 'Defence'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '빠', '빠', '빠', '찌'] \n        모드: [None, 'Defence', 'Attack', 'Attack', 'Attack'] \n        \n\n\n\na가 찌, b가 빠를 내어 최초 공격권을 a가 획득하였지만 이후 공격권을 상실한 상실함. 이후 4번째 가위바위보에서 b가 a가 동시에 찌를 내며 b의 승리로 마무리됨\n\n3. game.records 에 b의 승리가 기록되어 있음\n\ngame.records \n\n['b']\n\n\n4. 1회 대결기록을 삭제하고 또 다른 게임을 진행: 이번에는 a의 승리\n\ngame.reset_player_history()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None] \n        모드: [None] \n        \n\n\n\ngame.play()\n\n\na\n\n\n        낼 수 있는 패: ['묵', '찌'] \n        기록: [None, '찌', '찌', '찌'] \n        모드: [None, None, 'Attack', 'Attack'] \n        \n\n\n\nb\n\n\n        낼 수 있는 패: ['찌', '빠'] \n        기록: [None, '찌', '빠', '찌'] \n        모드: [None, None, 'Defence', 'Defence'] \n        \n\n\n\n공격권은 2번만에 A가 획득, 1번의 공격을 통하여 마무리\n\n5. 이번에는 a의 승리가 기록됨\n\ngame.records\n\n['b', 'a']\n\n\n(풀이)\n\nclass PlayMookjjibba:\n    def __init__(self,a,b):\n        self.a = a\n        self.b = b\n        self.records = list()\n    def reset_player_history(self):\n        self.a.reset()\n        self.b.reset()\n    def record(self):\n        if self.a.modes[-1] == 'Attack':\n            self.records.append('a')\n        else:\n            self.records.append('b')\n    def jumpball(self):\n        self.a * self.b \n        while self.a == self.b:\n            self.a * self.b \n    def play(self):\n        self.jumpball()\n        while self.a != self.b:\n            self.a * self.b \n        self.record()\n\n\na=MookjjibbaPlayer(['묵','찌'])\nb=MookjjibbaPlayer(['찌','빠'])\ngame = PlayMookjjibba(a,b)\n\n\nfor _ in range(1000):\n    game.play()\n\n\n{'a':game.records.count('a'),'b':game.records.count('b')}\n\n{'a': 678, 'b': 322}\n\n\n\n\n\n2. 종합문항 (50점)\n(1) LinearRegression 이라는 이름의 클래스를 만들고 아래의 기능을 넣어라.\n__init__: “클래스 \\(\\to\\) 인스턴스” 인 시점에 길이가 \\(n\\)인 numpy array \\({\\bf x}=(x_1,\\dots,x_n)\\), \\({\\bf y}=(y_1,\\dots,y_n)\\)을 입력으로 받아 내부에 저장한다.\nfit: fit은 내부에 저장된 \\({\\bf x}\\), \\({\\bf y}\\)를 이용하여 \\(\\hat{\\bf y}=(\\hat{y}_1,\\dots,\\hat{y}_n)\\)을 계산하는 역할을 한다. 계산은 아래의 수식을 이용한다. \\[\\hat{\\bf y}= {\\bf X}({\\bf X}^T {\\bf X})^{-1}{\\bf X}^T {\\bf y}, \\quad {\\bf X}=\\begin{bmatrix} 1 & x_1 \\\\ 1 & x_2 \\\\ \\dots \\\\ 1 & x_n \\end{bmatrix}\\]\nplot: plot은 \\((x_i,y_i)\\)와 \\((x_i,\\hat{y}_i)\\)를 시각화하는 역할을 한다.\n아래의 자료를 LinearRegression의 입력으로 받고 시각화하는 분석을 수행하라.\n\nx = np.linspace(0,1,100)\ny = 2*x + np.random.normal(size=100)\nplt.plot(x,y,'o')\n\n\n\n\n(풀이)\n\nclass LinearRegression: \n    def __init__(self,x,y):\n        self.x = x\n        self.y = y \n    def fit(self):\n        n = len(self.x)\n        self.X = np.stack([np.ones(n),self.x],axis=1)\n        self.yhat = self.X@np.linalg.inv(self.X.T@self.X)@self.X.T@self.y \n    def plot(self):\n        plt.plot(self.x,self.y,'o',label=r'$(x_i,y_i)$')\n        plt.plot(self.x,self.yhat,'--',label=r'$(x_i,\\hat{y}_i)$')\n        plt.legend()\n\n\nlinreg = LinearRegression(x,y)\nlinreg.fit()\nlinreg.plot()\n\n\n\n\n\n5월24일 12wk-2 숙제참고\n\n\n(2) 앞면과 뒷면이 나올 확률이 각각 1/2인 동전을 생각하자. 하니와 규빈은 이 동전을 연속으로 던져서 아래와 같은 룰을 정하여 내기를 하였다.\n\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,앞면) 이 나오면 하니의 승리\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,뒷면) 이 나오면 규빈의 승리\n\n이 내기는 하니가 유리한가? 규빈이 유리한가? 시뮬레이션을 통해 검증하라.\n\n\n\n\n\n\nNote\n\n\n\nhint: 똑같이 유리하다\n\n\n(풀이)\nStep1 CoinFlipper 설계\n\nclass CoinFlipper: \n    def __init__(self):\n        self.coins = list()\n        self.win_cond = {'하니':[],'규빈':[]}\n        self.winner = str()        \n    def __iter__(self):\n        return self \n    def __next__(self):\n        self.coins.append(np.random.choice(['앞면','뒷면']))\n        if self.coins[-2:] == self.win_cond['하니']:\n            self.winner = '하니'\n            raise StopIteration\n        elif self.coins[-2:] == self.win_cond['규빈']:\n            self.winner = '규빈'\n            raise StopIteration        \n        else:\n            pass\n    def __call__(self,win_cond):\n        self.win_cond = win_cond\n        for _ in self:\n            pass \n    def __repr__(self):\n        repr_str = '하니의 승리조건: {}\\n규빈의 승리조건: {}\\n동전을 던진결과들: {}\\n최종승리자: {}'.format(\n            self.win_cond['하니'],\n            self.win_cond['규빈'],\n            self.coins,\n            self.winner\n        )\n        return repr_str\n\n\ncoin_fliper = CoinFlipper()\n\n\ncoin_fliper\n\n하니의 승리조건: []\n규빈의 승리조건: []\n동전을 던진결과들: []\n최종승리자: \n\n\n\nwin_cond = {\n    '하니':['앞면','뒷면'],\n    '규빈':['뒷면','앞면']\n}\ncoin_fliper(win_cond)\n\n\ncoin_fliper\n\n하니의 승리조건: ['앞면', '뒷면']\n규빈의 승리조건: ['뒷면', '앞면']\n동전을 던진결과들: ['뒷면', '뒷면', '뒷면', '뒷면', '앞면']\n최종승리자: 규빈\n\n\nStep2: 100회 대결진행\n\ncoinfliper_lst = [CoinFlipper() for _ in range(100)]\nwinners = [] \nfor coinfliper in coinfliper_lst:\n    coinfliper(win_cond)\n    winners.append(coinfliper.winner)\n\n\n{'하니':winners.count('하니'), '규빈':winners.count('규빈')}\n\n{'하니': 51, '규빈': 49}\n\n\n\n참고로 \\(n\\)회 대결결과는 아래와 같이 조회가능\n\ncoinfliper_lst[3]\n\n하니의 승리조건: ['앞면', '뒷면']\n규빈의 승리조건: ['뒷면', '앞면']\n동전을 던진결과들: ['앞면', '앞면', '뒷면']\n최종승리자: 하니\n\n\n\n(3) 앞면과 뒷면이 나올 확률이 각각 1/2인 동전을 생각하자. 하니와 규빈은 이 동전을 연속으로 던져서 아래와 같은 룰을 정하여 내기를 하였다.\n\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (앞면,뒷면) 이 나오면 하니의 승리\n동전을 연속으로 반복하여 던진다. 최근 2회의 결과가 (뒷면,뒷면) 이 나오면 규빈의 승리\n\n이 내기는 하니가 유리한가? 규빈이 유리한가? 시뮬레이션을 통해 검증하라.\n\n\n\n\n\n\nNote\n\n\n\nhint: 이 내기는 하니가 유리하다.\n\n\n(풀이)\n\nwin_cond = {\n    '하니':['앞면','뒷면'],\n    '규빈':['뒷면','뒷면']\n}\ncoin_fliper(win_cond)\n\n\ncoinfliper_lst = [CoinFlipper() for _ in range(100)]\nwinners = [] \nfor coinfliper in coinfliper_lst:\n    coinfliper(win_cond)\n    winners.append(coinfliper.winner)\n\n\n{'하니':winners.count('하니'), '규빈':winners.count('규빈')}\n\n{'하니': 73, '규빈': 27}\n\n\n\n(4) Time을 상속받아 Init 클래스를 만들고 __repr__을 조작하여 아래와 같이 인스턴스 생성시점을 출력하는 기능을 구현하라.\n\nclass Time:\n    def time(self):\n        return datetime.datetime.now().strftime('%y-%m-%d %X')\n\n(풀이)\n\nclass Init(Time):\n    def __init__(self):\n        self.init_time = self.time()\n    def __repr__(self):\n        return '인스턴스생성시점: {}'.format(self.init_time)\n\n\na = Init()\n\n\na\n\n인스턴스생성시점: 23-06-20 14:05:58\n\n\n\nb = Init()\n\n\na,b\n\n(인스턴스생성시점: 23-06-20 14:05:58, 인스턴스생성시점: 23-06-20 14:05:59)\n\n\n\n(5) tuple 클래스와 아래의 Check를 상속받아 아래와 같은 역할을 하는 새로운 Tuple 클래스를 만들라.\n\nclass Check:\n    def ckeck(self):\n        return [l for l in dir(self) if l[0]!='_']\n\n(풀이)\n\nclass Tuple(Check,tuple):\n    def freq(self):\n        return {s:self.count(s) for s in set(self)}\n    def __repr__(self):\n        return super().__repr__() + '\\n' +'methods={}'.format(self.ckeck())\n\n\ntpl = Tuple('asdfassdfsasdf')\ntpl # 값과 함께 사용가능한 메소드가 함께 출력 \n\n('a', 's', 'd', 'f', 'a', 's', 's', 'd', 'f', 's', 'a', 's', 'd', 'f')\nmethods=['ckeck', 'count', 'freq', 'index']\n\n\n\ntpl.freq()\n\n{'f': 3, 'd': 3, 's': 5, 'a': 3}\n\n\n\n(6) 아래와 같은 클래스를 고려하자.\n\nclass Init(object):\n    def __init__(self,value):\n        self.value = value\n        \nclass Times2(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value * 2\n        \nclass Plus5(Init):\n    def __init__(self,value):\n        super().__init__(value)\n        self.value = self.value + 5\n\nPlus5와 Times2를 상속하여 적당한 클래스 Times2Plus5를 정의하고 생성과 동시에 \\(x \\to (x\\times 2)+5\\) 를 수행도록 하라.\n(풀이)\n\nclass Times2Plus5(Plus5,Times2):\n    def __init__(self,value):\n        super().__init__(value)\n\n사용예시\n\na=Times2Plus5(0)\na.value\n\n5\n\n\n\na=Times2Plus5(1)\na.value\n\n7\n\n\n\na=Times2Plus5(5)\na.value\n\n15\n\n\n\n(7) 아래의 함수가 있다고 하자.\n\ndef f(x): \n    return np.sin(x)\n\n적당한 함수 derivate를 정의하여 함수를 입력으로 받으면 그 도함수를 출력으로 리턴하도록 하라. 아래의 코드를 이용하여 검증하라.\n\nx = np.linspace(-6,6,100)\nplt.plot(x,f(x),label=r'$f(x)=\\sin(x)$')\nplt.plot(x,(derivate(f))(x),label=r'$f\\'(x)=\\cos(x)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7effa80130a0&gt;\n\n\n\n\n\n(풀이)\n\ndef f(x): \n    return np.sin(x)\ndef derivate(f): \n    # step1: 함수오브젝트 f는 입력으로 받은상태 \n    # step2: 함수오브젝트 f를 이용하여 df라는 함수를 정의 \n    def df(x): \n        h=0.000000000001\n        return (f(x+h)-f(x))/h \n    # step3: 정의된 df를 리턴\n    return df\n\n\nx = np.linspace(-6,6,100)\nplt.plot(x,f(x),label=r'$f(x)=\\sin(x)$')\nplt.plot(x,(derivate(f))(x),label=r'$f\\'(x)=\\cos(x)$')\nplt.legend()\n\n&lt;matplotlib.legend.Legend at 0x7effa7ec2f10&gt;\n\n\n\n\n\n\n(8) Student 클래스를 생성지침 및 사용예시를 참고하여 설계하라.\n생성지침\nattributes\n\nname: 이름을 저장하는 변수\nage: 나이를 저장하는 변수\nsemester: 학기를 저장하는 변수\n\nmethods\n\n__init__: name, age, semester 세 가지 매개변수를 입력받아 인스턴스의 attribute로 저장\n__str__: 인스턴스의 정보(이름,나이,학기)를 문자열 형태로 반환\n\n사용예시\n\n# 사용 예시\nboram = Student(name='김보람', age=20, semester=1)\nprint(boram)\n\n이름: 김보람\n나이: 20\n학기: 1\n\n\n(풀이)\n\nclass Student:\n    def __init__(self,name='김보람',age=20,semester=0): \n        self.name = name\n        self.age = age\n        self.semester = semester\n    def __str__(self):\n        print_str = '''이름: {}\\n나이: {}\\n학기: {}'''.format(self.name,self.age,self.semester)\n        return print_str\n\n\n# 사용 예시\nboram = Student(name='김보람', age=20, semester=1)\nprint(boram)\n\n이름: 김보람\n나이: 20\n학기: 1\n\n\n\n(9) 8의 클래스를 상속받아 Student2 만들라. __add__ 재정의하여 Student2의 인스턴스가 아래와 같이 동작하도록 하라.\n\nboram = Student2()\n\n입학을 축하합니다. 당신의 나이는 20이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록'+ '휴학' + '등록' + '휴학'\nboram\n\n\n        나이: 22.0 \n        학기: 2 \n        \n\n\n\n4학기가 지났으므로 나이는 22살이 된다. 4학기중 2학기만 등록하였으므로 현재는 2학기를 마친상태이다.\n\n(풀이)\n\nclass Student2(Student):\n    def __init__(self,name='김보람',age=20,semester=0): \n        super().__init__()\n        print(\"입학을 축하합니다. 당신의 나이는 {}이고 현재 학기는 {}학기 입니다.\".format(self.age,self.semester))\n    def __add__(self,registration_status): \n        if registration_status=='휴학': \n            self.age=self.age+0.5\n        elif registration_status=='등록':\n            self.age=self.age+0.5 \n            self.semester= self.semester+1 \n        return self\n    def _repr_html_(self):\n        html_str = \"\"\"\n        나이: {} &lt;br/&gt;\n        학기: {} &lt;br/&gt;\n        \"\"\"\n        return html_str.format(self.age,self.semester)\n\n\nboram = Student2()\n\n입학을 축하합니다. 당신의 나이는 20이고 현재 학기는 0학기 입니다.\n\n\n\nboram + '등록'+ '휴학' + '등록' + '휴학'\nboram\n\n\n        나이: 22.0 \n        학기: 2 \n        \n\n\n\n(10) 적당한 클래스를 선언하여 \\(f(x)=x+{\\tt const}\\)를 수행하는 함수를 생성하도록 하라.\n사용예시1\n\nf = AddConstant(5) # f(x) = x+5 \n\n\nf(10)\n\n15\n\n\n사용예시2\n\nf = AddConstant(-3) # f(x) = x-3\n\n\nf(10)\n\n7\n\n\n(풀이)\n\nclass AddConstant: \n    def __init__(self,const):\n        self.const = const \n    def __call__(self,x):\n        return x + self.const\n\n\nf = AddConstant(5) # f(x) = x+5 \nf(10)\n\n15\n\n\n\nf = AddConstant(-3) # f(x) = x-3\nf(10)\n\n7"
  },
  {
    "objectID": "PP2023/posts/Appendix/2021-04-20-mid.html",
    "href": "PP2023/posts/Appendix/2021-04-20-mid.html",
    "title": "참고자료: 2021-04-mid",
    "section": "",
    "text": "클로즈 북, 40분, 문제미리공개X\n\n\n2021년 파이썬 입문 중간고사\n\n1 다음을 읽고 참인것을 모두 골라라. (10점)\n(ㄱ) 딕셔너리는 key와 value가 하나의 쌍으로 되어 {}로 둘러싸여 있다. \n(ㄴ) `abs(-20)`의 실행결과는 `20`이다. \n(ㄷ) `[1]+[2]`의 실행결과는 `[3]` 이다. \n(ㄹ) `(1,)`의 자료형은 tuple이다. \n(ㅁ) 자료형이 `str`이면 각 원소를 쉽게 바꿀 수 있다. \n\n\n2 아래의 실행결과 중 올바른 것은? (35점)\n\n(a)\na=1.0\nb=2\ntype(a+b)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(b)\na=1\nb=2\ntype(a==b)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(c)\na=1\nb=2\ntype(int(a==b))\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(d)\ntype([1,2,3])\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(e)\na=1\ntype(a)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(f)\na=(1)\ntype(a)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n(g)\na=(1,)\ntype(a)\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n\n3 아래의 코드를 잘 읽고 물음에 답하라. (25점)\na=[1,[2],2,[1]]\n\ndef a_add(a,i,j): \n    if type(a[i])==type(a[j]): \n        rtn=a[i]+a[j]\n    else:\n        rtn=a[i],a[j]\n    return rtn\n\n(a) 아래의 출력결과 중 바른 것은?\na[0]==a[2]\n(ㄱ) True (ㄴ) False\n\n\n(b) 아래의 출력결과 중 바른 것은?\ntype(a[0])==type(a[2])\n(ㄱ) True (ㄴ) False\n\n\n(c) 아래의 출력결과를 쓰라.\na_add(a,0,2)\n\n\n(d) 아래의 출력결과를 쓰라.\na_add(a,1,3)\n\n\n(e) 아래의 출력결과중 적절한 것은?\ntype(a_add(a,0,1))\n(ㄱ) int (ㄴ) float (ㄷ) bool  (ㄹ) complex \n(ㅁ) str (ㅂ) list  (ㅅ) tuple (ㅇ) dict \n\n\n\n4 원주율을 출력하는 방법 중 올바른 것을 모두 고르시오 (10점)\n(ㄱ) \nimport math\nmath.pi\n\n(ㄴ) \nimport math\npi \n\n(ㄷ)\nfrom math import pi\npi\n\n(ㄹ)\nfrom math import *\npi\n\n\n5 아래의 에러메시지가 나오는 (잘못된) 코드는? (10점)\n\n(a)\nTypeError: object of type 'float' has no len()\n(ㄱ) len(3.14) \n(ㄴ) len([3.14]) \n(ㄷ) len((3.14,)) \n(ㄹ) len('3.14') \n\n\n(b) (a)의 에러가 나오는 이유에 대하여 설명하라.\n\n\n\n6 아래와 같이 a를 선언하였다고 하자. (ㄱ)-(ㄹ) 중 옳은 설명을 모두 골라라. (10점)\na='guebin'\n(ㄱ) a의 자료형은 str이다. 즉 type(a)의 출력결과는 str이다. \n(ㄴ) len(a)의 실행결과는 1이다. \n(ㄷ) a[0]='G'와 같은 방법으로 첫글자를 대문자로 바꿀 수 있다. \n(ㄹ) a*2의 실행결과는 'guebinguebin'이다. \n\n\n7 [예제코드]의 결과를 관찰하고 물음에 답하라. (10점)\n## 예제코드 ## \na=['G','u','e','b','i','n']\ndel a[0]\na\n## 실행결과 \n['u', 'e', 'b', 'i', 'n']\n\n(a) 아래코드의 출력결과를 쓰라.\na=['G','u','e','b','i','n']\ndel a[0]\ndel a[0]\n\n\n(b) 아래코드의 출력결과 중 올바른 것은?\nb=['1','2','3']\ndel b[-1]\nb\n(ㄱ) ['1', '2']\n(ㄴ) ['2', '3']\n(ㄷ) ['1', '3']\n(ㄹ) 에러메시지로 출력할 수 없음. \n\n\n\n8 다음을 읽고 물음에 답하라. (15점)\n\n(a) 아래는 .append에 대한 사용예시이다.\n### .append 예시 \na=[1,2]\na.append(3)\nprint(a)\n### 실행결과 \n[1, 2, 3]\n\n\n위의 코드를 참고하여 아래의 실행결과를 쓰라.\nx=[]\nfor i in [0,1,2,3,4,5]:\n    x.append(2**i)\nx\n\n\n(b) 리스트 컴프리헨션을 사용하여 (a)와 동일한 출력결과를 얻는 코드를 작성하라.\n\n\n(c) 리스트 컴프리헨션을 사용하여 아래의 출력결과를 얻는 코드를 작성하라.\n['X1','X2','X3','Y1','Y2','Y3']\n\n\n\n9 a,b에 저장된 두 값을 교환하고 싶다고 하자. 아래의 ???에 알맞은 내용을 적으시오. (10점)\na=10\nb=20\n???\na,b\n## 실행결과\n(20, 10)\n\n\n10 아래의 코드에 대한 출력결과를 쓰라. (10점)\nidlist=[('guebin', '202112345','M','Korea'), \n        ('iu', '202154321','F','Korea'), \n        ('hodong', '201812321','M','Korea')]\nfor name, _, _, _ in idlist: \n    print(name)        \n\n\n11 리스트를 활용하여 아래와 같은 배열을 만들었다고 하자. (15점)\na=[[11,12,13], \n   [21,22,23], \n   [31,32,33]]\n\n(a) 아래코드의 시행결과를 쓰라.\na[0][1]+a[1][2]\n\n\n(b) 아래코드의 시행결과를 쓰라.\na[0]+a[1]\n\n\n(c) 아래코드의 시행결과를 쓰라.\nimport numpy as np\na=np.array(a)\na[0]+a[1]\n\n\n\n12 아래와 같은 연립방정식을 만족하는 해 \\((w,x,y,z)\\)를 푸는 코드를 작성하라. (20점)\n\\(\\begin{cases} x+y+z=3 \\\\ w+y+z=3 \\\\ w+x+z=3 \\\\ w+x+y=3 \\end{cases}\\)\n\n\n13 아래와 같은 행렬을 numpy를 이용하여 선언했다고 하자. (15점)\nimport numpy as np\nA=np.array([[11,12,13,14,15],\n            [21,22,23,24,25],\n            [31,32,33,34,35]])\n\n(a) 다음 코드의 실행결과로 적절한 것은?\nA[1]\n(ㄱ) array([11, 12, 13, 14, 15])\n(ㄴ) array([21, 22, 23, 24, 25])\n(ㄷ) array([11, 21, 31])\n(ㄹ) array([12, 22, 32])\n\n\n(b) 다음 코드의 실행결과로 적절한 것은?\nA[1,:]\n(ㄱ) array([11, 12, 13, 14, 15])\n(ㄴ) array([21, 22, 23, 24, 25])\n(ㄷ) array([11, 21, 31])\n(ㄹ) array([12, 22, 32])\n\n\n(c) 다음 코드의 실행결과로 적절한 것은?\nA[np.ix_([0,1],[0,1])]\n(ㄱ)\narray([[11, 12],\n       [21, 22]]) \n(ㄴ) \narray([[11, 21],\n       [12, 22]]) \n(ㄷ) \narray([11, 12, 21, 22]) \n\n(ㄹ) \narray([12, 22, 11, 12])\n\n\n\n14 적당한 과정을 통하여 아래와 같은 데이터를 얻었다고 가정하자. (20점)\nimport pandas as pd\n#...적당한과정...\ndf\n\n#hide_input\nfrom IPython.display import HTML\nHTML('&lt;table border=\"1\" class=\"dataframe\"&gt;\\n  &lt;thead&gt;\\n    &lt;tr style=\"text-align: right;\"&gt;\\n      &lt;th&gt;&lt;/th&gt;\\n      &lt;th&gt;age&lt;/th&gt;\\n      &lt;th&gt;toeic&lt;/th&gt;\\n      &lt;th&gt;gpa&lt;/th&gt;\\n    &lt;/tr&gt;\\n  &lt;/thead&gt;\\n  &lt;tbody&gt;\\n    &lt;tr&gt;\\n      &lt;th&gt;새로이&lt;/th&gt;\\n      &lt;td&gt;30.0&lt;/td&gt;\\n      &lt;td&gt;600&lt;/td&gt;\\n      &lt;td&gt;4.0&lt;/td&gt;\\n    &lt;/tr&gt;\\n    &lt;tr&gt;\\n      &lt;th&gt;이서&lt;/th&gt;\\n      &lt;td&gt;20.0&lt;/td&gt;\\n      &lt;td&gt;950&lt;/td&gt;\\n      &lt;td&gt;4.2&lt;/td&gt;\\n    &lt;/tr&gt;\\n    &lt;tr&gt;\\n      &lt;th&gt;일권&lt;/th&gt;\\n      &lt;td&gt;28.0&lt;/td&gt;\\n      &lt;td&gt;450&lt;/td&gt;\\n      &lt;td&gt;2.3&lt;/td&gt;\\n    &lt;/tr&gt;\\n    &lt;tr&gt;\\n      &lt;th&gt;현이&lt;/th&gt;\\n      &lt;td&gt;28.0&lt;/td&gt;\\n      &lt;td&gt;650&lt;/td&gt;\\n      &lt;td&gt;3.8&lt;/td&gt;\\n    &lt;/tr&gt;\\n  &lt;/tbody&gt;\\n&lt;/table&gt;')\n\n\n\n\n\nage\ntoeic\ngpa\n\n\n\n\n새로이\n30.0\n600\n4.0\n\n\n이서\n20.0\n950\n4.2\n\n\n일권\n28.0\n450\n2.3\n\n\n현이\n28.0\n650\n3.8\n\n\n\n\n\n\n(a) 첫 두열(age,toeic)에 접근하는 코드를 써라.\n\n\n(b) 토익점수가 800이상인 사람을 불러오는 코드를 써라.\n\n\n(c) 세번째 열(gpa)에 접근하는 코드 중 적절한 것을 모두 골라라.\n(ㄱ) \ndf.loc['gpa']\n(ㄴ) \ndf.iloc[:,2]\n(ㄷ) \ndf.iloc[:,-1]\n(ㄹ) \ndf.iloc[2]\n\n\n(d) 나이가 23보다 많고 토익점수가 635이하 학점이 3.0 이상인 사람을 불러오는 코드를 작성하라.\n\n\n\n15 아래를 보고 적절한 설명을 한 사람을 모두 고르라. (10점)\nimport vec\nvec?\nType:        module\nString form: &lt;module 'vec' from '/home/cgb2/vec/__init__.py'&gt;\nFile:        ~/vec/__init__.py\nDocstring:   이 패키지는 현재 길이가 2,3인 벡터의 연산만 지원하지만 추후 업데이트하여 더욱 발전할 예정\n(로이) import vec이 실행되는 것을 보니 (1) 사용자가 vec이라는 패키지를 설치했거나 (2) 사용자가 현재 작업중인 폴더에 vec.py파일을 만들었거나 (3) 사용자가 현재 작업중인 폴더 아래 vec이라는 폴더가 존재하는 경우등 중 하나라고 볼 수 있겠군.\n(이서) 네, 그런데 vec?의 실행 결과중 File:을 확인해 보니 사용자가 작업중인 폴더아래 vec이라는 폴더가 있는것으로 판단됩니다.\n(일권) 이서가 말한대로 File:을 확인해보니 사용자가 vec폴더에 __init__.py도 만들어 놓았음을 알수 있군. __init__.py는 import vec을 수행하면 암시적으로 실행된다고 했었지?\n(현이) 그렇지, 그런데 사실 파일 이름이 꼭 __init__.py이어야 하는것은 아니야.\n(수아) vec?의 실행결과 Docstring:이 있는것으로 보아 __init__.py상단에 아래와 같은 내용이 있음을 유추할 수 있어.\n'''\n이 패키지는 현재 길이가 2,3인 벡터의 연산만 지원하지만 추후 업데이트하여 더욱 발전할 예정\n'''"
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-05-03-mid.html",
    "href": "PP2023/posts/Appendix/2022-05-03-mid.html",
    "title": "참고자료: 2022-04-mid",
    "section": "",
    "text": "오픈 북, 2시간, 문제유형만 공개"
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-05-03-mid.html#imports",
    "href": "PP2023/posts/Appendix/2022-05-03-mid.html#imports",
    "title": "참고자료: 2022-04-mid",
    "section": "0. imports",
    "text": "0. imports\n아래코드를 이용하여 numpy 와 matplotlib을 import하라.\n\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-05-03-mid.html#코드구현-i-40점",
    "href": "PP2023/posts/Appendix/2022-05-03-mid.html#코드구현-i-40점",
    "title": "참고자료: 2022-04-mid",
    "section": "1. 코드구현 I (40점)",
    "text": "1. 코드구현 I (40점)\n주의: 문제에 조건이 있는 경우 조건을 준수할 것\n(1) a의 type을 bool로 바꾸어라.\n\na=1.0\n\n\nnote: 출제의도: 자료형의 변환\n\n(풀이)\n\nbool(a)\n\nTrue\n\n\n\n(2)-(6)\n아래의 문자열을 고려하자.\n\ntest_arr = 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@mylaptop.local'\n\n(2) 위 문자열에서 짝수번째 원소를 출력하는 코드를 작성하라.\n\nnote: 출제의도: 인덱싱, 스트라이딩\n\n(풀이)\n\ntest_arr[1::2]\n\n's-s AA3zCy2AABwAQAlUkHfY7bmINTKTo/WSGlnflDY7d4Ze1J4WjhFvQMxEEfhlXQkPpw0d3b7OJMylXC+A3XiBxXnhpAscL86jNQddFSV/XtFoosc19530w8eFbzUlQKrX8yNvYb6wP0wr/nZA4ZnP8ZmMuyDc8Zi8+wr+namkns10QalqSbNRiwfMQ=shcnmlpo.oa'\n\n\n(3) 위 문자열에서 마지막 10개의 원소를 출력하는 코드를 작성하라.\n\nnote: 출제의도: -인덱싱\n\n(풀이)\n\ntest_arr[-10:]\n\n'ptop.local'\n\n\n(4) 위 문자열을 뒤집은 문자열을 구하는 코드를 작성하라. 즉 아래를 출력하는 코드를 작성하라.\n'lacol.potpalym@nocahcs ==Q7M+frw9iFRrNxbsSVqMlTarQ10d1os2njkImtaKn1+3r3wg+b8li/Z68Ec2DryauLMVmPZ98IPTnPZO4WA+ZmnE/trewr0bP/wv6ybNYjvDNpyX88XrrpKJQjlFUuz1bmFIe/86wW0V3+5x9Q1McnsAoJoaF3tAX7/KVlSvFMdsdwQANsjR6V8qLicMsZAHpXhKn1XixqBtiRXF3oAH+RCFXWlByTM/JdOk7vbP3adc0gwSppPbkVQ5XFl9h4fVELElx7MzQivrFUhbj9WJ4HJ81we5Zy4Idh7WYTDHlzfan+lPGUSDWB/mojT9KGTLNpITmrbS71YHfrHDkpUOlkAEQAAAwIBAAAAE2cy1CazN3BAAAA asr-hss'\n\nnote: 출제의도: -1 스트라이딩\n\n(풀이)\n\ntest_arr[::-1]\n\n'lacol.potpalym@nocahcs ==Q7M+frw9iFRrNxbsSVqMlTarQ10d1os2njkImtaKn1+3r3wg+b8li/Z68Ec2DryauLMVmPZ98IPTnPZO4WA+ZmnE/trewr0bP/wv6ybNYjvDNpyX88XrrpKJQjlFUuz1bmFIe/86wW0V3+5x9Q1McnsAoJoaF3tAX7/KVlSvFMdsdwQANsjR6V8qLicMsZAHpXhKn1XixqBtiRXF3oAH+RCFXWlByTM/JdOk7vbP3adc0gwSppPbkVQ5XFl9h4fVELElx7MzQivrFUhbj9WJ4HJ81we5Zy4Idh7WYTDHlzfan+lPGUSDWB/mojT9KGTLNpITmrbS71YHfrHDkpUOlkAEQAAAwIBAAAAE2cy1CazN3BAAAA asr-hss'\n\n\n(5) 위 문자열에서 대문자의 수를 count하라.\nhint .isupper() 메소드를 이용할 것.\n\n'a'.isupper()\n\nFalse\n\n\n\n'A'.isupper()\n\nTrue\n\n\n\n'='.isupper()\n\nFalse\n\n\n\n'@'.isupper()\n\nFalse\n\n\n\nnote: 출제의도: 리스트컴프리헨션, bool자료형의 sum\n\n(풀이)\n\nsum([s.isupper() for s in test_arr])\n\n155\n\n\n(6) 위 문자열에서 사용된 문자 및 특수문자의 종류는 모두 몇가지 인가?\nnote1: 문자열 ‘AAB @ab’ 에서 사용된 문자는 ‘A’, ‘B’, ’ ‘,’@‘, ’a’, ‘b’ 이므로 모두 6종류의 문자 및 특수문자가 사용되었다.\nnote2: ’ ‘,’+‘,’-‘,’.’, ‘/’, ‘=’, ‘@’, ‘1’, ‘a’, ‘A’ 등을 모두 다른 문자로 취급한다.\n\nnote: 출제의도: set 자료형의 이해\n\n(풀이)\n\nlen(set(test_arr))\n\n69\n\n\n\n(7) 리스트컴프리헨션을 이용하여 아래와 같은 리스트를 생성하라\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa'] &lt;- a가 10개있음 \n\nnote: 출제의도: 문자열의 * 연산, 리스트컴프리헨션\n\n(풀이)\n\n['a'*i for i in range(1,11)]\n\n['a',\n 'aa',\n 'aaa',\n 'aaaa',\n 'aaaaa',\n 'aaaaaa',\n 'aaaaaaa',\n 'aaaaaaaa',\n 'aaaaaaaaa',\n 'aaaaaaaaaa']\n\n\n(8) 길이가 1인 튜플을 만들어 자신의 학번을 저장하라. 길이가 1인 튜플을 만들어 자신의 영문이름을 저장하라. 두 튜플을 + 연산자로 합쳐아래와 같은 출력결과를 얻어라.\n(202143052,'guebin')\n\nnote: 출제의도: 튜플의 + 연산, 길이가 1인 튜플\n\n(풀이)\n\na=(202143052,)\nb=('guebin',)\na+b\n\n(202143052, 'guebin')\n\n\n(9) 아래와 같은 list가 있다고 하자.\ntest_lst = [['g',1],['u',5],['e',2],['b',8],['i',2],['n',9]]\ntest_lst와 리스트컴프리헨션을 이용하여 아래를 출력하는 코드를 구현하라.\n['g', 'uuuuu', 'ee', 'bbbbbbbb', 'ii', 'nnnnnnnnn']\n\nnote: 출제의도: 스트링의 + 연산, 리스트 컴프리헨션\n\n(풀이)\n\ntest_lst = [['g',1],['u',5],['e',2],['b',8],['i',2],['n',9]]\n[i*j for i,j in test_lst]\n\n['g', 'uuuuu', 'ee', 'bbbbbbbb', 'ii', 'nnnnnnnnn']\n\n\n(10) 다음은 학생들의 출석,레포트,중간고사,기말고사 점수를 입력으로 하여 학점을 계산하는 함수이다.\n\ndef grade(attendance, report, mid, final): \n    if attendance&lt;70: \n        credit = 'F' \n    else: \n        total_score = attendance * 0.1 + report * 0.2 + mid * 0.3 + final * 0.4 \n        if total_score &gt; 80: \n            credit = 'A+' \n        else:\n            credit = 'B0' \n    return credit \n\n아래는 학생들의 학번, 출석점수, 레포트, 중간고사, 기말고사 점수가 입력된 리스트이다.\n\ndata = [['202212345', [100,95,25,90]],\n        ['202212346', [60,90,95,95]],\n        ['202212347', [50,90,45,35]],\n        ['202212348', [90,90,50,75]],\n        ['202212349', [100,95,85,85]],\n        ['202212350', [90,90,100,95]],\n        ['202212351', [100,95,100,95]],\n        ['202212352', [95,85,80,60]],\n        ['202212353', [100,90,60,55]],\n        ['202212354', [100,85,70,95]],\n        ['202212355', [100,95,40,100]]]\n\n아래의 ???를 적절하게 완성하여 학생들의 학점을 계산하는 코드를 완성하라.\n[grade(???) for _, scores in data] \n\nnote: 출제의도: dummy variable _, 언패킹연산자 *, for문과 튜플언패킹, 리스트컴프리헨션\n\n(풀이)\n\n[grade(*scores) for _, scores in data] \n\n['B0', 'F', 'F', 'B0', 'A+', 'A+', 'A+', 'B0', 'B0', 'A+', 'A+']\n\n\n(11) 길이가 0인 문자열을 선언하라.\n\nnote: 출제의도: 길이가 0인 문자열\n\n(풀이)\n\nlen('')\n\n0\n\n\n\n(12)-(15)\n(12) dir(plt)와 dir(np)를 각각 실행하라. 실행결과를 각각 a,b로 저장하라. a,b의 type은 무엇인가?\n\nnote: 출제의도: type사용법\n\n(풀이)\n\na=dir(plt)\nb=dir(np)\ntype(a),type(b)\n\n(list, list)\n\n\n(13) a의 원소와 b의 원소의 수를 각각 구하라.\n\nnote: 출제의도: len의 사용법 및 응용\n\n(풀이)\n\nlen(a),len(b)\n\n(254, 611)\n\n\n(14) a와 b의 공통원소의 수를 구하라.\n\nnote: 출제의도: set에서 & 연산자 이용\n\n(풀이)\n\nlen(set(a)&set(b))\n\n9\n\n\n(15) a와 b의 원소를 합친 리스트를 만들어라. (공통원소는 중복하여 합치지 않는다)\n\nnote: 출제의도: set에서 | 연산자 이용\n\n(풀이)\n\nlst = list(set(a)|set(b))\n\n\n(16)-(18) 아래와 같은 dictionary가 있다.\n\ntest_dic = {'202212345': {'att':100,'rep':95,'mid':25,'fin':90},\n            '202212346': {'att':60,'rep':90,'mid':95,'fin':95},\n            '202212347': {'att':50,'rep':90,'mid':45,'fin':35},\n            '202212348': {'att':90,'rep':90,'mid':50,'fin':75},\n            '202212349': {'att':100,'rep':95,'mid':85,'fin':85},\n            '202212350': {'att':90,'rep':90,'mid':100,'fin':95},\n            '202212351': {'att':100,'rep':95,'mid':100,'fin':95},\n            '202212352': {'att':95,'rep':85,'mid':80,'fin':60},\n            '202212353': {'att':100,'rep':90,'mid':60,'fin':55},\n            '202212354': {'att':100,'rep':85,'mid':70,'fin':95},\n            '202212355': {'att':100,'rep':95,'mid':40,'fin':100}}\n\n여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다.\n(16) get 메소드를 이용하여 202212353에 해당하는 학생의 성적을 아래와 같이 리턴하라.\n{'att': 100, 'rep': 90, 'mid': 60, 'fin': 55}\n\nnote: 출제의도: 딕셔너리에서 get 메소드 이용\n\n(풀이)\n\ntest_dic.get('202212353')\n\n{'att': 100, 'rep': 90, 'mid': 60, 'fin': 55}\n\n\n(17) 202212354의 레포트 점수를 리턴하라.\n\nnote: 출제의도: 딕셔너리에서 key를 이용한 원소추출\n\n(풀이)\n\ntest_dic['202212354']['rep']\n\n85\n\n\n(18) 학생들의 학번을 리턴하는 코드를 작성하라.\n\nnote: 출제의도: 딕셔너리와 for문\n\n(풀이)\n\n[k for k in test_dic]\n\n['202212345',\n '202212346',\n '202212347',\n '202212348',\n '202212349',\n '202212350',\n '202212351',\n '202212352',\n '202212353',\n '202212354',\n '202212355']\n\n\n\n(19) shape이 ()인 numpy이 array를 만들어라. (즉 차원이 0인 np.array를 만들어라)\n\nnote: 출제의도: 0차원인 numpy array\n\n(풀이)\n\nnp.array(3).shape\n\n()\n\n\n(20) shape이 (2,2)인 단위행렬을 만들어라.\n\nnote: 출제의도: 넘파이에서의 배열선언\n\n(풀이)\n\nnp.array([[1,0],[0,1]])\n\narray([[1, 0],\n       [0, 1]])\n\n\n(21) a의 모든 원소에 1을 더하는 코드를 작성하라.\na=[1,3,2,5,-3,3,8,2,3,1] \n\nnote: 출제의도: 브로드캐스팅\n\n(풀이)\n\nnp.array([1,3,2,5,-3,3,8,2,3,1])+1\n\narray([ 2,  4,  3,  6, -2,  4,  9,  3,  4,  2])\n\n\n(22) 아래와 같은 수열을 생성하라.\n1,3,6,10,15,21,28,36,45, ... , 378, 406, 435\nhint: 이 수열에서 \\(a_n-a_{n-1}=n, ~n\\geq 2\\) 이다. 즉 3-1=2, 6-3=3, 10-6=4, …\n\nnote: 출제의도: np.arange, cumsum\n\n(풀이)\n\n435-406\n\n29\n\n\n\nnp.arange(1,30).cumsum()\n\narray([  1,   3,   6,  10,  15,  21,  28,  36,  45,  55,  66,  78,  91,\n       105, 120, 136, 153, 171, 190, 210, 231, 253, 276, 300, 325, 351,\n       378, 406, 435])\n\n\n(23) 아래와 같은 수열을 생생성하라.\n0,1,2,3,4,5,...,99 \n위의 수열에서 1,4,7,10,13,… 번째의 원소를 뽑아라. (첫번째 원소는 0이다)\n\nnote: 출제의도: np.arange, 스트라이딩\n\n(풀이)\n\nnp.arange(100)[::3]\n\narray([ 0,  3,  6,  9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48,\n       51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99])\n\n\n(24) numpy를 이용하여 아래의 역행렬을 구하라. \\[\\begin{bmatrix}\n1&  0 \\\\\n0&  3\n\\end{bmatrix}\\]\n\nnote: 출제의도: np.linalg.inv\n\n(풀이)\n\nnp.linalg.inv(np.array([[1,0],[0,3]]))\n\narray([[1.        , 0.        ],\n       [0.        , 0.33333333]])\n\n\n\n(25)-(30)\na,b가 아래와 같이 주어졌다고 하자.\n\na=[1]*10 \nb=[2]*10 \n\n(25) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([a,b])\n\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n\n\n(26) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([[1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2]])\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([np.array(a).reshape(-1,1),np.array(b).reshape(-1,1)])\n\narray([[1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [1],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2],\n       [2]])\n\n\n(27) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([np.array(a).reshape(1,-1),np.array(b).reshape(1,-1)])\n\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]])\n\n\n(28) a,b와 np.concatenate를 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\nnp.concatenate([np.array(a).reshape(-1,1),np.array(b).reshape(-1,1)],axis=1)\n\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\n\n(29) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]\n(풀이)\n\nnp.stack([a,b])\n\narray([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n       [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]])\n\n\n\nnote: 출제의도: np.stack\n\n(30) a,b와 np.stack을 이용하여 아래와 같은 배열을 만들어라.\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\nnote: 출제의도: np.stack\n\n(풀이)\n\nnp.stack([a,b],axis=1)\n\narray([[1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2],\n       [1, 2]])\n\n\n(31) 아래와 같은 배열이 있다고 하자.\n\na=np.array([1,2,3,4,5])\nb=np.array([3,2,1,1,2])\n\nnumpy의 @ 연산자를 이용하여 \\(\\sum_{i=1}^{5}a_ib_i\\)를 계산하라.\n\nnote: 출제의도: @연산자의 계산 및 해석\n\n(풀이)\n\na@b\n\n24\n\n\n(32) 아래와 같은 배열을 생성하라.\nx=np.random.randn(100)\nnumpy의 @연산자를 이용하여 \\(\\sum_{i=1}^{100}x_i^2\\)을 계산하라.\n\nnote: 출제의도: @연산자의 계산 및 해석\n\n(풀이)\n\nx=np.random.randn(100)\nx@x\n\n69.28009497479688\n\n\n(33) 아래와 같은 배열을 생성하라.\na=np.array([1/100]*100)\nx=np.random.randn(100)\nnumpy의 @연산자를 이용하여 \\(\\frac{1}{n}\\sum_{i=1}^{n}x_i\\)를 계산하라.\n\nnote: 출제의도: @연산자의 계산 및 해석\n\n(풀이)\n\na=np.array([1/100]*100)\nx=np.random.randn(100)\na@x\n\n-0.010052841585430794\n\n\n(34) 표준정규분포에서 100개의 난수를 생성하라.\n\nnote: 출제의도: 표준정규분포 생성\n\n(풀이)\n\nnp.random.randn(100)\n\narray([ 1.85418429,  1.74095494,  1.84238756,  0.11833414,  0.50517813,\n       -0.69557289, -1.72748266, -0.26601374,  0.57719853,  0.18027158,\n       -0.42542364,  0.85536403, -0.58893928,  0.55397097, -1.5535881 ,\n       -0.88229423, -0.71875421, -0.43570715, -0.30980515, -0.36179948,\n       -0.17548155,  1.44052988, -0.59466028,  0.17292887, -0.59491904,\n       -1.9695988 ,  0.11928747,  1.28964429,  0.53823904, -1.18030647,\n       -0.20558282, -1.08160482,  0.83372329,  0.28800561,  0.15599112,\n       -1.03586037, -1.06770958, -2.71210449,  0.58241292,  0.69235475,\n        1.37391505, -0.0326631 , -0.12266586, -0.20292358, -0.27657851,\n        0.56420234,  0.40045754, -0.63219726,  0.40820948, -0.612829  ,\n       -1.28695191,  0.46508036,  0.2463253 , -0.27429529, -0.65675501,\n       -1.01875321, -0.69944952, -0.31570476,  0.3646879 , -1.1631018 ,\n       -1.20414629, -0.90456531,  0.89434359, -0.29053615,  1.16408738,\n        0.71108284, -0.52138787,  1.07033411,  1.72342412,  0.90605155,\n       -0.28896114, -1.89628331, -1.71603025,  1.21529517,  0.23833153,\n       -0.52176073, -0.49144623, -0.75427022,  0.10468367,  0.36750664,\n        0.24346823,  0.20762347,  1.08915492,  1.89502878,  1.91479936,\n       -0.4241885 , -1.05989046,  0.96622936,  0.40962212, -2.16589513,\n        0.45357349, -1.23802044,  0.39859558,  0.02910548,  1.44679724,\n        1.16285902, -0.1593022 , -2.14983146,  0.42739322, -0.94301164])\n\n\n(35) 아래와 동일한 코드를 np.random.rand()로 구현하라.\nnp.random.uniform(low=2,high=4,size=(5,)) \n\nnote: 출제의도: np.random.rand, np.random.uniform\n\n(풀이)\n\nnp.random.rand(5)*2+2\n\narray([3.62616239, 2.4038075 , 2.64420359, 2.80481305, 2.2678642 ])\n\n\n(36) 아래와 같은 배열을 선언하라.\na=np.random.randn(100) \nnp.where를 이용하여 a의 모든 음수를 0으로 바꾸는 코드를 작성하라.\n\nnote: 출제의도: np.where 을 이용한 마스킹\n\n(풀이)\n\na=np.random.randn(100)\nnp.where(a&lt;0,0,a)\n\narray([0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 6.23392366e-01,\n       0.00000000e+00, 1.08600932e+00, 3.67178107e-01, 0.00000000e+00,\n       2.20251453e-01, 0.00000000e+00, 0.00000000e+00, 3.89764950e-02,\n       6.86794220e-01, 6.89479404e-01, 1.26211471e+00, 0.00000000e+00,\n       4.23611162e-01, 8.19460987e-01, 3.14530150e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 1.30354361e+00, 0.00000000e+00,\n       0.00000000e+00, 4.40581127e-01, 0.00000000e+00, 0.00000000e+00,\n       7.86386724e-01, 1.92151119e-02, 0.00000000e+00, 0.00000000e+00,\n       0.00000000e+00, 3.23260088e-01, 0.00000000e+00, 7.13352290e-01,\n       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 7.01771469e-01,\n       0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 1.01926360e+00,\n       0.00000000e+00, 1.00933996e+00, 0.00000000e+00, 5.55528483e-01,\n       5.99763436e-01, 0.00000000e+00, 1.35136571e-01, 1.35928670e-02,\n       9.35722269e-01, 0.00000000e+00, 8.64547752e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 1.68682634e+00, 0.00000000e+00,\n       1.07091321e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00,\n       8.27772542e-01, 0.00000000e+00, 7.65702396e-01, 0.00000000e+00,\n       0.00000000e+00, 3.29389519e-01, 0.00000000e+00, 2.51416616e-01,\n       0.00000000e+00, 8.17591580e-01, 0.00000000e+00, 1.09930438e-01,\n       8.71101099e-04, 2.17063699e-01, 2.06385934e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 3.19516814e-01, 5.92549379e-02,\n       1.92857588e+00, 1.39519785e+00, 3.77551912e-01, 0.00000000e+00,\n       0.00000000e+00, 0.00000000e+00, 5.16744013e-01, 0.00000000e+00,\n       1.87178822e+00, 1.75448718e+00, 3.40204387e-01, 7.69851631e-01])\n\n\n(37) 아래와 같은 배열을 선언하라.\na=np.random.randn(100) \n위 배열의 최소값이 위치한 index를 return하라.\n\nnote: 출제의도: np.where\n\n(풀이)\n\na=np.random.randn(100)\nnp.where(a==np.min(a))\n\n(array([92]),)\n\n\n(38) 아래와 같은 배열을 선언하라.\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n차원의 수를 유지하면서 1열을 추출하는 코드를 작성하라. 즉 결과가 아래와 같이 나오도록 하라.\narray([[0],\n       [4],\n       [8]])\n\nnote: 출제의도: 차원을 유지하는 인덱싱\n\n(풀이)\n\na[:,[0]]\n\narray([[0],\n       [4],\n       [8]])\n\n\n(39)-(40)\n(39) 자신의 학번으로 random seed 를 설정하라. [20,25)의 범위에서 100개의 정수를 랜덤으로 생성해 (10,10) shape의 배열을 만들어라.\n\nnote: 출제의도: np.random.randint\n\n(풀이)\n\nnp.random.seed(43052)\na=np.random.randint(low=20,high=25,size=(10,10))\n\n(40) 39의 결과에서 20,21,22 는 각각 몇개씩 있는가?\n\nnote: 출제의도: bool형의 sum\n\n(풀이)\n\nnp.sum(a==20),np.sum(a==21),np.sum(a==22)\n\n(17, 20, 19)"
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-05-03-mid.html#코드구현-ii-50점",
    "href": "PP2023/posts/Appendix/2022-05-03-mid.html#코드구현-ii-50점",
    "title": "참고자료: 2022-04-mid",
    "section": "2. 코드구현 II (50점)",
    "text": "2. 코드구현 II (50점)\n\n(1)-(6) 아래의 코드를 실해하여 test_dic를 생성하라.\n\nnp.random.seed(43052)\natt = np.random.choice(np.arange(10,21)*5,200)\nrep = np.random.choice(np.arange(5,21)*5,200)\nmid = np.random.choice(np.arange(0,21)*5,200)\nfin = np.random.choice(np.arange(0,21)*5,200)\nkey = ['202212'+str(s) for s in np.random.choice(np.arange(300,501),200,replace=False)]\ntest_dic = {key[i] : {'att':att[i], 'rep':rep[i], 'mid':mid[i], 'fin':fin[i]} for i in range(200)}\ndel(att);del(rep);del(mid);del(fin);del(key)\n\n여기에서 202212345등은 학번을, att는 출석점수, rep는 레포트점수, mid는 중간고사점수, fin은 기말고사 점수를 의미한다.\n(1) test_dic에서 출석점수가 70이상(70&gt;=)인 학생들의 학번을 출력하는 코드를 작성하라.\n\nnote: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nids= [k for k in test_dic if test_dic[k]['att']&gt;=70]\n\n(2) test_dic에서 출석점수가 70미만(&lt;70)인 학생들의 수를 구하라.\n\nnote: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nlen([k for k in test_dic if test_dic[k]['att']&lt;70])\n\n70\n\n\n\nsum([test_dic[k]['att']&lt;70 for k in test_dic])\n\n70\n\n\n(3) test_dic에서 출석점수가 70이상(70&gt;=)인 학생들의 중간고사 점수의 평균을 계산하라.\n\nnote: 출제의도: if문이 포함된 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nnp.mean([test_dic[k]['mid'] for k in test_dic if test_dic[k]['att']&gt;=70])\n\n57.15384615384615\n\n\n(4) test_dic에서 중간고사 점수를 출력하는 코드를 작성하라.\n\nnote: 출제의도: 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\nmid=[test_dic[k]['mid'] for k in test_dic]\n\n(5) test_dic에서 중간고사 점수의 표준편차와 레포트점수의 표준편차를 구하여라. 어떤것이 더 큰가?\n\nnote: 출제의도: 리스트컴프리헨션, for문과 딕셔너리, np.std\n\n(풀이)\n\nnp.std([test_dic[k]['mid'] for k in test_dic]),np.std([test_dic[k]['rep'] for k in test_dic])\n\n(29.88243631299162, 22.626533097229014)\n\n\n(6) test_dic에서 중간고사 점수가 가장 높은 사람의 학번을 출력하라.\n주의: att,rep,mid,fin,key를 실행하여 소멸시키지 않고 그대로 이용하거나 np.random.choice()를 이용하여 재생성한 뒤 계산할 경우 0점 처리함. - 예를들면 (5)의 경우 np.std(mid), np.std(rep) 와 같은 식으로 구현하면 0점 처리함.\n\nnote: 출제의도: 리스트컴프리헨션, for문과 딕셔너리\n\n(풀이)\n\n[k for k in test_dic if test_dic[k]['mid']==max(mid)]\n\n['202212326',\n '202212463',\n '202212383',\n '202212341',\n '202212417',\n '202212401',\n '202212405',\n '202212369',\n '202212403',\n '202212407',\n '202212315']\n\n\n\n(7) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번의 시행하였을 경우 73번 이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라.\n\nnote: 출제의도: np.random.binomial, bool형의 합\n\n(풀이)\n\nsum(np.random.binomial(n=100,p=0.45,size=(1000,)) &gt;= 73)\n\n0\n\n\n(8) 성공확률이 0.45인 시행이 있다고 하자. 이 시행을 100번 시행하였을 경우 10번이하로 실패하거나 90번이상 성공할 확률은 얼마인가? 시뮬레이션을 이용하여 근사계산하라.\n\nnote: 출제의도: np.random.binomial, bool형의 합\n\n(풀이)\n\na=np.random.binomial(n=100,p=0.45,size=(1000,))\nsum((a&gt;=90) | (a&lt;=10))\n\n0\n\n\n\nsum(a&gt;=90) + sum(a&lt;=10) # 이것도 좋은 풀이\n\n0\n\n\n(9) 아래와 같은 행렬을 선언하자.\n\nA=np.arange(2*1).reshape(2,1)\nB=np.arange(2*2).reshape(2,2)\nC=np.arange(2*3).reshape(2,3)\nD=np.arange(3*3).reshape(3,3)\nE=np.arange(3*2).reshape(3,2)\nF=np.arange(3*1).reshape(3,1)\n\n아래의 블락매트릭스를 만들어라.\n\\(\\begin{bmatrix} a_{11} & b_{11} & b_{12} & c_{11} & c_{12} & c_{13} \\\\ a_{21} & b_{21} & b_{22} & c_{21} & c_{22} & c_{23} \\\\ d_{11} & d_{12} & d_{13} & e_{11} & e_{12} & f_{11} \\\\ d_{21} & d_{22} & d_{23} & e_{21} & e_{22} & f_{21} \\\\ d_{31} & d_{32} & d_{33} & e_{31} & e_{32} & f_{31} \\end{bmatrix}\\)\n여기에서 \\(a_{ij}\\)는 매트릭스 \\({\\bf A}\\)의 원소이다.\n\nnote: 출제의도: np.concatenate\n\n(풀이)\n\ntop = np.concatenate([A,B,C],axis=1)\nbottom = np.concatenate([D,E,F],axis=1)\nnp.concatenate([top,bottom],axis=0)\n\narray([[0, 0, 1, 0, 1, 2],\n       [1, 2, 3, 3, 4, 5],\n       [0, 1, 2, 0, 1, 0],\n       [3, 4, 5, 2, 3, 1],\n       [6, 7, 8, 4, 5, 2]])\n\n\n(10) 표준정규분포에 10000개의 난수를 아래와 같이 생성하라.\n\nx=np.random.randn(10000)\ny=np.random.randn(10000)\n\n\\((i,j)\\) 번째 원소가 \\((x_i-y_j)^2\\)인 (10000,10000) 매트릭스를 만들어라.\n\nnote: 출제의도: 브로드캐스팅\n\n(풀이)\n\n(x.reshape(10000,1) - y.reshape(1,10000))**2\n\narray([[9.94471594e-01, 1.59617444e+00, 4.89939117e-01, ...,\n        5.85763251e-02, 8.71831383e-01, 4.48231705e-02],\n       [3.82650425e-01, 7.82788668e-01, 1.16338019e+00, ...,\n        3.85231232e-01, 1.72229831e+00, 3.48524169e-01],\n       [2.19381916e-03, 4.81046770e-02, 3.04162913e+00, ...,\n        1.65404203e+00, 3.91165053e+00, 1.57699602e+00],\n       ...,\n       [4.06902110e-02, 4.15352671e-03, 3.60584637e+00, ...,\n        2.07641061e+00, 4.54827803e+00, 1.98997559e+00],\n       [6.35135252e-01, 1.13022358e+00, 8.10422594e-01, ...,\n        1.95632560e-01, 1.28594998e+00, 1.69738287e-01],\n       [3.93009857e+00, 5.05626325e+00, 8.13727798e-02, ...,\n        5.52331661e-01, 2.65189382e-03, 5.98303522e-01]])\n\n\n\n(11)-(16)\n아래와 같은 매트릭스를 생성하라.\n\nnp.random.seed(43052)\na=np.random.randn(10000).reshape(100,100)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825, ..., -0.18506968,\n         1.05538764,  1.18701443],\n       [-0.25027283, -1.58045215,  0.1124153 , ...,  1.0321894 ,\n         0.40438012, -0.13491595],\n       [-0.76763724, -0.64294232, -0.24782396, ..., -0.01530161,\n         0.89125897, -0.82683395],\n       ...,\n       [-1.41379028,  0.79611333, -0.71011837, ..., -0.9860352 ,\n         1.30755244,  2.18677233],\n       [ 1.33968105, -0.78457449, -0.10405858, ..., -0.71110186,\n         0.99841286,  2.34371635],\n       [-0.66422032, -0.07550233,  0.7405869 , ...,  1.03232398,\n        -0.18988252, -0.03578389]])\n\n\n(11) 각 행의 합을 구하라. 즉 1행의 합, 2행의 합, … 100행의 합을 계산하라. - 1행의합 = 0.38342049 + 1.0841745 + … + 1.18701443\n\nnote: 출제의도: np.sum with axis\n\n(풀이)\n\na.sum(axis=1)\n\narray([-8.13607922e+00,  9.87120533e+00, -1.41434956e+01, -2.21705363e+00,\n       -1.45535236e+01, -9.15821678e+00, -2.59866360e+00, -1.54562385e+01,\n       -1.42005088e+00, -3.51523111e+00,  9.70487578e+00, -1.26229105e+01,\n        1.66837113e+00,  2.43015457e+00,  2.72990184e+00, -7.99486429e+00,\n       -8.38305954e-01, -8.45002020e+00, -1.03610098e+00,  2.07251861e+01,\n        1.11461478e+01,  7.62144075e+00, -7.93734585e+00,  1.82844319e+01,\n       -2.63562392e+00, -8.97916930e+00, -1.88986183e+00, -9.32477049e+00,\n       -6.69074565e+00, -1.42463143e+01,  6.45540510e-01,  1.80911488e+00,\n        2.40997157e+00,  1.63367254e+01,  7.63990677e+00,  8.13524813e+00,\n        3.97159000e+00, -1.10542949e+00,  4.37564512e-01,  2.87299971e+00,\n       -4.01016768e+00,  5.71115215e+00, -4.64132698e+00, -9.13987753e+00,\n       -6.78326000e+00,  3.36308150e+00, -5.13704342e+00, -5.09782466e+00,\n        6.54192465e-03,  7.19722660e+00, -4.64674820e+00, -9.24124039e+00,\n        6.73530841e+00,  1.12168921e+00,  1.61615988e+00,  1.37602200e+01,\n        6.67289840e-01, -2.09578108e+00, -2.81826564e-01, -8.52416541e+00,\n       -7.21970047e+00,  2.27146777e+01, -1.40341974e+01,  1.69263136e+01,\n       -1.80568372e+01,  6.52142336e+00, -1.73092812e+01, -1.34999285e+01,\n       -7.85539317e+00, -4.74940393e-01, -2.75765037e+01,  8.74991555e+00,\n       -9.77324158e+00,  1.42854121e+01, -1.10130356e+00, -1.39206483e-01,\n       -1.54638921e+01,  1.36814794e+00,  8.41394160e+00, -2.42153833e+00,\n       -2.57155344e+01, -6.72423820e+00, -9.49366257e-01,  3.79493472e+00,\n       -6.23508582e+00,  7.75657189e+00,  9.69403620e+00,  1.46847519e+01,\n        7.36500792e+00, -2.54755192e+01,  1.22792449e+01, -1.02497847e+01,\n        1.30452028e+01,  3.92943038e+00, -3.27227585e+00, -1.06633071e+01,\n       -1.56942302e+01,  8.01451222e+00,  2.81546938e+00,  5.56774384e+00])\n\n\n(12) (11)의 결과로 나온 배열의 표준편차를 구하라.\n\nnote: 출제의도: np.sum with axis, np.std\n\n(풀이)\n\na.sum(axis=1).std()\n\n9.98012658863081\n\n\n(13) 각 열의 평균을 구하라. 즉 1열의 평균, 2열의 평균, … , 100열의 평균을 계산하라.\n\nnote: 출제의도: np.sum with axis\n\n(풀이)\n\na.sum(axis=0)\n\narray([ 5.05543481e-01, -8.11250975e-01, -7.27142023e-01,  9.64876493e+00,\n        5.64186324e+00, -2.22728206e+00,  1.32808256e-02, -9.60905067e+00,\n        9.42144096e+00, -1.21946518e+01, -2.21878576e+00, -3.77018716e+00,\n        2.35739166e-01, -1.13202128e+01, -9.00374437e+00, -3.09372275e+00,\n       -2.18029121e+00,  7.04210003e+00, -4.12563112e+00,  2.58233488e+00,\n        1.16578817e+01, -1.59430241e+01, -1.53668953e+00,  9.21879710e+00,\n       -1.11346500e+01, -1.20131585e+01,  5.94139652e+00, -3.27022797e+00,\n       -1.46466366e+00, -1.78386785e+00, -1.06650333e+01, -9.04542721e+00,\n       -8.52586244e+00,  5.52166280e+00,  1.94115122e+01,  4.64389603e+00,\n        5.13636914e+00,  1.11424801e+01, -4.18629084e+00,  9.23822150e+00,\n       -2.00433998e+00, -5.73784795e+00, -8.79928414e+00, -3.01766235e+00,\n        6.47256326e+00,  3.14419234e+00, -1.16146865e+01, -1.04800787e+01,\n        3.17924308e+00,  5.51687322e+00,  1.04913214e+01, -2.79741703e-01,\n        2.56767141e+01, -1.35620430e+01, -9.59492302e+00,  1.23241275e+01,\n       -5.26436946e-01, -3.14823093e+00, -4.00286104e+00, -1.48618576e+01,\n        4.85988487e+00, -1.37972086e+01, -1.04715966e+01, -7.13893940e+00,\n        4.35483376e+00, -2.10610822e+01, -1.03231108e+01, -1.62132451e+01,\n        2.85187037e+01, -8.25697744e+00,  4.33723229e+00,  1.32763889e+00,\n       -1.61919484e+01, -5.07924036e+00,  6.62243327e+00, -9.72863991e+00,\n        2.71962223e+01, -5.97710822e+00,  1.54580795e+01, -5.46739064e+00,\n       -1.08611574e+01, -1.56520706e+01, -1.40476317e+01,  1.06067589e+01,\n       -3.46141736e+00, -6.07673046e+00,  5.33471760e-01,  8.10276105e+00,\n       -1.31994569e+01, -1.00936968e+00,  6.13944222e+00, -9.72765699e+00,\n        1.61342793e+01,  1.02634369e+01, -5.03038014e+00, -7.50604837e+00,\n        2.63992605e+00,  6.98470602e+00, -1.89567885e+01,  7.91910813e+00])\n\n\n(14) (13)의 결과로 나온 배열의 표준편차를 구하라.\n\nnote: 출제의도: np.sum with axis, np.std\n\n(풀이)\n\na.sum(axis=0).std()\n\n9.944992000065781\n\n\n(15) a의 원소중 a&gt;0 을 만족하는 원소의 평균을 구하여라.\n\nnote: 출제의도: bool을 이용한 인덱싱\n\n(풀이)\n\na[a&gt;0].mean()\n\n0.7879030416692301\n\n\n(16) a의 원소중 a&gt;3을 만족하는 원소의 수를 count하라.\n\nnote: 출제의도: bool의 sum\n\n(풀이)\n\nnp.sum(a&gt;3)\n\n17\n\n\n\n(17)-(18)\n아래와 같은 배열 a를 고려하자.\n\nnp.random.seed(43052)\na=np.random.binomial(1,0.2,size=(10000,))\na\n\narray([1, 0, 1, ..., 1, 1, 0])\n\n\n(17) 0에서 1로 바뀌는 부분을 count하라.\n\nnote: 출제의도: np.diff 응용\n\n(풀이)\n\nnp.sum(np.diff(a)==1)\n\n1617\n\n\n(18) 1에서 0으로 바뀌는 부분을 count하라.\n[예시] 아래의 배열에서 0에서 1로 부분은 모두 세 군데이고, 1에서 0으로 바뀌는 부분은 모두 두 군데 이다.\n0 0 0 1 0 1 0 0 0 1 1 1 \n\nnote: 출제의도: np.diff 응용\n\n(풀이)\n\nnp.sum(np.diff(a)==-1)\n\n1618\n\n\n\n(19)-(25)\n(19) \\(i=1,2,\\dots,1000\\)에 대하여 아래를 각각 구하라.\n\\[x_i= \\cos(t_i)+\\cos(3t_i)+\\cos(5t_i)\\]\n\\[y_i= \\sin(t_i)+\\sin(4t_i)\\]\n여기에서 \\(t_i=\\frac{2\\pi i }{1000}\\) 이다.\n\nnote: 출제의도: numpy를 이용한 수식표현\n\n(풀이)\n\ni=np.arange(1,1001)\nt=i*2*np.pi/1000\nx=np.cos(t)+np.cos(3*t)+np.cos(5*t) \ny=np.sin(t)+np.sin(4*t) \n\n(20) \\((x_i,y_i)\\)를 그려라.\n\nnote: 출제의도: plt.plot\n\n(풀이)\n\nplt.plot(x,y)\n\n\n\n\n(21) 아래와 같은 변환을 통하여 \\((w_i,z_i)\\)를 얻어라.\n\\[w_i= \\frac{1}{\\sqrt{2}}x_i - \\frac{1}{\\sqrt{2}}y_i\\]\n\\[z_i= \\frac{1}{\\sqrt{2}}x_i + \\frac{1}{\\sqrt{2}}y_i\\]\n\\((w_i,z_i)\\)를 시각화 하라.\n\nnote: 출제의도: numpy를 이용한 연산, plt.plot\n\n(풀이)\n\nw = 1/np.sqrt(2)*x -  1/np.sqrt(2)*y\nz = 1/np.sqrt(2)*x +  1/np.sqrt(2)*y\nplt.plot(w,z)\n\n\n\n\n(22) 아래와 같은 매트릭스를 만들어라.\n\\[{\\bf A}=\\begin{bmatrix}\nx_1 & y_1 \\\\\nx_2 & y_2 \\\\\n\\dots & \\dots \\\\\nx_n & y_n\n\\end{bmatrix}\\]\n\nnote: 출제의도: np.stack\n\n(풀이)\n\nA=np.stack([x,y]).T\nA\n\narray([[ 2.99930917e+00,  3.14132394e-02],\n       [ 2.99723725e+00,  6.28103581e-02],\n       [ 2.99378587e+00,  9.41752452e-02],\n       ...,\n       [ 2.99723725e+00, -6.28103581e-02],\n       [ 2.99930917e+00, -3.14132394e-02],\n       [ 3.00000000e+00, -1.22464680e-15]])\n\n\n\nA=np.stack([x,y],axis=1)\nA\n\narray([[ 2.99930917e+00,  3.14132394e-02],\n       [ 2.99723725e+00,  6.28103581e-02],\n       [ 2.99378587e+00,  9.41752452e-02],\n       ...,\n       [ 2.99723725e+00, -6.28103581e-02],\n       [ 2.99930917e+00, -3.14132394e-02],\n       [ 3.00000000e+00, -1.22464680e-15]])\n\n\n(23) \\({\\bf A} {\\bf B}\\)의 첫번째 열과 두번째 열을 시각화한 결과가 \\((w_i,z_i)\\)과 동일하도록 적당한 (2,2) 매트릭스 \\({\\bf B}\\)를 만들어라.\n\nnote: 출제의도: 행렬의 수식표현, 행렬의 곱\n\n(풀이)\n\nB= np.array([[1/np.sqrt(2), 1/np.sqrt(2)],[-1/np.sqrt(2), 1/np.sqrt(2)]])\n#B= np.array([[1, 1],[-1, 1]])/np.sqrt(2)\nplt.plot(A@B[:,0],A@B[:,1])\n\n\n\n\n(24) \\({\\bf A}{\\bf B}^2\\)의 첫번째 열과 두번째 열을 시각화 하라.\n\nnote: 출제의도: 행렬의 곱\n\n(풀이)\n\nplt.plot((A@B@B)[:,0],(A@B@B)[:,1])\n\n\n\n\n(25) \\(n=3,4,5,6,\\dots\\) 에 대하여 \\({\\bf A}{\\bf B}^n\\)을 반복적으로 그려보라. \\((x_i,y_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n\\)은 얼마인가? \\((w_i,z_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n\\)은 얼마인가?\n\nnote: 출제의도: 회전변환의 유추, 역행렬의 개념응용\n\n(풀이)\n\nplt.plot((A@B@B@B)[:,0],(A@B@B@B)[:,1]) ## n=3\n\n\n\n\n\nplt.plot((A@B@B@B@B)[:,0],(A@B@B@B@B)[:,1]) ## n=4\n\n\n\n\n\n(B@B)@(B@B)@(B@B)@(B@B)\n\narray([[1., 0.],\n       [0., 1.]])\n\n\n\n(B@B)@(B@B)@(B@B)@(B@B)@B\n\narray([[ 0.70710678,  0.70710678],\n       [-0.70710678,  0.70710678]])\n\n\n\n답: \\((x_i,y_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n=8\\) 이고 \\((w_i,z_i)\\)의 시각화 결과와 동일한 가장 작은 \\(n=9\\) 이다."
  },
  {
    "objectID": "PP2023/posts/Appendix/2022-05-03-mid.html#다음을-잘-읽고-물음에-답하라.-10점",
    "href": "PP2023/posts/Appendix/2022-05-03-mid.html#다음을-잘-읽고-물음에-답하라.-10점",
    "title": "참고자료: 2022-04-mid",
    "section": "3. 다음을 잘 읽고 물음에 답하라. (10점)",
    "text": "3. 다음을 잘 읽고 물음에 답하라. (10점)\n(1) 아래는 python을 설치하는 방법을 소개한 url 이다. 직접 url에 들어가서 설치하는 방법을 읽어보고 곤이, 철용, 아귀, 짝귀 중 옳은말을 한 사람을 모두 골라라.\n\nhttps://www.pythonlikeyoumeanit.com/Module1_GettingStartedWithPython/Installing_Python.html\n\n(곤이) 해당 방법은 아나콘다를 이용하여 파이썬을 설치하는 방법이다.\n(철용) 그래서 이 방법으로는 가상환경을 만들 수 없겠군.\n(아귀) 위 url에 제시된 방법으로 설치하면 주피터가 자동설치 된다.\n(짝귀) 따라서 위의 방법으로 설치하면 IDE는 주피터만 사용할 수 있다.\n\nnote: 출제의도: 아나콘다를 이용한 설치\n\n(2) 곤이는 1부터 10까지의 합을 구하는 코드를 작성하기 위하여 아래와 같이 mysum.py 파일을 만들었다.\n## mysum.py\ntotal = 0 \nfor i in range(1,11): \n    total = total + i\nprint(total)\n곤이의 컴퓨터는 윈도우이며 아니콘다를 이용해 파이썬을 설치하였다고 가정한다. 다음중 옳은 설명을 한 사람을 모두 고르라.\n(곤이) mysum.py를 실행하기 위해서는 anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 %run mysum.py 를 실행하면 된다.\n(철용) anaconda prompt 에서 mysum.py가 위치한 폴더로 이동한 뒤 ipython을 실행하고 %run mysum.py을 실행해도 된다.\n(아귀) 철용의 방법에서 %run mysum.py 대신에 !python mysum.py를 쳐도 동작한다.\n(짝귀) 하지만 다른 가상환경을 만들 경우 철용과 아귀의 방법으로 실행할 수 없다는 단점이 있다.\n\nnote: 출제의도: *.py 의 사용방법"
  }
]